/************************************************************************
*  File: pcie_diag.c
*
*  Sample user-mode diagnostics application for accessing JSEB2
*  devices using WinDriver's API.
*  Code was generated by DriverWizard v10.21.
*
*  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
*************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include "wdc_defs.h"
#include "wdc_lib.h"
#include "utils.h"
#include "status_strings.h"
#include "samples/shared/diag_lib.h"
#include "samples/shared/wdc_diag_lib.h"
#include "samples/shared/pci_regs.h"
#include "jseb2_lib.h"

//CFM EDITS
//#include "cppWatch.h"

/*************************************************************
  General definitions
 *************************************************************/
/* Error messages display */
#define JSEB2_ERR printf

/*************************************************************
  Global variables
 *************************************************************/
/* User's input command */
static CHAR gsInput[256];

/* --------------------------------------------------
    JSEB2 configuration registers information
   -------------------------------------------------- */
/* Configuration registers information array */
const WDC_REG gJSEB2_CfgRegs[] = {
    { WDC_AD_CFG_SPACE, PCI_VID, WDC_SIZE_16, WDC_READ_WRITE, "VID", "Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_DID, WDC_SIZE_16, WDC_READ_WRITE, "DID", "Device ID" },
    { WDC_AD_CFG_SPACE, PCI_CR, WDC_SIZE_16, WDC_READ_WRITE, "CMD", "Command" },
    { WDC_AD_CFG_SPACE, PCI_SR, WDC_SIZE_16, WDC_READ_WRITE, "STS", "Status" },
    { WDC_AD_CFG_SPACE, PCI_REV, WDC_SIZE_32, WDC_READ_WRITE, "RID_CLCD", "Revision ID & Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCSC, WDC_SIZE_8, WDC_READ_WRITE, "SCC", "Sub Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCBC, WDC_SIZE_8, WDC_READ_WRITE, "BCC", "Base Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CLSR, WDC_SIZE_8, WDC_READ_WRITE, "CALN", "Cache Line Size" },
    { WDC_AD_CFG_SPACE, PCI_LTR, WDC_SIZE_8, WDC_READ_WRITE, "LAT", "Latency Timer" },
    { WDC_AD_CFG_SPACE, PCI_HDR, WDC_SIZE_8, WDC_READ_WRITE, "HDR", "Header Type" },
    { WDC_AD_CFG_SPACE, PCI_BISTR, WDC_SIZE_8, WDC_READ_WRITE, "BIST", "Built-in Self Test" },
    { WDC_AD_CFG_SPACE, PCI_BAR0, WDC_SIZE_32, WDC_READ_WRITE, "BADDR0", "Base Address 0" },
    { WDC_AD_CFG_SPACE, PCI_BAR1, WDC_SIZE_32, WDC_READ_WRITE, "BADDR1", "Base Address 1" },
    { WDC_AD_CFG_SPACE, PCI_BAR2, WDC_SIZE_32, WDC_READ_WRITE, "BADDR2", "Base Address 2" },
    { WDC_AD_CFG_SPACE, PCI_BAR3, WDC_SIZE_32, WDC_READ_WRITE, "BADDR3", "Base Address 3" },
    { WDC_AD_CFG_SPACE, PCI_BAR4, WDC_SIZE_32, WDC_READ_WRITE, "BADDR4", "Base Address 4" },
    { WDC_AD_CFG_SPACE, PCI_BAR5, WDC_SIZE_32, WDC_READ_WRITE, "BADDR5", "Base Address 5" },
    { WDC_AD_CFG_SPACE, PCI_CIS, WDC_SIZE_32, WDC_READ_WRITE, "CIS", "CardBus CIS Pointer" },
    { WDC_AD_CFG_SPACE, PCI_SVID, WDC_SIZE_16, WDC_READ_WRITE, "SVID", "Sub-system Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_SDID, WDC_SIZE_16, WDC_READ_WRITE, "SDID", "Sub-system Device ID" },
    { WDC_AD_CFG_SPACE, PCI_EROM, WDC_SIZE_32, WDC_READ_WRITE, "EROM", "Expansion ROM Base Address" },
    { WDC_AD_CFG_SPACE, PCI_CAP, WDC_SIZE_8, WDC_READ_WRITE, "NEW_CAP", "New Capabilities Pointer" },
    { WDC_AD_CFG_SPACE, PCI_ILR, WDC_SIZE_32, WDC_READ_WRITE, "INTLN", "Interrupt Line" },
    { WDC_AD_CFG_SPACE, PCI_IPR, WDC_SIZE_32, WDC_READ_WRITE, "INTPIN", "Interrupt Pin" },
    { WDC_AD_CFG_SPACE, PCI_MGR, WDC_SIZE_32, WDC_READ_WRITE, "MINGNT", "Minimum Required Burst Period" },
    { WDC_AD_CFG_SPACE, PCI_MLR, WDC_SIZE_32, WDC_READ_WRITE, "MAXLAT", "Maximum Latency" },
    };
#define JSEB2_CFG_REGS_NUM sizeof(gJSEB2_CfgRegs) / sizeof(WDC_REG)
/* TODO: For read-only or write-only registers, change the direction field of
         the relevant registers in gJSEB2_CfgRegs to WDC_READ or WDC_WRITE. */
/* NOTE: You can define additional configuration registers in gJSEB2_CfgRegs. */
const WDC_REG *gpJSEB2_CfgRegs = gJSEB2_CfgRegs;

/* -----------------------------------------------
    JSEB2 run-time registers information
   ----------------------------------------------- */
/* Run-time registers information array */
/* const WDC_REG gJSEB2_Regs[]; */
const WDC_REG *gpJSEB2_Regs = NULL;
/* TODO: You can remove the comment from the gJSEB2_Regs array declaration and
         fill the array with run-time registers information for your device,
         in which case be sure to set gpJSEB2_Regs to point to gJSEB2_Regs. */
#define JSEB2_REGS_NUM 0

/*************************************************************
  Static functions prototypes
 *************************************************************/
/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */

//CFM EDIT - configFileName here short-circuits the menu process and goes right into testing - if file is good and all parameters needed are found
//if not everything is found, revert to menu behavior
static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev2, char* configFileName);

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId);
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot);
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot);
static void DeviceClose(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev);
static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace);

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev);
//static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, JSEB2_INT_RESULT *pIntResult);
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, JSEB2_INT_RESULT *pIntResult);

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
static void MenuEvents(WDC_DEVICE_HANDLE hDev);
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction);
static void Menujsebii_test(WDC_DEVICE_HANDLE hDev);
static void MenuADCtest(WDC_DEVICE_HANDLE hDev, WDC_DEVICE_HANDLE hDev2, char* configFileName);
static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_send_6_1(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_send_1(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_rec_16b(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec_2(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec_6_1(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec_6_2(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int xmit_boot(WDC_DEVICE_HANDLE hDev, int imod_xmit);
static int fem_boot(WDC_DEVICE_HANDLE hDev, int imod_fem);
static int dcm2_fpga_boot(WDC_DEVICE_HANDLE hDev, int imod, int fpga_t, int iprint);
static int adc_setup(WDC_DEVICE_HANDLE hDev, int imod, int iprint);
static int adc_setup_bebug(WDC_DEVICE_HANDLE hDev, int imod, int iprint);
static int adc_testram_load(WDC_DEVICE_HANDLE hDev, int imod, int iprint);
static int eprom_readback(WDC_DEVICE_HANDLE hDev, int imod, int mode, UINT32 *buff_rec);


/*************************************************************
  Functions implementation
 *************************************************************/
int main(int argc, char* argv[])
{
  //cppWatch timer;
  //  timer.start();

  //Some initial output
  printf("ARGC: %d\n", argc);
  int aI = 0;
  while(aI < argc){
    printf(" ARG %d: %s\n", aI, argv[aI]);
    ++aI;
  }
  
  struct timeval start;
  gettimeofday(&start,NULL);

  static long seconds, useconds;
  seconds = start.tv_sec;
  useconds = start.tv_usec;
      
  printf("\nStart time of program: %ld sec %ld usec\n",seconds,useconds);

    WDC_DEVICE_HANDLE hDev = NULL;
    WDC_DEVICE_HANDLE hDev1 = NULL;
    WDC_DEVICE_HANDLE hDev2 = NULL;

    DWORD dwStatus;

    printf("\n");
    printf("JSEB2 diagnostic utility.\n");
    printf("Application accesses hardware using " WD_PROD_NAME ".\n");

    /* Initialize the JSEB2 library */
    dwStatus = JSEB2_LibInit();
    if(WD_STATUS_SUCCESS != dwStatus){
      JSEB2_ERR("pcie_diag: Failed to initialize the JSEB2 library: %s",
		JSEB2_GetLastErr());
      return dwStatus;
    }

    /* Find and open a JSEB2 device (by default ID) */
    if(JSEB2_DEFAULT_VENDOR_ID) hDev = DeviceFindAndOpen(JSEB2_DEFAULT_VENDOR_ID, JSEB2_DEFAULT_DEVICE_ID);
    if (JSEB2_DEFAULT_VENDOR_ID)
        hDev1 = DeviceFindAndOpen(JSEB2_DEFAULT_VENDOR_ID, JSEB2_DEFAULT_DEVICE_ID+1);
    if (JSEB2_DEFAULT_VENDOR_ID)
        hDev2 = DeviceFindAndOpen(JSEB2_DEFAULT_VENDOR_ID, JSEB2_DEFAULT_DEVICE_ID+2);

    /* Display main diagnostics menu for communicating with the device */
    if(argc == 1) MenuMain(&hDev, &hDev2, "");
    else MenuMain(&hDev, &hDev2, argv[1]);

    /* Perform necessary cleanup before exiting the program */
    if (hDev)
        DeviceClose(hDev);
        DeviceClose(hDev1);
        DeviceClose(hDev2);

    dwStatus = JSEB2_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
        JSEB2_ERR("pcie_diag: Failed to uninit the JSEB2 library: %s", JSEB2_GetLastErr());

  gettimeofday(&start,NULL);

  long secondsEnd, usecondsEnd;
  secondsEnd = start.tv_sec;
  usecondsEnd = start.tv_usec;  

  printf("TIME (SECONDS): %ld - %ld = %ld\n", secondsEnd, seconds, secondsEnd - seconds);
    
  return dwStatus;
}

/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
/* Main menu options */
enum {
    MENU_MAIN_SCAN_PCI_BUS = 1,
    MENU_MAIN_FIND_AND_OPEN,
    MENU_MAIN_RW_ADDR,
    MENU_MAIN_RW_CFG_SPACE,
    MENU_MAIN_RW_REGS,
    MENU_MAIN_ENABLE_DISABLE_INT,
    MENU_MAIN_EVENTS,
    MENU_MAIN_MB_TEST, /* add new route for testing */
    MENU_MAIN_JSEB2_TEST, /* add new route for testing */
    MENU_MAIN_EXIT = DIAG_EXIT_MENU,
};

char* getConfigLineID(char* inChar)
{
}

/* Main diagnostics menu */
static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev2, char* configFileName)
{
  printf("CONFIGFILENAME IS \'%s\'\n", configFileName);
  //CFM: If the configFileName is real and the file is found + contains all necessary items, we short-circuit the menu system and jump right into what we want to do

  if(configFileName[0] == '\0'){
    //No config is provided, just go
    printf("CONFIGFILENAME is empty - going to menu\n"); 
  }
  else{
    //Initial test to see if the configFile is good for use (check if all needed params are present, etc.)
    FILE * configFile;
    char* configLine = NULL;
    size_t configLen = 0;
    ssize_t configRead;

    configFile = fopen(configFileName, "r");

    //Current set of values for the config file, as stored in a char* array
    //Don't like the magic variable reqValues being disconnected from array sizes, figure out a way to fix
    const int reqValues = 23;
    char* reqValueIDs[23] = {"BOARDID",
			     "CHANNELMIN",
			     "CHANNELMAX",
			     "ADDITIONALTAG",
			     "DODEBUG",
			     "NUMBEROFLOOP",
			     "NUMBEROFEVENT",
			     "POSITIONOFMODULE",
			     "NUMBERFEM",
			     "USEXMIT",
			     "USEDCM",
			     "WRITETOFILE",
			     "USEPULSE",
			     "USEEXTERNALTRIGGER",
			     "USEPULSEGEN",
			     "NUMBEROFSTEPS",
			     "EVENTSPERSTEP",
			     "DACPERSTEP",
			     "SIGNAL",
			     "USEFIXEDDAC",
			     "L1DELAY",
			     "LOADADCMEM",
			     "TRIGXMITRESET"};
    
    int containsValues[23];
    int rI = 0;
    while(rI < reqValues){
      containsValues[rI] = 0;
      ++rI;
    }

    if(configFile == NULL){
      printf("GIVEN CONFIGFILENAME \'%s\' IS NOT VALID. RETURN TO MENU\n", configFileName);
      return;
    }
    else{
      printf("READING \'%s\'\n", configFileName);

      while((configRead = getline(&configLine, &configLen, configFile)) != -1){
	//Skipping empty and/or commented lines in the input config	
	if(configLen == 0) continue;
	if(configLine[0] == '#') continue;
	if(configLine[0] == '\0') continue;
	if(configLine[0] == '\n') continue;

	//Parse the first half of the config string for the tag
	const int tempArrSize = 100;
	char tempArr[100];	
	int tI = 0;
	while(tI < tempArrSize){
	  char temp3 = configLine[tI];	  
	  if(temp3 == ':') break;
	  
	  tempArr[tI] = temp3;
	  ++tI;	  
	  if(tI == tempArrSize){
	    printf("WARNING YOU HAVE HIT THE SIZE LIMIT \'%d\' OF YOUR CHAR PARSING ARRAY, L%d", tempArrSize, __LINE__);
	  }
	}	

	//Recast your tempArr char array as a more useful char*
	char* tempstr = &(tempArr[0]);
	tempstr[tI] = '\0';

	//Check that a required value is in fact found
	rI = 0;	
	while(rI < reqValues){
	  if(strcmp(tempstr, reqValueIDs[rI]) == 0){
	    containsValues[rI] = 1;
	    //	    printf(" FOUND %s\n", reqValueIDs[rI]);
	    break;
	  }
	  ++rI;
	}       
      }
      //Finished config file read
     
      //Check that all required values are found
      int totalReq = 0;
      rI = 0;
      while(rI < reqValues){
	if(containsValues[rI] == 0) printf("CONFIG FILE MISSING \'%s\'\n", reqValueIDs[rI]);
	totalReq += containsValues[rI];
	++rI;
      }

      //If all found, pass the config file forward, else return
      if(totalReq == reqValues) printf("ALL REQ CONFIG VALUES FOUND IN GIVEN CONFIG \'%s\'\n", configFileName);
      else{
	printf("MISSING VALUES IN CONFIG FILE \'%s\'. return\n", configFileName);
	return;
      }
    }
    fclose(configFile);

    if(*phDev){
      //Pass valid config file forward to ADC testing
      MenuADCtest(*phDev, *phDev2, configFileName);      
    }
    else{
      printf("NO VALID JSEB 2 DEVICES FOUND - TRY RESETTING LICENSE. return\n");
    }
    
    return;
  }

  DWORD option;
  
  do
    {
      printf("\n");
        printf("JSEB2 main menu\n");
        printf("--------------\n");
        printf("%d. Scan PCI bus\n", MENU_MAIN_SCAN_PCI_BUS);
        printf("%d. Find and open a JSEB2 device\n", MENU_MAIN_FIND_AND_OPEN);
        if (*phDev)
        {
            printf("%d. Read/write memory and IO addresses on the device\n",
                MENU_MAIN_RW_ADDR);
            printf("%d. Read/write the device's configuration space\n",
                MENU_MAIN_RW_CFG_SPACE);
            if (JSEB2_REGS_NUM)
            {
                printf("%d. Read/write the run-time registers\n",
                    MENU_MAIN_RW_REGS);
            }
            printf("%d. Enable/disable the device's interrupts\n",
                MENU_MAIN_ENABLE_DISABLE_INT);
            printf("%d. Register/unregister plug-and-play and power management "
                "events\n", MENU_MAIN_EVENTS);
            printf("%d. MicroBoone test\n", MENU_MAIN_MB_TEST);
            printf("%d. Test loop for PCIe\n", MENU_MAIN_JSEB2_TEST);
        }
        printf("%d. Exit\n", MENU_MAIN_EXIT);

	/**        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_EVENTS : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }
	**/

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_JSEB2_TEST : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }

        switch (option)
        {
        case MENU_MAIN_EXIT: /* Exit menu */
            break;
        case MENU_MAIN_SCAN_PCI_BUS: /* Scan PCI bus */
            WDC_DIAG_PciDevicesInfoPrintAll(FALSE);
            break;
        case MENU_MAIN_FIND_AND_OPEN: /* Find and open a JSEB2 device */
            if (*phDev)
                DeviceClose(*phDev);
            *phDev = DeviceFindAndOpen(0, 0);
            break;
        case MENU_MAIN_RW_ADDR: /* Read/write memory and I/O addresses */
            MenuReadWriteAddr(*phDev);
            break;
        case MENU_MAIN_RW_CFG_SPACE: /* Read/Write the JSEB2 configuration space */
            MenuReadWriteCfgSpace(*phDev);
            break;
        case MENU_MAIN_RW_REGS: /* Read/write the run-time registers */
            if (JSEB2_REGS_NUM)
                MenuReadWriteRegs(*phDev);
            else
                printf("Invalid selection\n");
            break;
        case MENU_MAIN_ENABLE_DISABLE_INT: /* Enable/disable interrupts */
            MenuInterrupts(*phDev);
            break;
        case MENU_MAIN_EVENTS: /* Register/unregister plug-and-play and power management events */
	  MenuEvents(*phDev);
	  break;
        case MENU_MAIN_MB_TEST: /* my test loop DMA */  //CFM NOTE: THIS IS THE MICROBOONE TEST CASE
	  MenuADCtest(*phDev, *phDev2, "");
	  break;
        case MENU_MAIN_JSEB2_TEST: /* my test loop DMA */
	  Menujsebii_test(*phDev);
	  break;
        }
    } while (MENU_MAIN_EXIT != option);
}

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
/* Find and open a JSEB2 device */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId)
{
    WD_PCI_SLOT slot;
    
    if (!DeviceFind(dwVendorId, dwDeviceId, &slot))
        return NULL;

    return DeviceOpen(&slot);
}

/* Find a JSEB2 device */
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot)
{
    DWORD dwStatus;
    DWORD i, dwNumDevices;
    WDC_PCI_SCAN_RESULT scanResult;

    if (dwVendorId == 0)
    {
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwVendorId,
            "Enter vendor ID", TRUE, 0, 0))
        {
            return FALSE;
        }

        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwDeviceId,
            "Enter device ID", TRUE, 0, 0))
        {
            return FALSE;
        }
    }

    BZERO(scanResult);
    dwStatus = WDC_PciScanDevices(dwVendorId, dwDeviceId, &scanResult);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        JSEB2_ERR("DeviceFind: Failed scanning the PCI bus.\n"
            "Error: 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    dwNumDevices = scanResult.dwNumDevices;
    if (!dwNumDevices)
    {
        JSEB2_ERR("No matching device was found for search criteria "
            "(Vendor ID 0x%lX, Device ID 0x%lX)\n",
            dwVendorId, dwDeviceId);

        return FALSE;
    }
    
    printf("\n");
    printf("Found %ld matching device%s [ Vendor ID 0x%lX%s, Device ID 0x%lX%s ]:\n",
        dwNumDevices, dwNumDevices > 1 ? "s" : "",
        dwVendorId, dwVendorId ? "" : " (ALL)",
        dwDeviceId, dwDeviceId ? "" : " (ALL)");

    for (i = 0; i < dwNumDevices; i++)
    {
        printf("\n");
        printf("%2ld. Vendor ID: 0x%lX, Device ID: 0x%lX\n",
            i + 1,
            scanResult.deviceId[i].dwVendorId,
            scanResult.deviceId[i].dwDeviceId);

        WDC_DIAG_PciDeviceInfoPrint(&scanResult.deviceSlot[i], FALSE);
    }
    printf("\n");

    if (dwNumDevices > 1)
    {
        sprintf(gsInput, "Select a device (1 - %ld): ", dwNumDevices);
        i = 0;
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&i,
            gsInput, FALSE, 1, dwNumDevices))
        {
            return FALSE;
        }
    }

    *pSlot = scanResult.deviceSlot[i - 1];

    return TRUE;
}

/* Open a handle to a JSEB2 device */
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot)
{
    WDC_DEVICE_HANDLE hDev;
    DWORD dwStatus;
    WD_PCI_CARD_INFO deviceInfo;

    /* Retrieve the device's resources information */
    BZERO(deviceInfo);
    deviceInfo.pciSlot = *pSlot;
    dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        JSEB2_ERR("DeviceOpen: Failed retrieving the device's resources information.\n"
            "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return NULL;
    }

    /* NOTE: You can modify the device's resources information here, if
       necessary (mainly the deviceInfo.Card.Items array or the items number -
       deviceInfo.Card.dwItems) in order to register only some of the resources
       or register only a portion of a specific address space, for example. */

    /* Open a handle to the device */
    hDev = JSEB2_DeviceOpen(&deviceInfo);
    if (!hDev)
    {
        JSEB2_ERR("DeviceOpen: Failed opening a handle to the device: %s",
            JSEB2_GetLastErr());
        return NULL;
    }

    return hDev;
}

/* Close handle to a JSEB2 device */
static void DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    if (!hDev)
        return;

    if (!JSEB2_DeviceClose(hDev))
    {
        JSEB2_ERR("DeviceClose: Failed closing JSEB2 device: %s",
            JSEB2_GetLastErr());
    }
}



/* Read/write memory or I/O space address menu */
static void MenuADCtest(WDC_DEVICE_HANDLE hDev, WDC_DEVICE_HANDLE hDev2, char* configFileName)
{

#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  adc_cntrl_int 0x0
#define  adc_cntrl_loopback_on 0x1
#define  adc_cntrl_loopback_off 0x2
#define  adc_cntrl_offline 0x3
#define  adc_cntrl_online 0x4


#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6
#define  mb_trig_enable             7

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_g1_allow_min      36
#define  mb_trig_g1_allow_max      37
#define  mb_trig_g2_allow_min      38
#define  mb_trig_g2_allow_max      39

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_g1_width          45
#define  mb_trig_g2_width          46

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58
#define  mb_trig_output_select     59

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_trig_frame_trig        63
#define  mb_trig_rd_counter        70

#define  mb_gate_fake_sel          80
#define  mb_fake_gate_width        47
#define  mb_scaler_out_sel_0       81
#define  mb_scaler_out_sel_1       82

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49
#define  mb_feb_pmt_trig_delay     87

#define  mb_feb_pmt_gate1_size     88
#define  mb_feb_pmt_beam1_delay    89
#define  mb_feb_pmt_beam1_size     90
#define  mb_feb_pmt_trig1_delay    91

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  mb_version               254

#define  sp_cntrl_sub               2
#define  sp_cntrl_timing            3 
#define  sp_cntrl_busyrst           4
#define  sp_cntrl_init           0x30
#define  sp_cntrl_reset          0x28
#define  sp_cntrl_l1             0x24
#define  sp_cntrl_pulse          0x22

#define  sp_cntrl_loopback_on       1
#define  sp_cntrl_loopback_off      2
#define  sp_cntrl_offline           3
#define  sp_cntrl_online            4
#define  sp_cntrl_isprst_on         5
#define  sp_cntrl_isprst_off        6
#define  sp_cntrl_seldisc_off       0
#define  sp_cntrl_seldisc_on        7
#define  sp_cntrl_seldisc_add      31

#define  sp_adc_readback_sub        4
#define  sp_adc_readback_transfer   1
#define  sp_adc_readback_read       2
#define  sp_adc_readback_status     3
#define  sp_adc_readback_trig       4

#define  sp_adc_input_sub           2
#define  sp_adc_slowcntl_sub        1
#define  sp_adc_trigproc_sub        5

#define  sp_adc_l1_delay            1
#define  sp_adc_evt_sample          2

#define  sp_adc_rd_link             3
#define  sp_adc_rd_cntrl            4

#define  sp_adc_sel_l1              5
#define  sp_adc_sel_pulse           6
#define  sp_adc_sel_test_trig       7

#define  sp_adc_sel_link_rxoff     8

#define  sp_adc_u_adc_align        10
#define  sp_adc_l_adc_align        11
#define  sp_adc_pll_reset          12

#define  sp_adc_rstblk             13
#define  sp_adc_test_pulse         14

#define  sp_adc_dpa_reset          15

#define  sp_adc_spi_add            20
#define  sp_adc_spi_data           30

#define  sp_adc_testram_load_ch     4
#define  sp_adc_testram_load_data   5
#define  sp_adc_testram_trig_delay  7


#define  sp_adc_lnk_tx_dreset      20
#define  sp_adc_lnk_tx_areset      21
#define  sp_adc_trg_tx_dreset      22
#define  sp_adc_trg_tx_areset      23
#define  sp_adc_lnk_rx_dreset      24
#define  sp_adc_lnk_rx_areset      25

#define  sp_adc_link_mgmt_reset    26
#define  sp_adc_link_conf_w        27
#define  sp_adc_link_conf_add      30
#define  sp_adc_link_conf_data_l   31
#define  sp_adc_link_conf_data_u   32

#define  sp_adc_sel_caltrig        33

#define  sp_adc_calib_dac         100
#define  sp_adc_calib_ch          101
#define  sp_adc_calib_write       102
#define  sp_adc_calib_send        103
#define  sp_adc_calib_gate        104

#define  sp_adc_eprom_addr_l       50
#define  sp_adc_eprom_addr_h       51
#define  sp_adc_eprom_wdata        52
#define  sp_adc_eprom_w_pulse      53
#define  sp_adc_eprom_read_pulse   54
#define  sp_adc_eprom_bulk_erase_p 55
#define  sp_adc_eprom_read_status_p  56
#define  sp_adc_eprom_read_id_p    57
#define  sp_adc_eprom_reset_p      58
#define  sp_adc_eprom_sector_protect_p  59
#define  sp_adc_eprom_erase_sector 68

#define  sp_adc_update_data_in_l   60
#define  sp_adc_update_data_in_h   61
#define  sp_adc_update_reset_timer 62
#define  sp_adc_update_write_param 63
#define  sp_adc_update_reconfig    64
#define  sp_adc_update_param       65
#define  sp_adc_update_reset       66

#define  sp_adc_trig_sub_delay      1
#define  sp_adc_trig_tbl_chnl       2
#define  sp_adc_trig_lkp_addr       3
#define  sp_adc_trig_lkp_data       4
#define  sp_adc_trig_smpl_phase     5
#define  sp_adc_trig_smpl_phase     5
#define  sp_adc_trig_read_delay     6
#define  sp_adc_trig_read_size      7
#define  sp_adc_trig_lkp_write     10

#define  sp_adc_fake_gtm_init     210
#define  sp_adc_fake_gtm_l1       211
#define  sp_adc_fake_gtm_reset    212


#define  sp_xmit_lastmod            1
#define  sp_xmit_rxanalogreset      2
#define  sp_xmit_rxdigitalreset     3
#define  sp_xmit_init               4

#define  sp_xmit_sub                1
#define  sp_xmit_rxbytord          15

#define  sp_mbd_disc_led           10
#define  sp_mbd_disc_charge_dac     4
#define  sp_mbd_disc_pulse_even     6
#define  sp_mbd_disc_pulse_odd      5
#define  sp_mbd_disc_disc_dac       1

#define  sp_mbd_clk_pulse           1
#define  sp_mbd_clk_delay_off       0
#define  sp_mbd_clk_delay_on        2
#define  sp_mbd_clk_busy_reset      3
#define  sp_mbd_clk_add            22

#define  dma_buffer_size        10000000

    static DWORD dwAddrSpace;

    static UINT32 u32Data;
    static unsigned short u16Data;
    static unsigned long long u64Data, u64Data1;
    static DWORD dwOffset;
    static long imod,ichip;
    unsigned short *buffp;

/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    //CFM:
    //Since everything is cast as static up top and its known there are some memory issues
    //Switching to static top level casts for my used iterators, etc.
    struct timeval adcTestTimer;
    static unsigned long long seconds, useconds;
    static time_t timer;
    struct tm localt;
    static char dateBuffer[128];
    static char* dateStr;
    static int configGood;

    const int tempArrSize = 100;
    static char tempArr[100], tempArr2[100];
    static char boardIDArr[100];
    static char channelMinArr[100];
    static char channelMaxArr[100];
    static char additionalTagArr[100];

    static char* boardID;
    static char* channelMin;
    static char* channelMax;
    static char* additionalTag;

    static char* fileName;

    static unsigned int tempI, startVal, currLen;
    static char tempChar, tempChar2;
    static char* tempStr, *tempStr2;

    static unsigned int doDebug;

    static char fileNameArr[100] = "output/board"; 
    static char fileNameArr2[100] = "_Channel";
    static int fileNameLen = 12;
    static int fileNameLen2 = 8;

    //END CFM
    
    
    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
    static UINT32 istop,newcmd,irand,ioffset,kword,lastchnl,ib;
    static UINT32 send_array[40000],read_array[dma_buffer_size],read_array1[40000];
    static UINT32 read_array_c[40000];
    static UINT32 read_comp[8000];
    static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
    static UINT32 imod_p,imod_trig,imod_shaper;
    unsigned short idcm_read_array[40000],read_array_s[1600000];
    static UINT32 idcm_read_array32[40000];
    static UINT32 idcm_send_array[400000];
    static UINT32 idcm_verify_array[400000];
    static int icomp_l,comp_s,ia,ic,ihuff;
    UINT32 *idcm_send_p,*idcm_verify_p,*pbuffp_rec;
    DWORD dwDMABufSize;
    PVOID pbuf;
    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck,izero;
    UINT32 buf_send[40000];
    static int   count,num,counta,nword,ireadback,nloop,ierror;
    static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
    static int   itest,iframe,irun,ichip_c,dummy1,itrig_c;
    static int  idup,ihold,idouble,ihold_set,istatus_read;
    static int  idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
    static int   timesize,ipulse,ibase,a_id,itrig_delay;
    static int   iset,ncount,nsend_f,nwrite,itrig_ext;
    static int   imod_xmit,idiv,isample, isel_xmit, isel_dcm;
    static int   iframe_length, itrig,idrift_time,ijtrig;
    static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
    static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
    static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
    static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
    static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
    static int   irawprint,ifem_fst,ifem_lst,ifem_loop,imod_fem;
    static int   pmt_deadtime,pmt_mich_window, imod_dcm;
    static int   oframe,osample,odiv,cframe,csample,cdiv;
    static int   idac_shaper, pmt_dac_scan,pmt_precount, ichoice;
    static int   inewcode, p1_delay, p1_width, pulse_trig_delay;
    static int   p2_delay,p2_width,itrig_pulse,p3_delay,p3_width;
    static int   ich, nsample;
    static int   conf_add,conf_data, iext_trig, igen, ioffset_t;
    static int   imod_start, imod_end, nmod, iparity, itest_ram, itrig_xmit_reset;
    static int   nstep, nstep_event, ipattern, nstep_dac, idac_shaper_load;
    static int   dac_start, trig_rw_delay;
    static int   trig_lookup[64][1024],itrig_lk_data ;
    static int   fake_data_array[64][512], fake_data_array_sub[64][512];
    static int   fake_data_array_sub_lk[64][512];
    static int   fake_data_array_sub_lk_sum[16][512];
    static int   fake_data_trig_out[16][100], ntrig_w, ntrig_st; 
    static int   trig_smp_data[16][100];
    static int   nsector, read_eprom_array[1000], write_eprom_array[1000];
    static int   addr_w;
    static int   iad,idata,ibin;
    static int   itest_pattern, itest_even, itest_odd, test_pulse_d;
    static int   imod_disc, idisc_ch, idisc_dac, idisc_thr,idac_scan;
    static int   nsample_trig, ndelay_trig, ifix_dac;
    static int   fake_pulse[10] = {0x1ff, 0xfff, 0x1fff, 0x2fff, 0x1fff, 0xfff, 0x1ff, 0x0, 0x0, 0x0};
    static int   ifake_start,ifake_width;
    unsigned char    charchannel;
    unsigned char    carray[40000];
    //CFM: Ran id'd Memory issue w/ adc_data - somehow it was overwriting nsample (when it was declared immediately before nsample - search for fix
    static int   adc_data[64][64],l1_delay;
    struct timespec tim, tim2;
    tim.tv_sec = 0;
//    tim.tv_nsec =128000;
    tim.tv_nsec =172000;


    PVOID pbuf_rec;
    WD_DMA *pDma_rec;
    DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
//    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;

    static UINT64 *buffp_rec64;
    static UINT32 *buffp_rec32;
    UINT32 *px, *py, *py1;

    FILE *outf,*inpf, *configFile, *termf;
    static unsigned char* configLine;
    static size_t configLen;
    static ssize_t configRead;

    nread = 4096*2+6; /*16384 32768, 65536+4;  number of byte to be readout */
    ifr=0;
    iwrite =0;
    iprint =0;
    icheck =0;
    istop=0;

    //CFM - Do some date and time manips
    //next five lines are just getting a starttime in seconds
    gettimeofday(&adcTestTimer,NULL);

    seconds = adcTestTimer.tv_sec;
    useconds = adcTestTimer.tv_usec;

    //Now we will get the start date
    timer = time(NULL);
    localt = *localtime(&timer);
    snprintf(dateBuffer, sizeof(dateBuffer), "%04d%02d%02d", localt.tm_year + 1900, localt.tm_mon + 1, localt.tm_mday);
    dateStr = &(dateBuffer[0]);
    dateStr[8] = '\0';

    configGood = strcmp(configFileName, "");
    if(configGood != 0) configGood = 1;


    if(configGood == 0){
      printf("Input the command code for test......\n");
      printf("     (1) controller test...");
      printf("     (2) boot FPGA 1-4 \n");
      printf("     (3) loop back test \n");
      printf("     (4) MB controller test loopback\n");
      printf("     (5) MB controller output test \n");
      printf("     (6) MB FEM booting \n");
      printf("     (7) Fake data read \n");
      printf("     (8) Fake data read - test 2 \n");
      printf("     (9) ADC basic testing \n");
      printf("     (10) ADC testing \n");
      printf("     (11) XMIT board boot test \n");
      printf("     (12) BNL ADC testing \n");
      printf("     (14) new FEM FPGA code testing  \n");
      printf("     (15) 2 FEM and XMIT test  \n");
      printf("     (16) trigger board test \n");
      printf("     (17) shapper baord test \n");
      printf("     (18) new BNL ADC testing \n");
      printf("     (19) FEM fake data slow readback test \n");
      printf("     (20) BNL chian test routine \n");
      printf("     (21) SuperNova readout test \n");
      printf("     (22) PMT ADC systen readout test \n");
      printf("     (23) XMIT module busy test \n");
      printf("     (24) SuperNova readout test -- 2 buffer mode \n");
      printf("     (26) multiple ADC module test \n");
      
      scanf("%d",&newcmd);
    }
    else newcmd = 4;


    switch(newcmd) {


    case 1:
     printf(" number of loop \n");
     scanf("%d",&nloop);
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" type 1 to use xmit module \n");
     scanf("%d", &isel_xmit);
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
//
//
//
     printf(" enter 1 to use pulse \n");
     scanf("%d",&ipulse);
     if(ipulse !=0) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     } 
/*
     printf(" enter number of word per packet\n");
     scanf("%d",&nsend);
     printf(" enter 1 for loopback check\n");
     scanf("%d",&ireadback);
     printf(" type 1 to use new PCie FPGA code \n");
     scanf("%d",&inew);
     if(ireadback == 1) {
       printf(" enter 1 for readback in DCM mode\n");
       scanf("%d",&idma_readback);
     }


     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
     printf(" scope loop test \n");
*/
/*
    dwDMABufSize = 140000;
    dwStatus = WDC_DMAContigBufLock(hDev, &pbuf, dwOptions, dwDMABufSize, &pDma);
    if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a receive Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
    }
*/

     px = &buf_send;
     py = &read_array;
     imod =6;
     imod_xmit = 7;
     ichip=6;
     nsample = 12;
     if(isel_dcm ==1) {
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev,11,1, 0);

      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev,11,2, 0);
      printf(" DCM II booting done \n");
      //      scanf("%d",&i);

      imod_dcm=11;
      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev,1,1,px);
     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
       ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//     for (j=0; j<10000000; j++)  {
//      ichip = sp_adc_slowcntl_sub;
//      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + (0xffff<<16) ;
//      buf_send[1]= 0x5555aaaa;
//      i= 1;
//      k= 2;
//      i = pcie_send_1(hDev, i, k, px);
//      usleep(100);
//     }

//

//#define  sp_cntrl_init           0x30
//#define  sp_cntrl_reset           0x28
//#define  sp_cntrl_l1              0x24
     printf(" type 1 to send init \n");
     scanf("%d",&is);
//
//
//#define  sp_xmit_lastmod            1
//#define  sp_xmit_rxanalogreset      2
//#define  sp_xmit_rxdigitalreset     3
//#define  sp_xmit_init               4

//#define  sp_smit_sub
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);
     }


//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
     printf(" type 1 to send reset \n");
     scanf("%d",&is);

     buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set L1 delay  -- to 100
//
     printf(" type 1 to set L1 delay \n");
     scanf("%d",&is);
     if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
     printf(" buf_send = %x\n", buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set select L1 trigger on
//
     printf(" type 1 to select L1 trigger \n");
     scanf("%d",&is);
     if(ipulse != 0 ) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set up complete type 1 to continue \n");
     scanf("%d",&is);

//#define  sp_adc_l1_delay            1
//#define  sp_adc_evt_sample          2

//#define  sp_adc_rd_link             3
//#define  sp_adc_rd_cntrl            4

//#define  sp_adc_sel_l1              5
//#define  sp_adc_sel_pulse           6
//#define  sp_adc_sel_test_trig       7

     for (j=0; j<nloop; j++) {
      ichip = sp_adc_input_sub ;   // controller data go to ADC input section
      for (ich=0; ich<8; ich++) {

//    set spi address

       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
       printf(" type 1 to continue ich= %d \n", ich);
//       scanf("%d",&is);

//      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_)+((is & 0xf)<<16); //set spi address
//      i=1;
//        k=1;
//        i = pcie_send(hDev, i, k, px);
//       printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
//        ichip=5;
//
//     reset ADC
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0x0))+((0x3c)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x0, data =0x3c;
//

       i=1;
       k=2;
//       i = pcie_send(hDev, i, k, px);
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us
//
//       if(ich ==7) {
        printf(" type 1 to continue -- send last command ich= %d \n", ich);
//        scanf("%d",&is);
//       }
//
//    set LVDS termination  set addess 0x15  to 0x30 100 ohms termination
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<12)+(0x15))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x15, data =0x1;
//
       i=1;
       k=2;
//       i = pcie_send(hDev, i, k, px);
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us

//
//    set fix pattern  0xa = sync pattern
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xa;
//

       i=1;
       k=2;
//       i = pcie_send(hDev, i, k, px);
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us
//
//       printf(" type 1 to continue \n");
//       scanf("%d",&is);
      }


      for (k=0; k<1000000; k++) {
       ik=k+1;
       i=ik*ik;
      }
//
//    set up for ADC alignment
//
      ichip = sp_adc_slowcntl_sub ;   // controller data go to ADC input section
//
//       pll reset
//
      printf(" type 1 to send pll reset\n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_pll_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);

//
//       DPA reset
//
      printf(" type 1 to send ADC DPA reset\n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_dpa_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);

//
//       upper ADC alignment
//
      printf(" type 1 to send upper channel align \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_u_adc_align + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//
//       lower ADC alignment
//
      printf(" type 1 to send lower channel align \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l_adc_align + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//
//
//

     ichip = sp_adc_input_sub ;   // controller data go to ADC input section
     for (ich=0; ich<8; ich++) {
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);
//
//    output offset binary code
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<12)+(0x14))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x14, data =0x0;
//

       i=1;
       k=2;

       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us

//
//    unset fix pattern  0x0 for normal data taking   --- set to test condition
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0x0;
//

       i=1;
       k=2;

       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us
     }


//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       printf(" header 1 = %x\n", read_array[0]);
       printf(" header 2 = %x\n", read_array[1]);
       printf(" header 3 = %x\n", read_array[2]);
       printf(" header word = %x\n", (read_array[0]& 0xffff));
       printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
       iread = read_array[2] & 0xffff;
       printf(" word count = %x\n", iread);
       printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
       scanf("%d", &i );
//
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        if(i%8 == 0) printf("%3d",i);
        printf(" %9x",u32Data);
        if(i%8 == 7) printf("\n");
       }
       scanf("%d", &i );
       for (is=0; is<nsample; is++) {
        for (k=0; k<32; k++) {
         adc_data[k*2][is] = read_array[7+((k*nsample+is)*2)] & 0xffff;
         adc_data[(k*2)+1][is] = read_array[6+((k*nsample+is)*2)] & 0xffff;
        }
       }
       for (is=0; is<64; is++) {
       printf(" channel %d ", is);
       for (k=0; k<nsample; k++) {
        printf(" %4x", adc_data[is][k]);
       }
        printf("\n");
       }
       scanf("%d", &i );
      }


//
//
      ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
//
      if(iwrite != 1) {
       printf(" type 1 to send the transfer \n");
       scanf("%d",&is);
      }
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//
//
//
      nread =2+(64*nsample/2)+1;
      i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

      if(iwrite != 1) {
       printf(" type 1 to send the read \n");
       scanf("%d",&is);
      }
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//
//
      i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
      if (iwrite == 1) {
       fprintf(outf," %x\n", read_array[0]);
       fprintf(outf," %x\n", read_array[1]);
      }
      else {
       printf(" header 1 = %x\n", read_array[0]);
       printf(" header 2 = %x\n", read_array[1]);
      }

      k=0;
      for (is=0; is< (nread-2); is++) {
       if(iwrite == 1) {
        fprintf(outf," %8X", read_array[is+2]);
       }
       else {
        if(is%8 ==0) printf(" %d ", is);
        printf(" %x", read_array[is+2]);
       }
       k=k+1;
       if(iwrite == 1) {
        if((k%8) ==0) fprintf(outf,"\n");
       }
       else {
        if((k%8) ==0) printf("\n");
       }
      }
      if(iwrite == 1) fprintf(outf,"\n");
      else printf("\n");

      if(iwrite != 1) {
       for (is=0; is< nsample; is++ ) {
        for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
         adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
         adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
        }
       }


       for (is=0; is<64; is++) {
       printf(" channel %d ", is);
       for (k=0; k<nsample; k++) {
        printf(" %4x", adc_data[is][k]);
       }
        printf("\n");
       }
      }


      if(iwrite != 1) {
        printf(" type 1 to continue \n");
        scanf("%d",&is);
      }
     }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//

     }
     break;

    case 2:
//     printf(" number of loop \n");
//     scanf("%d",&nloop);
     printf(" number per event \n");
     scanf("%d",&nevent);
//     printf(" type 1 to write data to file \n");
//     scanf("%d",&iwrite);
//     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
     iwrite = 0;
//
//
//
     printf(" enter 1 to use pulse \n");
     scanf("%d",&ipulse);
     if(ipulse !=0) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     }
/*
     printf(" enter number of word per packet\n");
     scanf("%d",&nsend);
     printf(" enter 1 for loopback check\n");
     scanf("%d",&ireadback);
     printf(" type 1 to use new PCie FPGA code \n");
     scanf("%d",&inew);
     if(ireadback == 1) {
       printf(" enter 1 for readback in DCM mode\n");
       scanf("%d",&idma_readback);
     }


     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
     printf(" scope loop test \n");
*/
/*
    dwDMABufSize = 140000;
    dwStatus = WDC_DMAContigBufLock(hDev, &pbuf, dwOptions, dwDMABufSize, &pDma);
    if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a receive Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
    }
*/
     px = &buf_send;
     py = &read_array;
     imod =18;
     ichip=6;
     nsample = 12;
//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
       ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//     for (j=0; j<10000000; j++)  {
//      ichip = sp_adc_slowcntl_sub;
//      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + (0xffff<<16) ;
//      buf_send[1]= 0x5555aaaa;
//      i= 1;
//      k= 2;
//      i = pcie_send_1(hDev, i, k, px);
//      usleep(100);
//     }

//

//#define  sp_cntrl_init           0x30
//#define  sp_cntrl_reset           0x28
//#define  sp_cntrl_l1              0x24
     printf(" type 1 to send init \n");
     scanf("%d",&is);

//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
     printf(" type 1 to send reset \n");
     scanf("%d",&is);

     buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);

//#define  sp_adc_link_conf_w        27
//#define  sp_adc_link_conf_add     30
//#define  sp_adc_link_conf_data_l    31
//#define  sp_adc_link_conf_data_u    32

     imod = 15;
//
//
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_mgmt_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
     for (ijk=0; ijk <10000; ijk++) {
      printf(" enter configuration address 0 to change module address -- module address %d\n", imod);
      scanf("%d",&conf_add);
      if(conf_add == 0) {
        printf(" enter the new module address \n");
        scanf("%d", &imod);
      }
      else {
       printf(" enter configuration data \n");
       scanf("%d",&conf_data);
       ichip = sp_adc_slowcntl_sub;
       k= conf_data & 0xffff;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_conf_data_l+ (k<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//
       k= conf_data >> 16;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_conf_data_u+ (k<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_conf_add+ (conf_add<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_conf_w+ (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
      }
     }






     imod = 17;
//#define  sp_adc_link_mgmt_reset    26
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_mgmt_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10); 
     imod = 18;
//#define  sp_adc_link_mgmt_reset    26
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_mgmt_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//
//
     imod_start = 17;
     imod_end =18;

     for (imod=imod_start; imod<(imod_end+1); imod++) {

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" type 1 to set L1 delay, mod = %d \n", imod);
      scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
      if(ipulse != 0 ) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set up complete type 1 to continue \n");
      scanf("%d",&is);
//
//   reset link transmitter interface
//
      printf(" type 1 to reset link tx analog and digital interface module number =%d \n", imod);
      scanf("%d",&is);
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_lnk_tx_areset + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_lnk_tx_dreset + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   reset link receiver interface
//
      printf(" type 1 to reset link tx analog and digital interface  module number =%d \n", imod);
      scanf("%d",&is);
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_lnk_rx_areset + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_lnk_rx_dreset + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);




//#define  sp_adc_lnk_tx_dreset      20
//#define  sp_adc_lnk_tx_areset      21
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
//#define  sp_adc_lnk_tx_dreset      24
//#define  sp_adc_lnk_tx_areset      25

//#define  sp_adc_l1_delay            1
//#define  sp_adc_evt_sample          2

//#define  sp_adc_rd_link             3
//#define  sp_adc_rd_cntrl            4

//#define  sp_adc_sel_l1              5
//#define  sp_adc_sel_pulse           6
//#define  sp_adc_sel_test_trig       7


      ichip = sp_adc_input_sub ;   // controller data go to ADC input section
      for (ich=0; ich<8; ich++) {

//    set spi address

       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
       printf(" type 1 to continue ich= %d \n", ich);
//       scanf("%d",&is);

//      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_)+((is & 0xf)<<16); //set spi address
//      i=1;
//        k=1;
//        i = pcie_send(hDev, i, k, px);
//       printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
//        ichip=5;
//
//     reset ADC
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0x0))+((0x3c)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x0, data =0x3c;
//

       i=1;
       k=2;
//       i = pcie_send(hDev, i, k, px);
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us
//
//       if(ich ==7) {
        printf(" type 1 to continue -- send last command ich= %d \n", ich);
//        scanf("%d",&is);
//       }

//
//    set fix pattern  0xa = sync pattern
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xa;
//

       i=1;
       k=2;
//       i = pcie_send(hDev, i, k, px);
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us
//
//       printf(" type 1 to continue \n");
//       scanf("%d",&is);
      }


      for (k=0; k<1000000; k++) {
       ik=k+1;
       i=ik*ik;
      }
//
//    set up for ADC alignment
//
      ichip = sp_adc_slowcntl_sub ;   // controller data go to ADC input section
//
//       pll reset
//
      printf(" type 1 to send pll reset\n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_pll_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);

//
//       DPA reset
//
      printf(" type 1 to send ADC DPA reset\n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_dpa_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);

//
//       upper ADC alignment
//
      printf(" type 1 to send upper channel align \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_u_adc_align + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//
//       lower ADC alignment
//
      printf(" type 1 to send lower channel align \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l_adc_align + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//
//
//

      ichip = sp_adc_input_sub ;   // controller data go to ADC input section
      for (ich=0; ich<8; ich++) {
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);
//
//    output offset binary code
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<12)+(0x14))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x14, data =0x0;
//

       i=1;
       k=2;

       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us

//
//    unset fix pattern  0x0 for normal data taking
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0x0;
//

       i=1;
       k=2;

       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us
      }
     }


//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//
//
      ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
//
      if(iwrite != 1) {
       printf(" type 1 to send the transfer \n");
       scanf("%d",&is);
      }
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//
//
//
      nread =2+(64*nsample/2)+1;
      i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

      if(iwrite != 1) {
       printf(" type 1 to send the read \n");
       scanf("%d",&is);
      }
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//
//
      i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
      if (iwrite == 1) {
       fprintf(outf," %x\n", read_array[0]);
       fprintf(outf," %x\n", read_array[1]);
      }
      else {
       printf(" header 1 = %x\n", read_array[0]);
       printf(" header 2 = %x\n", read_array[1]);
      }

      k=0;
      for (is=0; is< (nread-2); is++) {
       if(iwrite == 1) {
        fprintf(outf," %8X", read_array[is+2]);
       }
       else {
        if(is%8 ==0) printf(" %d ", is);
        printf(" %x", read_array[is+2]);
       }
       k=k+1;
       if(iwrite == 1) {
        if((k%8) ==0) fprintf(outf,"\n");
       }
       else {
        if((k%8) ==0) printf("\n");
       }
      }
      if(iwrite == 1) fprintf(outf,"\n");
      else printf("\n");

      if(iwrite != 1) {
       for (is=0; is< nsample; is++ ) {
        for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
         adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
         adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
        }
       }


       for (is=0; is<64; is++) {
       printf(" channel %d ", is);
       for (k=0; k<nsample; k++) {
        printf(" %4x", adc_data[is][k]);
       }
        printf("\n");
       }
      }


      if(iwrite != 1) {
        printf(" type 1 to continue \n");
        scanf("%d",&is);
      }
     }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//

     break;

    case 3:
     printf(" number of loop \n");
     scanf("%d",&nloop);
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
     scanf("%d", &isel_xmit);
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite == 1) {
       printf(" type 1 to write test.data, otherwise write /dev/null \n");
       scanf("%d",&i);
       if(i ==1) outf = fopen("/home/chi/test.dat","w");
       else outf = fopen("/dev/null","w");
     }  
//
//
//
     printf(" enter 1 to use pulse \n");
     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
      printf(" type 1 for fix dac \n");
      scanf("%d", &ifix_dac);
     }
     if(igen == 1 & iwrite == 1) {
      fprintf(outf," %d\n", nstep);
      fprintf(outf," %d\n", nstep_event);
      fprintf(outf," %d\n", nstep_dac);
     }

     if(igen == 1){
       nevent = nstep * nstep_event;
       printf(" event number override, final number=%d\n", nevent);
     }


     if(configGood == 0){
       if((ipulse !=0) | (igen != 0)) {
	 printf(" enter L1 delay number \n");
	 scanf("%d", &l1_delay);
       }
     }
    

     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
     nsample = 12;
     printf(" %d ", __LINE__);
     scanf(" enter 1 %d",&i);
     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev,imod_dcm,1,0);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev,imod_dcm,2,0);
      printf(" DCM II booting done \n");
      scanf("%d",&i);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev,1,1,px);
     }
     printf(" %d ", __LINE__);

     scanf(" enter 1 %d",&i);


//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     printf(" %d ", __LINE__);

     scanf(" enter 1 %d",&i);

     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     printf(" %d ", __LINE__);

     scanf(" enter 1 %d",&i);

     i = pcie_send_1(hDev, i, k, px);
//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      printf(" %d ", __LINE__);
      scanf(" enter 1 %d",&i);

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      printf(" %d ", __LINE__);
      scanf(" enter 1 %d",&i);

      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" %d ", __LINE__);
      scanf(" enter 1 %d",&i);

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      printf(" %d ", __LINE__);
      scanf(" enter 1 %d",&i);

      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       scanf("%d",&is);
       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);



     }
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
//     printf(" type 1 to send reset \n");
//     scanf("%d",&is);

     buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
      if(igen ==1) {
//
// remove analog reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" trigger transmitter resets removed \n");
        scanf("%d",&i);


        for (is=0; is< 16; is++) {
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
         
/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value \n", is);
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
///
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
      if((ipulse != 0) | (igen  !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
      scanf("%d",&is);
//sp_adc_sel_link_rxoff



     }
//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =1;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1) {
        printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
       }
      }



//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else if (igen != 0) {
	idac_shaper = (ia/nstep_event);
         if(ifix_dac != 1) idac_shaper = idac_shaper *nstep_dac;    //set up the dac value
	 else idac_shaper = 4000;

         imod = imod_start;
         for (is=0; is< 16; is++) {
         ic= ipattern>> is;
         if((ic & 0x1) != 1) idac_shaper_load =0;
         else idac_shaper_load = idac_shaper;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
//         scanf("%d",&i);

        }

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }
      else if ((iext_trig != 1) & (igen != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is); 
       }
      }

      if(iext_trig == 1) {
       ik =0;
       while (ik != 1) {
        imod = imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if (((read_array[0] >>21) & 0x1) == 0) {
         printf(" trigger received \n");
         ik=1;
        }
       }
      }


//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
        scanf("%d", &i );
       }
//
       iread = read_array[2] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) {
         if(i%8 == 0) printf("%3d",i);
         printf(" %9x",u32Data);
         if(i%8 == 7) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if(i%8 == 7) fprintf(outf,"\n");
        }
        if((i%8) != 7) fprintf(outf,"\n");
       }

       if(iwrite != 1) {
        if((i%8) != 7) printf("\n");
        scanf("%d", &i );
        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
       iparity =0;
       for (is=0; is<4+(nsample*64); is++) {
        if(is%2 == 0) u32Data = (read_array1[is+6] & 0xffff) <<16;
        else {
         u32Data = u32Data + (read_array1[is+6] & 0xffff);
//         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
         iparity = iparity ^ u32Data;
        }
       }
       i= ((read_array1[778] & 0xffff) <<16) +(read_array1[779] & 0xffff);
       if(i != iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia, i, iparity);
         scanf("%d", &i);
       }
       printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);

       if(iwrite != 1) {
        printf(" parity word = %x\n", iparity);
        printf(" packet parity word = %x\n", (((read_array1[778] & 0xffff) <<16) +(read_array1[779] & 0xffff)));
        scanf("%d", &i );
        for (is=0; is<nsample; is++) {
         for (k=0; k<32; k++) {
          adc_data[k*2][is] = read_array1[11+((k*nsample+is)*2)] & 0xffff;
          adc_data[(k*2)+1][is] = read_array1[10+((k*nsample+is)*2)] & 0xffff;
         }
        }
        for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
         printf(" %4x", adc_data[is][k]);
        }
         printf("\n");
        }
        scanf("%d", &i );
       }
      }


//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }

        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if (iwrite != 1) printf(" parity = %x  \n", iparity);
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
      if(iwrite ==1) {
       if((ia%10) == 0) printf(" write event = %d \n", ia);
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
     break;

   case 4:
     termf = fopen("term.out", "w");

      //Configuration file is being read here to streamline testing
      doDebug = 0;
      if(configGood != 0){	
	configFile = fopen(configFileName, "r");

	while((configRead = getline(&configLine, &configLen, configFile)) != -1){
	  //Skipping empty and/or commented lines in the input config
	  if(configLen == 0) continue;
	  if(configLine[0] == '#') continue;
	  if(configLine[0] == '\0') continue;
	  if(configLine[0] == '\n') continue;

	  //Parse the first half of the config string for the tag
	  tempI = 0;
	  while(tempI < tempArrSize){
	    tempChar = configLine[tempI];	    
	    if(tempChar == ':') break;
	  
	    tempArr[tempI] = tempChar;
	    ++tempI;	  
	    if(tempI == tempArrSize){
	      printf("WARNING YOU HAVE HIT THE SIZE LIMIT \'%d\' OF YOUR CHAR PARSING ARRAY, L%d", tempArrSize, __LINE__);
	    }
	  }	
	  tempStr = &(tempArr[0]);
	  tempStr[tempI] = '\0';
	 	  
	  ++tempI;
	  ++tempI;
	  startVal = tempI;
	  while(tempI < 100){
	    tempChar = configLine[tempI];
            //printf("tempChar: %s \n", tempChar);

            if(tempChar == '\0') break;
            if(tempChar == '\n') break;

            tempArr2[tempI - startVal] = tempChar;
	    if(strcmp(tempStr, "BOARDID") == 0) boardIDArr[tempI - startVal] = tempChar;
	    else if(strcmp(tempStr, "CHANNELMIN") == 0) channelMinArr[tempI - startVal] = tempChar;
	    else if(strcmp(tempStr, "CHANNELMAX") == 0) channelMaxArr[tempI - startVal] = tempChar;
	    else if(strcmp(tempStr, "ADDITIONALTAG") == 0) additionalTagArr[tempI - startVal] = tempChar;

	    ++tempI;
	  }

	  tempStr2 = &(tempArr2[0]);
	  tempStr2[tempI - startVal] = '\0';

	  //CFM: HERE WE GRAB ALL THE VALUES IN THE CONFIG FILE
	  if(strcmp(tempStr, "BOARDID") == 0){
	    boardID = &(boardIDArr[0]);
	    boardID[tempI - startVal] = '\0';
	  }
	  else if(strcmp(tempStr, "CHANNELMIN") == 0){
	    channelMin = &(channelMinArr[0]);
	    channelMin[tempI - startVal] = '\0';
	  }
	  else if(strcmp(tempStr, "CHANNELMAX") == 0){
	    channelMax = &(channelMaxArr[0]);
	    channelMax[tempI - startVal] = '\0';
	  }
	  else if(strcmp(tempStr, "ADDITIONALTAG") == 0){
	    additionalTag = &(additionalTagArr[0]);
	    additionalTag[tempI - startVal] = '\0';
	  }
	  else if(strcmp(tempStr, "DODEBUG") == 0) doDebug = atoi(tempStr2);
	  else if(strcmp(tempStr, "NUMBEROFLOOP") == 0) nloop = atoi(tempStr2);
	  else if(strcmp(tempStr, "NUMBEROFEVENT") == 0) nevent = atoi(tempStr2);
	  else if(strcmp(tempStr, "POSITIONOFMODULE") == 0) imod_start = atoi(tempStr2);
	  else if(strcmp(tempStr, "NUMBERFEM") == 0) nmod = atoi(tempStr2);
	  else if(strcmp(tempStr, "USEXMIT") == 0) isel_xmit = atoi(tempStr2);
	  else if(strcmp(tempStr, "USEDCM") == 0) isel_dcm = atoi(tempStr2);
	  else if(strcmp(tempStr, "WRITETOFILE") == 0) iwrite = atoi(tempStr2);
	  else if(strcmp(tempStr, "USEPULSE") == 0) ipulse = atoi(tempStr2);
	  else if(strcmp(tempStr, "USEEXTERNALTRIGGER") == 0) iext_trig = atoi(tempStr2);
	  else if(strcmp(tempStr, "USEPULSEGEN") == 0) igen = atoi(tempStr2);
	  else if(strcmp(tempStr, "NUMBEROFSTEPS") == 0) nstep = atoi(tempStr2);
	  else if(strcmp(tempStr, "EVENTSPERSTEP") == 0) nstep_event = atoi(tempStr2);
	  else if(strcmp(tempStr, "DACPERSTEP") == 0) nstep_dac = atoi(tempStr2);
	  else if(strcmp(tempStr, "SIGNAL") == 0) ipattern = (int)strtol(tempStr2, NULL, 16);
	  else if(strcmp(tempStr, "USEFIXEDDAC") == 0) ifix_dac = atoi(tempStr2);
	  else if(strcmp(tempStr, "L1DELAY") == 0) l1_delay = atoi(tempStr2);
	  else if(strcmp(tempStr, "LOADADCMEM") == 0) itest_ram = atoi(tempStr2);
	  else if(strcmp(tempStr, "TRIGXMITRESET") == 0) itrig_xmit_reset = atoi(tempStr2);
	}

	printf(" number of loop=%d \n", nloop);
	printf(" number per event=%d (Will be overridden)\n", nevent);
	printf(" 1st module slot number=%d\n", imod_start);
	printf(" number of FEM module=%d\n", nmod);
	printf(" use xmit module=%d\n", isel_xmit);
	printf(" write to file=%d\n", iwrite);
	printf(" use pulse=%d\n", ipulse);
	printf(" use external trigger=%d\n", iext_trig);
	printf(" use pulse generator=%d\n", igen);
	printf(" number of steps=%d\n", nstep);
	printf(" events per step=%d\n", nstep_event);
	printf(" dac per step=%d\n", nstep_dac);
	printf(" test pattern=%x\n", ipattern);
	printf(" use fixed dac=%d\n", ifix_dac);
	printf(" l1 delay=%d\n", l1_delay);		
	printf(" load adc test data memory=%d\n", itest_ram);
	printf(" remove trigger transmit reset=%d\n", itrig_xmit_reset);

	fprintf(termf, " number of loop=%d \n", nloop);
	fprintf(termf, " number per event=%d (Will be overridden)\n", nevent);
	fprintf(termf, " 1st module slot number=%d\n", imod_start);
	fprintf(termf, " number of FEM module=%d\n", nmod);
	fprintf(termf, " use xmit module=%d\n", isel_xmit);
	fprintf(termf, " use dcm module=%d\n", isel_dcm);
	fprintf(termf, " write to file=%d\n", iwrite);
	fprintf(termf, " use pulse=%d\n", ipulse);
	fprintf(termf, " use external trigger=%d\n", iext_trig);
	fprintf(termf, " use pulse generator=%d\n", igen);
	fprintf(termf, " number of steps=%d\n", nstep);
	fprintf(termf, " events per step=%d\n", nstep_event);
	fprintf(termf, " dac per step=%d\n", nstep_dac);
	fprintf(termf, " test pattern=%x\n", ipattern);
	fprintf(termf, " use fixed dac=%d\n", ifix_dac);
	fprintf(termf, " l1 delay=%d\n", l1_delay);		
	fprintf(termf, " load adc test data memory=%d\n", itest_ram);
	fprintf(termf, " remove trigger transmit reset=%d\n", itrig_xmit_reset);
      }
      else{	
	printf(" doDebug? (1/0) \n");
	fprintf(termf, " doDebug? (1/0) \n");
	scanf("%d",&doDebug);
	fprintf(termf, " USER INPUT DODEBUG: %d\n", doDebug);

	printf(" number of loop \n");
	fprintf(termf, " number of loop \n");
	scanf("%d",&nloop);
	fprintf(termf, " USER INPUT NUMBER OF LOOP: %d\n", nloop);

	printf(" number per event \n");
	fprintf(termf, " number per event \n");
	scanf("%d",&nevent);
	fprintf(termf, " USER INPUT NUMBER PER EVENT: %d\n", nevent);

	printf(" 1st module slot number \n");
	fprintf(termf, " 1st module slot number \n");
	scanf("%d",&imod_start);
	fprintf(termf, " USER INPUT 1st MODULE SLOT: %d\n", imod_start);


	printf(" number of FEM module \n");
	fprintf(termf, " number of FEM module \n");
	scanf("%d", &nmod);
	fprintf(termf, " USER INPUT NUMBER OF FEM: %d\n", nmod);


	printf(" type 1 to use xmit module \n");
	fprintf(termf, " type 1 to use xmit module \n");
	scanf("%d", &isel_xmit);
	fprintf(termf, " USER INPUT USE XMIT: %d\n", isel_xmit);

	if(isel_xmit == 1) {
	  printf(" type 1 to use dcm module \n");
	  fprintf(termf, " type 1 to use dcm module \n");
	  scanf("%d", &isel_dcm);
	  fprintf(termf, " USER INPUT USE DCM: %d\n", isel_dcm);
	}

	printf(" type 1 to write data to file \n");
	fprintf(termf, " type 1 to write data to file \n");
	scanf("%d",&iwrite);
	fprintf(termf, " USER INPUT WRITE TO FILE: %d\n", iwrite);
      }
          

      //BEGIN FILENAME CREATION - CONFIG GOOD ONLY
      int scan_here;
      if(configGood != 0){
	//CFM Note - starting length is not zero because fileNameArr is initialized
	currLen = 12;
	tempI = 0;
	printf("Size of boardID: %i \n", sizeof(boardID));
	fprintf(termf, "Size of boardID: %i \n", sizeof(boardID));
	//for (int iii = 0; iii < 8; iii++) printf("%s",iii);
	while(tempI < 100){
	  if(doDebug == 1) printf("1. tempI: %i \n", tempI);
	  tempChar = boardID[tempI];
	  if(doDebug == 1) printf("tempI: %f \n", tempChar);
	  
	  if(tempChar == '\0') break;
	  fileNameArr[currLen + tempI] = tempChar;      
	  ++tempI;
	}
	currLen += tempI;
	
	tempI = 0;
	while(tempI < 8){
	  if(doDebug == 1) printf("2. tempI: %i \n", tempI);
	  fileNameArr[currLen + tempI] = fileNameArr2[tempI];
	  ++tempI;
	}
	currLen += tempI;
	
	tempI = 0;
	while(tempI < 100){
	  if(doDebug == 1) printf("3. tempI: %i \n", tempI);
	  tempChar = channelMin[tempI];
	  if(tempChar == '\0') break;
	  fileNameArr[currLen + tempI] = tempChar;      
	  ++tempI;
	}
	currLen += tempI;

	fileNameArr[currLen] = 't';
	++currLen;
	fileNameArr[currLen] = 'o';
	++currLen;
	
	tempI = 0;
	while(tempI < 100){
	  if(doDebug == 1) printf("4. tempI: %i \n", tempI);
	  tempChar = channelMax[tempI];
	  if(tempChar == '\0') break;
	  fileNameArr[currLen + tempI] = tempChar;      
	  ++tempI;
	}
	currLen += tempI;
	
	fileNameArr[currLen] = '_';
	++currLen;
	
	tempI = 0;
	while(tempI < 8){
	  if(doDebug == 1) printf("5. tempI: %i \n", tempI);
	  fileNameArr[currLen + tempI] = dateBuffer[tempI];
	  ++tempI;
	}
	currLen += tempI;
	
	fileNameArr[currLen] = '_';
	++currLen;
	tempI = 0;
	while(tempI < 100){
	  if(doDebug == 1) printf("6. tempI: %i \n", tempI);
	  tempChar = additionalTag[tempI];
	  if(tempChar == '\0') break;
	  fileNameArr[currLen + tempI] = tempChar;      
	  ++tempI;
	}
	currLen += tempI;
	
	fileNameArr[currLen] = '.';
	++currLen;
	fileNameArr[currLen] = 'd';
	++currLen;
	fileNameArr[currLen] = 'a';
	++currLen;
	fileNameArr[currLen] = 't';
	++currLen;
	fileNameArr[currLen] = '\0';
      }
      else{
	fileNameArr[0] = 'o';
	fileNameArr[1] = 'u';
	fileNameArr[2] = 't';
	fileNameArr[3] = 'p';
	fileNameArr[4] = 'u';
	fileNameArr[5] = 't';
	fileNameArr[6] = '/';
	fileNameArr[7] = 't';
	fileNameArr[8] = 'e';
	fileNameArr[9] = 's';
	fileNameArr[10] = 't';
	fileNameArr[11] = '_';

	//Hardcoded length from above
	currLen = 12;
        tempI = 0;
        while(tempI < 8){
          if(doDebug == 1) printf("5. tempI: %i \n", tempI);
          fileNameArr[currLen + tempI] = dateBuffer[tempI];
          ++tempI;
        }
        currLen += tempI;

	fileNameArr[currLen] = '.';
        ++currLen;
        fileNameArr[currLen] = 'd';
        ++currLen;
        fileNameArr[currLen] = 'a';
        ++currLen;
        fileNameArr[currLen] = 't';
        ++currLen;
        fileNameArr[currLen] = '\0';	
      }

      fileName = &(fileNameArr[0]);

      if(iwrite ==1) outf = fopen(fileName, "w");
      //END FILENAME CREATE


      if(configGood == 0){
       printf(" enter 1 to use pulse \n");
       fprintf(termf, " enter 1 to use pulse \n");
       scanf("%d",&ipulse);

       printf(" enter 1 to use external trigger \n");
       fprintf(termf, " enter 1 to use external trigger \n");
       scanf("%d",&iext_trig);

       printf(" enter 1 to use pulse generator module \n");
       fprintf(termf, " enter 1 to use pulse generator module \n");
       scanf("%d", &igen);

       if(igen == 1) {
	 printf(" enter number of steps \n");
	 fprintf(termf, " enter number of steps \n");
	 scanf("%d", &nstep);

	 printf(" event per step \n");
	 fprintf(termf, " event per step \n");
	 scanf("%d", &nstep_event);

	 printf(" dac value per step \n");
	 fprintf(termf, " dac value per step \n");
	 scanf("%d", &nstep_dac);

	 printf(" enter test pattern %x \n");
	 fprintf(termf, " enter test pattern %x \n");
	 scanf("%x", &ipattern);

	 printf(" type 1 for fix dac \n");
	 fprintf(termf, " type 1 for fix dac \n");
	 scanf("%d", &ifix_dac);

	 printf(" number of loop=%d \n", nloop);
	 printf(" number per event=%d (Will be overridden)\n", nevent);
	 printf(" 1st module slot number=%d\n", imod_start);
	 printf(" number of FEM module=%d\n", nmod);
	 printf(" use xmit module=%d\n", isel_xmit);
	 printf(" write to file=%d\n", iwrite);
	 printf(" use pulse=%d\n", ipulse);
	 printf(" use external trigger=%d\n", iext_trig);
	 printf(" use pulse generator=%d\n", igen);
	 printf(" number of steps=%d\n", nstep);
	 printf(" events per step=%d\n", nstep_event);
	 printf(" dac per step=%d\n", nstep_dac);
	 printf(" test pattern=%x\n", ipattern);

	 fprintf(termf, " number of loop=%d \n", nloop);
	 fprintf(termf, " number per event=%d (Will be overridden)\n", nevent);
	 fprintf(termf, " 1st module slot number=%d\n", imod_start);
	 fprintf(termf, " number of FEM module=%d\n", nmod);
	 fprintf(termf, " use xmit module=%d\n", isel_xmit);
	 fprintf(termf, " write to file=%d\n", iwrite);
	 fprintf(termf, " use pulse=%d\n", ipulse);
	 fprintf(termf, " use external trigger=%d\n", iext_trig);
	 fprintf(termf, " use pulse generator=%d\n", igen);
	 fprintf(termf, " number of steps=%d\n", nstep);
	 fprintf(termf, " events per step=%d\n", nstep_event);
	 fprintf(termf, " dac per step=%d\n", nstep_dac);
	 fprintf(termf, " test pattern=%x\n", ipattern);

	 usleep(5000000);
       }
     }

     if(iwrite == 1) {
       if(igen == 1){
	 fprintf(outf,"BOARDID: %s\n", boardID);
	 fprintf(outf,"CHANNELMIN: %s\n", channelMin);
	 fprintf(outf,"CHANNELMAX: %s\n", channelMax);
	 fprintf(outf,"ADDITIONALTAG: %s\n", additionalTag);
	 fprintf(outf,"CONFIGFILENAME: %s\n", configFileName);
	 fprintf(outf,"DATE: %s\n", dateStr);
	 fprintf(outf,"NUMBEROFSTEPS: %d\n", nstep);
	 fprintf(outf,"EVENTSPERSTEP: %d\n", nstep_event);
	 fprintf(outf,"DACPERSTEP %d\n", nstep_dac);
       }
       else{
	 fprintf(outf,"BOARDID: %s\n", boardID);
	 fprintf(outf,"ADDITIONALTAG: %s\n", additionalTag);
	 fprintf(outf,"CONFIGFILENAME: %s\n", configFileName);
	 fprintf(outf,"DATE: %s\n", dateStr);
	 fprintf(outf,"NUMBEROFEVENTS: %d\n", nevent);
       }
     }
    
     if(igen == 1){
       if(doDebug) printf("DEBUG L%d\n", __LINE__);
       nevent = nstep * nstep_event;
       printf(" event number override, final number=%d\n", nevent);       
       fprintf(termf, " event number override, final number=%d\n", nevent);
     }

     if(doDebug) printf("DEBUG L%d\n", __LINE__);

     if((ipulse !=0) | (igen != 0)) {
       if(configGood == 0){
	 printf(" enter L1 delay number \n");
	 fprintf(termf, " enter L1 delay number \n");
	 scanf("%d", &l1_delay);
       }
     }

     if(doDebug) printf("DEBUG L%d\n", __LINE__);

     if(configGood == 0){
       printf(" enter 1 to load ADC test data memory\n");
       fprintf(termf, " enter 1 to load ADC test data memory\n");
       scanf("%d", &itest_ram);
     }

      if(doDebug) printf("DEBUG L%d\n", __LINE__);

     if(doDebug){
       printf(" ADC TEST DATA MEMORY LOAD: %d\n", itest_ram);
       fprintf(termf, " ADC TEST DATA MEMORY LOAD: %d\n", itest_ram);
     }

     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
     nsample = 28;
     if(igen == 1 & iwrite == 1) {
      fprintf(outf,"NSAMPLES: %d\n", nsample);
     }
     if(isel_dcm){
       nsample = 12;
       fprintf(outf,"NUMBEROFSAMPLES: %d\n", nsample);
     }

     if(doDebug){
       printf("USING BOOTED DCM: %d\n", isel_dcm);
       fprintf(termf, "USING BOOTED DCM: %d\n", isel_dcm);
     }
     
     

     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      fprintf(termf, " boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev,imod_dcm,1, doDebug);
      //      return 1;
 
      printf(" %d \n", __LINE__);
      //      scanf(" enter 1 %d \n",&scan_here);

      printf(" boot FPGA 1-4 \n");
      fprintf(termf, " boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev,imod_dcm,2, doDebug);
 
      printf(" DCM II booting done \n");
     

      fprintf(termf, " DCM II booting done \n");
      if(configGood == 0) scanf("%d \n",&i);
      else usleep(100);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
      /* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev,1,1,px);
      //      return 1;

     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       fprintf(termf, " type 1 to do the byte ordering \n");

       if(configGood == 0) scanf("%d",&is);
       else usleep(100);

       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" %d \n", __LINE__);

      //      scanf(" enter 1 %d\n",&i);

      printf(" xmit reset complete type 1 to continue \n");
      fprintf(termf, " xmit reset complete type 1 to continue \n");
      if(configGood == 0) scanf("%d",&is);
      else usleep(100);      
     }
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
//     printf(" type 1 to send reset \n");
//     scanf("%d",&is);

     buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

       printf(" %d \n", __LINE__);

       //       scanf(" enter 1 %d",&i);
      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
//
//
      ichip =5;
      printf(" %d \n", __LINE__);

      //      scanf(" enter 1 %d",&i);
      usleep(400);
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
      if(igen ==1) {
//
// remove analog reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
	if(doDebug) printf(" %d ", __LINE__);
        usleep(10);

	//	scanf(" enter 1 %d",&i);

	if(configGood == 0){
	  printf(" trigger transmitter resets removed \n");
	  fprintf(termf, " trigger transmitter resets removed \n");
	  scanf("%d",&i);
	}
	else i = itrig_xmit_reset;

	printf(" TRIGGER TRANSMITTER RESET: %d\n", itrig_xmit_reset);
	fprintf(termf, " TRIGGER TRANSMITTER RESET: %d\n", itrig_xmit_reset);
	usleep(1000000);

	if(doDebug) printf(" %d ", __LINE__);
	

        for (is=0; is< 16; is++) {
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
         
/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
	 //CFM EDIT: loading channel output commented out temp when a config is given
	 if(configGood == 0){
	   printf(" loading channel %d, dac value \n", is);
	   fprintf(termf, " loading channel %d, dac value \n", is);
	 }
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
      if(doDebug) printf(" %d ", __LINE__);

      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//

      if(doDebug) printf(" %d ", __LINE__);

      printf(" set L1 delay module %d\n", imod);
      fprintf(termf, " set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      fprintf(termf, " buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);

      //CFM 2021.05.19: Following edits below w/ tag CFM0519 are base on comparison w/ Chi's working code

      //CFM0519: set test ram state (could be this is just giving some time to exchange info )
      if(doDebug) printf(" %d ", __LINE__);

      if(itest_ram == 1){
	printf(" type 1 to set test ram state \n");
	fprintf(termf, " type 1 to set test ram state \n");
	if(configGood == 0) scanf("%d", &is);
	else usleep(100);
      }

      //CFM0519: Replace sp_adc_sel_test_trig w/ sp_adc_test_pulse
      //      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
      //      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;

      if(doDebug) printf("DEBUG L%d\n", __LINE__);

      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      if(doDebug) printf(" %d ", __LINE__);
     
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      if(doDebug) printf("DEBUG L%d\n", __LINE__);


//
//   set select L1 trigger on
//
      if(configGood == 0){	
	printf(" type 1 to select L1 trigger \n");
	fprintf(termf, " type 1 to select L1 trigger \n");
	scanf("%d",&is);
      }
      else is = 1;

      if(doDebug) printf("DEBUG L%d\n", __LINE__);

      //CFM0519: Replace if statement, remove itest_ram component
      //      if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      if((ipulse != 0) | (igen  !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;

      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set up complete type 1 to continue \n");
      fprintf(termf, " set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//

      if(doDebug) printf("DEBUG L%d\n", __LINE__);
      
      //CFM0519 STOPPED HERE - RESUME W/ CFM0520
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
	if(doDebug) printf(" %d ", __LINE__);

        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
	if(doDebug) printf(" %d ", __LINE__);

        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        if(doDebug) printf(" rx_off called , module %d\n", imod);
        fprintf(termf, " rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      fprintf(termf, " call adc setup  module %d\n", imod);
      if(doDebug) printf(" %d ", __LINE__);

      i = adc_setup(hDev,imod, 1);

      printf("Did we get out of adc_setup ok?\n");
      fprintf(termf, "Did we get out of adc_setup ok?\n");

      if(configGood == 0){
	scanf("%d",&is);
      }
      else is = 1; //CFM EDIT

      if(doDebug) printf("DEBUG L%d\n", __LINE__);
      
      usleep(1000000);

      if(itest_ram == 1) {
       printf(" call adc setup  module %d\n", imod);
       fprintf(termf, " call adc setup  module %d\n", imod);

       if(configGood == 0) scanf("%d",&is);
       else usleep(100);
       //CFM20210521: As part of Chi's suggested tests, this line was commented out - but we do need it 
       i = adc_testram_load(hDev,imod, 400);
      }
//sp_adc_sel_link_rxoff
     }
//sp_xmit_lastmod

     if(doDebug) printf("DEBUG L%d\n", __LINE__);

     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
      fprintf(termf, " set last module %d\n", imod_start);
     }
    
     if(doDebug) printf("DEBUG L%d\n", __LINE__);

     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       fprintf(termf, " type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

      if(doDebug) printf("DEBUG L%d\n", __LINE__);

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =1;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1/* || iwrite == 1*/) {//CFM IWRITE OVERWRITE
        printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));

        fprintf(termf, "module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
        fprintf (termf, " header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        fprintf (termf, " module address = %d \n" ,(read_array[0] & 0x1f));
        fprintf (termf, " upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        fprintf (termf, " upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        fprintf (termf, " upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        fprintf (termf, " upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        fprintf (termf, " lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        fprintf (termf, " lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        fprintf (termf, " lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        fprintf (termf, " lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        fprintf (termf, " link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        fprintf (termf, " clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        fprintf (termf, " trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
       }
     }

      if(doDebug) printf("DEBUG L%d\n", __LINE__);


//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) {
	buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
	if (doDebug) printf("Debug L%d \n",__LINE__);
      }
	else if (igen != 0) {
         idac_shaper = (ia/nstep_event);
         if(ifix_dac != 1) idac_shaper = idac_shaper *nstep_dac;    //set up the dac value
	 else idac_shaper = 4000;

         imod = imod_start;
	 if (doDebug) printf("Debug L%d \n",__LINE__);
         for (is=0; is< 16; is++) {
	   ic= ipattern>> is;
	   if((ic & 0x1) != 1) idac_shaper_load =0;
	   else idac_shaper_load = idac_shaper;
	   ichip = sp_adc_slowcntl_sub;
	   buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
	   i= 1;
	   k= 1;
	   i = pcie_send_1(hDev, i, k, px);
	   usleep(10);

	   imod = imod_start;
	   ichip = sp_adc_slowcntl_sub;
	   buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
	   i= 1;
	   k= 1;
	   i = pcie_send_1(hDev, i, k, px);
	   usleep(10);

	   imod = imod_start;
	   ichip = sp_adc_slowcntl_sub;
	   buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
	   i= 1;
	   k= 1;
	   i = pcie_send_1(hDev, i, k, px);
	   usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/

	 //CFM EDIT: loading channel output commented out temp when a config is given
	   if(configGood == 0){
	     printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
	     fprintf(termf, " loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
	   }
	   //         scanf("%d",&i);

	 }
	 if (doDebug) printf("Debug L%d \n",__LINE__);
         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }//CFM20210524: Following section block commented per Chi
      /*
      else if (itest_ram == 1) {
       printf(" send test pulse trigger \n");
       fprintf(termf, " send test pulse trigger \n");
       scanf("%d", &i);
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
      }
      else if ((iext_trig != 1) & (igen != 1) & (itest_ram != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);*/
      else if ((iext_trig != 1) & (igen != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1/* || iwrite == 1*/) {//CFM EDIT HERE 2021.05.17
       if(iext_trig != 1) {
        printf(" trigger send \n");
        fprintf(termf, " trigger send \n");
        if(iwrite != 1) scanf("%d",&is); //CFM IWRITE OVERWRITE
       }
      }
      
      if(iext_trig == 1) {
       ik =0;
       while (ik != 1) {
        imod = imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if (((read_array[0] >>21) & 0x1) == 0) {
	  printf(" trigger received \n");
	  fprintf(termf, " trigger received \n");
         ik=1;
        }
       }
      }

      if (doDebug) printf("Debug L%d \n",__LINE__);
//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words       

       if(doDebug){
	 printf("nread at L%d: %d\n", __LINE__, nread);
	 fprintf(termf, "nread at L%d: %d\n", __LINE__, nread);
       }

       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       if(doDebug) printf("nread at L%d: %d\n", __LINE__, nread);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       if(doDebug) printf("nread at L%d: %d\n", __LINE__, nread);

       if(iwrite != 1) { 
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));

        fprintf(termf, " header 1 = %x\n", read_array[0]);
        fprintf(termf, " header 2 = %x\n", read_array[1]);
        fprintf(termf, " header 3 = %x\n", read_array[2]);
        fprintf(termf, " header word = %x\n", (read_array[0]& 0xffff));
        fprintf(termf, " event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        fprintf(termf, " word count = %x %d\n", iread, iread);
        fprintf(termf, " trail word = %x\n", ((read_array[2] >>16) & 0xffff));

	if(doDebug) printf("LINE: %d\n", __LINE__);

        if(iwrite != 1) scanf("%d", &is ); //CFM MOD 2021.05.14
	if(doDebug) printf("LINE: %d\n", __LINE__);
       }
//
       if(doDebug) printf("iread at L%d: %d\n", __LINE__, iread);
       iread = read_array[2] & 0xffff;
       if(doDebug) printf("nread at L%d: %d\n", __LINE__, nread);
       if(doDebug) printf("iread at L%d: %d\n", __LINE__, iread);
       nread = iread+1;
       if(doDebug) printf("nread at L%d: %d\n", __LINE__, nread);
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;

       if(doDebug) printf("LINE: %d\n", __LINE__);

//
       if(doDebug) printf("nread at L%d: %d\n", __LINE__, nread);
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words	
       if(doDebug) printf("nread at L%d: %d\n", __LINE__, nread);

       if(doDebug) printf("LINE: %d\n", __LINE__);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);

       if(doDebug) printf("LINE: %d\n", __LINE__);

       if(doDebug) printf("nread at L%d: %d\n", __LINE__, nread);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       if(doDebug) printf("nread at L%d: %d\n", __LINE__, nread);

       if(doDebug) printf("LINE, nread: %d, %d\n", __LINE__, nread);

       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) { 
	  if(i%8 == 0){
	    printf("%3d",i);
	    fprintf(termf, "%3d",i);
	  }
         printf(" %9x",u32Data);
         fprintf(termf, " %9x",u32Data);
         if(i%8 == 7){
	   printf("\n");
	   fprintf(termf, "\n");
	 }
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if(i%8 == 7) fprintf(outf,"\n");
        }
	if((i%8) != 0) fprintf(outf,"\n");
	//        if((i%8) != 7) fprintf(outf,"\n");
       }
  
       if(iwrite != 1) {
	 if((i%8) != 7){
	   printf("\n");
	   fprintf(termf, "\n");
	 }

        scanf("%d", &i );
        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
	//        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
	//        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
	//        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
	//        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));

        fprintf(termf, " event number = %d \n", ( read_array1[1] & 0xffff));
        fprintf(termf, " flag word = %x \n", (read_array1[2] & 0xffff));
        fprintf(termf, " detector ID = %x \n", (read_array1[3] & 0xffff));
        fprintf(termf, " module address = %x \n", (read_array1[4] & 0xffff));
        fprintf(termf, " clock number = %x \n", (read_array1[5] & 0xffff));
        ////fprintf(termf, " FEM header = %x \n", (read_array1[6] & 0xffff));
        ////fprintf(termf, " FEM module address= %x \n", (read_array1[7] & 0xffff));
        ////fprintf(termf, " FEM event number = %d \n", (read_array1[8] & 0xffff));
        ////fprintf(termf, " FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
       //       iparity =0;
       //CFM EDIT: Chi's code had another for loop here - replicating
       for(ic=0; ic<nmod; ++ic){
	 ioffset = (64*nsample+4+2)*ic;              // 4 words header + 2 word parity
	 iparity =0;
	 
	 if(iwrite !=1){
	   printf(" FEM header = %x \n", (read_array1[6+ioffset] & 0xffff));
	   printf(" FEM module address= %x \n", (read_array1[7+ioffset] & 0xffff));
	   printf(" FEM event number = %d \n", (read_array1[8+ioffset] & 0xffff));
	   printf(" FEM clock number = %x \n", (read_array1[9+ioffset] & 0xffff));

	   fprintf(termf, " FEM header = %x \n", (read_array1[6+ioffset] & 0xffff));
	   fprintf(termf, " FEM module address= %x \n", (read_array1[7+ioffset] & 0xffff));
	   fprintf(termf, " FEM event number = %d \n", (read_array1[8+ioffset] & 0xffff));
	   fprintf(termf, " FEM clock number = %x \n", (read_array1[9+ioffset] & 0xffff));
	 }
       
	 for (is=0; is<4+(nsample*64); is++) {
	   if(is%2 == 0) u32Data = (read_array1[is+6+ioffset] & 0xffff) <<16;
	   else {
	     u32Data = u32Data + (read_array1[is+6+ioffset] & 0xffff);
	     //         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
	     iparity = iparity ^ u32Data;
	   }
	 }
	 ioffset_t = ioffset + (64*nsample+4)+6; // 4 words header + 5 event header -1 for array started at 0                                               
	 
	 i= ((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t + 1] & 0xffff);
	 if(i != iparity) {
	   printf(" event = %d, Partity error....... = %x %x\n", ia, i, iparity);
	   fprintf(termf, " event = %d, Partity error....... = %x %x\n", ia, i, iparity);
	   //scanf("%d", &i);
	 }
	 if(iwrite != 1){
	   printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);
	   fprintf(termf, " event = %d, Partity word = %x %x\n", ia, i, iparity);
	 }
       
	 if(iwrite != 1) {
	   printf(" parity word = %x\n", iparity);
	   printf(" packet parity word = %x\n", (((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff)));
	   
	   fprintf(termf, " parity word = %x\n", iparity);
	   fprintf(termf, " packet parity word = %x\n", (((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff)));

	   scanf("%d", &i );
	   for (is=0; is<nsample; is++) {
	     for (k=0; k<32; k++) {
	       adc_data[k*2][is] = read_array1[11 + ioffset_t +((k*nsample+is)*2)] & 0xffff;
	       adc_data[(k*2)+1][is] = read_array1[10 + ioffset_t +((k*nsample+is)*2)] & 0xffff;
	     }
	   }
	   for (is=0; is<64; is++) {
	     printf(" channel %d ", is);
	     fprintf(termf," channel %d ", is);
	     for (k=0; k<nsample; k++) {
	       printf(" %4x", adc_data[is][k]);
	       fprintf(termf, " %4x", adc_data[is][k]);
	     }
	     printf("\n");
	     fprintf(termf, "\n");
	   }
	   scanf("%d", &i );
	 }
       }//CFM NOTE EVERYTHING ABOVE HERE IS DCM WRITE ONLY
      }
      

      //if (doDebug) printf("Debug L%d \n",__LINE__);

//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;
	if (doDebug) printf("Debug L%d \n",__LINE__);
//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
	if (doDebug) printf("Debug L%d \n",__LINE__);
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }
	if (doDebug) printf("Debug L%d \n",__LINE__);
        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
	else{//CFM EDIT HER - else{ w/ above to if (iwrite ==, != 1)
	//	if(iwrite == 1 || iwrite != 1){
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }
	if (doDebug) printf("Debug L%d \n",__LINE__);
        k=0;
        for (is=0; is< (nread-2); is++) {
	  if (doDebug) printf("Debug L%d \n",__LINE__);
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else{//CFM EDIT HER - else{ w/ above to if (iwrite ==, != 1)
	 //	 if(iwrite == 1 || iwrite != 1){
	   if(is%8 ==0) printf(" %d ", is);
	   printf(" %x", read_array[is+2]);
         }
	 if (doDebug) printf("Debug L%d \n",__LINE__);
         k=k+1;

         if(iwrite == 1) {
	   if((k%8) ==0) fprintf(outf,"\n");
         }
	 else{//CFM EDIT HER - else{ w/ above to if (iwrite ==, != 1)
	   // if(iwrite == 1 || iwrite != 1){
          if((k%8) ==0) printf("\n");
         }
        }
	if (doDebug) printf("Debug L%d \n",__LINE__);
        if(iwrite == 1) {
	  if((is%8) !=0) fprintf(outf,"\n");
	  //	  fprintf(outf,"\n");
        }
	else{//CFM EDIT HER - else{ w/ above to if (iwrite ==, != 1)
	  //if(write == 1 || iwrite != 1){
         if((is%8) !=0) printf("\n");
        }
	if (doDebug) printf("Debug L%d \n",__LINE__);
        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
	if (doDebug) printf("Debug L%d \n",__LINE__);
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");//CFM EDIT HER - else{ w/ above to if (iwrite ==, != 1)
	//	if(iwrite != 1 || iwrite == 1) printf("\n");
//        printf(" parity = %x  \n", iparity);
	if (doDebug) printf("Debug L%d \n",__LINE__);
        if(iwrite != 1){//CFM EDIT HER - iwrite != 1 w/ above to if (iwrite ==, != 1)
	  //	if(iwrite != 1 || iwrite == 1){
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }

	 if (doDebug) printf("Debug L%d \n",__LINE__);
         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }
	if (doDebug) printf("Debug L%d \n",__LINE__);
     

        //if(iwrite != 1) {//CFM EDIT HER - iwrite != 1 w/ above to if (iwrite ==, != 1)
        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//

//      fclose(termf);
      if (doDebug) printf("Debug L%d \n",__LINE__);
      if(iwrite ==1) {
       if((ia%100) == 0) printf(" write event = %d \n", ia);
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
     
       if(configGood == 0){
	 scanf("%d",&is);
       }
       else is = 1;
      }
     }
     fclose(termf);                                                                                  
     break;



    case 5:
     nloop=100 ;
     nevent =200;
     imod_start=18;
     nmod=1;
     isel_xmit =0;
     iwrite =0;
     ipulse =0;
     iext_trig =0;
     igen = 0;

     printf(" number of loop \n");
//    scanf("%d",&nloop);
     printf(" number per event \n");
//     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
//     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
//     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     printf(" type 1 to write data to file \n");
//     scanf("%d",&iwrite);
//     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
     if(iwrite ==1) outf = fopen("/dev/null","w");
//
//
//
     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
//     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" DAC start value \n");
      scanf("%d", &dac_start);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
     }
     if(igen == 1 & iwrite == 1) {
      fprintf(outf," %d\n", nstep);
      fprintf(outf," %d\n", nstep_event);
      fprintf(outf," %d\n", nstep_dac);
     }

     if(igen == 1) nevent = nstep * nstep_event;
     if(igen == 1) printf(" event is going to be %d\n", nevent);


     if((ipulse !=0) | (igen != 0)) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     }


     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
     nsample = 12;
     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev,imod_dcm,1, 0);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev,imod_dcm,2, 0);
      printf(" DCM II booting done \n");
      scanf("%d",&i);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev,1,1,px);
     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
//    for (j=0; j<nloop; j++) {
     printf(" enter 1 for initialization \n");
     scanf("%d",&i);
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//     printf(" enter 1 for initialization \n");
//     scanf("%d",&i);
//    }
//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       scanf("%d",&is);
       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);



     }
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
//     printf(" type 1 to send reset \n");
//     scanf("%d",&is);

     buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
      if(igen ==1) {
//
// remove analog reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" trigger transmitter resets removed \n");
        scanf("%d",&i);


        for (is=0; is< 16; is++) {
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value \n", is);
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
//      printf(" type 1 to send sample size \n");
//      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
//      printf(" type 1 to send sample size");
//      scanf("%d",&is);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
      if((ipulse != 0) | (igen  !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
      scanf("%d",&is);
//sp_adc_sel_link_rxoff



     }
//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =1;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1) {
        printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
       }
      }


      printf(" enter trigger loop \n");
//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else if (igen != 0) {
         idac_shaper = (ia/nstep_event);
         idac_shaper = idac_shaper *nstep_dac+dac_start;    //set up the dac value

         imod = imod_start;
         for (is=0; is< 16; is++) {
         ic= ipattern>> is;
         if((ic & 0x1) != 1) idac_shaper_load =0;
         else idac_shaper_load = idac_shaper;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
//         scanf("%d",&i);

        }

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }
      else if ((iext_trig != 1) & (igen != 1) )
       {
        printf(" send controller trigger \n");
        scanf("%d",&is);
        buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
       }
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }

      if(iext_trig == 1) {
       if(isel_dcm != 1) {
        ik =0;
        while (ik != 1) {
         imod = imod_start;
         nword =1;
         py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
         ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
         buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
//
         i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
         ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
         py = &read_array;
         i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         if (((read_array[0] >>21) & 0x1) == 0) {
          printf(" trigger received \n");
          ik=1;
         }
        }
       }
       else {
//        printf(" enter DCM II event wait loop\n");
//
//      reset the busy from the controller
//
        buf_send[0]= (0x2<<8)+sp_cntrl_busyrst+ (0<<16);
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        nword = 2;
        i = pcie_rec(hDev,0,1,nword,iprint,py);       // init receiver
        ichip =5;
        buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_status_read;  /* turn on status read*/
        buf_send[1]=0x5555aaaa;
        ik = pcie_send(hDev, 1, 2, px);  //** for dcm2 status read send 2 words **//
        usleep(10);
        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//        printf(" DCMII FPGA 5 status word = %x , %x\n", read_array[0], read_array[1]);
//        if((read_array[0] & 0x10000000) == 0) printf(" DCM II buffer has event \n");
        if((read_array[0] & 0x40000000) != 0) printf(" DCM II buffer hold is on \n");
//        printf(" enter DCM status loop, type 1 to continue\n");
        while ( (read_array[0] & 0x10000000) != 0) {
//        for (ik=0; ik<10000; ik++) {
         nword = 2;
         i = pcie_rec(hDev,0,1,nword,iprint,py);       // init receiver
         ichip =5;
         buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_status_read;  /* turn on status read*/
         buf_send[1]=0x5555aaaa;
         ik = pcie_send(hDev, 1, 2, px);  //** for dcm2 status read send 2 words **//
         usleep(10);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//         printf(" DCMII FPGA 5 status word = %x , %x\n", read_array[0], read_array[1]);
//         if((read_array[0] & 0x10000000) == 0) printf(" DCM II buffer has event \n");
//        if((read_array[0] & 0x40000000) != 0) printf(" DCM II buffer hold is on \n");
//         printf(" enter DCM status loop, type 1 to continue\n");
//         scanf("%d", &i);
        }
       }
      }


//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
        scanf("%d", &i );
       }
//
       iread = read_array[2] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) {
         if(i%8 == 0) printf("%3d",i);
         printf(" %9x",u32Data);
         if(i%8 == 7) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if(i%8 == 7) fprintf(outf,"\n");
        }
        if((i%8) != 7) fprintf(outf,"\n");
       }

       if(iwrite != 1) {
        if((i%8) != 7) printf("\n");
        scanf("%d", &i );
        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
//        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
//        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
//        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
//        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
//       iparity =0;
       for (ic=0; ic< nmod; ic++ ){
        ioffset = (64*nsample+4+2)*ic;              // 4 words header + 2 word parity
        iparity =0;
        if(iwrite !=1)printf(" FEM header = %x \n", (read_array1[6+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM module address= %x \n", (read_array1[7+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM event number = %d \n", (read_array1[8+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM clock number = %x \n", (read_array1[9+ioffset] & 0xffff));

        for (is=0; is<4+(nsample*64); is++) {
         if(is%2 == 0) u32Data = (read_array1[is+6+ioffset] & 0xffff) <<16;
         else {
          u32Data = u32Data + (read_array1[is+6+ioffset] & 0xffff);
//         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
          iparity = iparity ^ u32Data;
         }
        }
        ioffset_t = ioffset + (64*nsample+4)+6;   // 4 words header + 5 event header -1 for array started at 0
        i= ((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff);
        if(i != iparity) {
         printf(" event = %d, module %d Partity error....... = %x %x\n", ia, (imod_start+ic), i, iparity);
         if(iwrite != 1) scanf("%d", &i);
        }
        if(iwrite != 1) printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);

        if(iwrite != 1) {
         printf(" parity word = %x\n", iparity);
         printf(" packet parity word = %x\n", (((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff)));
         scanf("%d", &i );
         for (is=0; is<nsample; is++) {
          for (k=0; k<32; k++) {
           adc_data[k*2][is] = read_array1[11+ioffset+((k*nsample+is)*2)] & 0xffff;
           adc_data[(k*2)+1][is] = read_array1[10+ioffset+((k*nsample+is)*2)] & 0xffff;
          }
         }
         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
          printf("\n");
         }
         scanf("%d", &i );
        }
       }
      }


//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }

        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if (iwrite != 1) printf(" parity = %x  \n", iparity);
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
      if(iwrite ==1) {
       if((ia%10) == 0) printf(" write event = %d \n", ia);
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
     break;

    case 6:
     printf(" controller busy taggle test \n");

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     
     printf(" controller init done \n");
     
     for (is=0; is<10000; is++) {
      printf(" type 1 to rest busy from trigger \n");
      scanf("%d", &ik);
//
//   send init to the controller
//
      buf_send[0]= (0x2<<8)+sp_cntrl_busyrst+ (0<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }

     break;
//
//
//
//
    case 7:
     printf(" eprom test \n");

     px = &buf_send;
     py = &read_array;
     imod =18;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     printf(" controller init done \n");
//
//
//

//     for (is=0; is<10000; is++) {
     printf(" type 1 for eprom testimg routine -- reset \n");
//     scanf("%d", &ik);
//
     ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
//
//    reset eprom
//
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_reset_p + (0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     printf(" enter operation type \n");
     printf("    1 for reading EPROM ID \n");
     printf("    2 for read EPROM data \n");
     printf("    3 for bulk erase \n");
     printf("    4 for program EPROM \n");
     printf("    5 read eprom status \n");
     printf("    6 write eprom sector protect \n");
     printf("    7 sector erase \n");
     printf("    8 reconfigure the FPGA \n");
     scanf("%d", &itest);
     switch (itest){

//
      case 1:
       printf(" type 1 for eprom testimg routine -- read ID \n");
       scanf("%d", &ik);
//
//    read eprom id
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_read_id_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//
//
//
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       i= eprom_readback(hDev,imod,0, py);
       printf(" eprom readback status %x\n",i);
//
       nword = 2;
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
       break;
//
//
      case 2:
       for (ia=0; ia<79872; ia++) {
        if(ia ==0) {
         printf(" type 1 for eprom testimg routine -- read data word print \n");
         printf(" type 2 for compressed print \n");
         scanf("%d", &ij);
//
//

        }
//
//
        ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
//
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_l + ((ia & 0xffff)<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
//        usleep(1);
//       printf(" add low\n");
//       scanf("%d", &ik);
//
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_h + (((ia>>16) & 0xffff)<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
//       printf(" add low\n");
//       scanf("%d", &ik);
//        usleep(1);
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_read_pulse + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1);
//       printf(" read\n");
//       scanf("%d", &ik);
//
//
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        nword = 2;
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//       printf("module %d address %d receive data word = %x, %x \n", imod, ia, read_array[0], read_array[1]);
//        printf(" address = %x, data = %x \n", ia, (read_array[1] & 0xff));
        if(ij == 1) if((ia%16)==0) printf("%7d", ia);
//      printf("%4x",carray[ia]);
        i = ((read_array[1] & 0x1) <<7 |
          (read_array[1] & 0x2) <<5 |
          (read_array[1] & 0x4) <<3 |
          (read_array[1] & 0x8) <<1 |
          (read_array[1] & 0x10) >>1 |
          (read_array[1] & 0x20) >>3 |
          (read_array[1] & 0x40) >>5 |
          (read_array[1] & 0x80) >>7);
//        printf("%4x",(read_array[1] & 0xff));
        if(ij== 1) {
         printf("%4x",(i & 0xff));
         if((ia+1)%16 == 0) printf("\n");
        }
        else read_array_s[ia] = i;
       }
       printf(" end of loop1 \n");
       if(ij != 1) {
        ib=79872/16;
        for (ia=0; ia<ib; ia++) {
         k=0;         for (ik=0; ik<16; ik++) {
          if(read_array_s[(ia*16)+ik] !=0xff) k=1;
         }
         if(k != 0) {
          printf("%6d", ia*16);
          for (ik=0; ik<16; ik++) {
           printf("%4x", read_array_s[(ia*16)+ik]);
          }
          printf("\n");
         }
        }
       }
       break;
      case 3:
       printf(" type 1 for eprom testimg routine -- bulk erase \n");
       scanf("%d", &ik);
//
//    read eprom id
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_bulk_erase_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       i= eprom_readback(hDev,imod,0,py);
       k=0;
       while ((i & 0x1000000) !=0)  {
        k=k+1;
        i= eprom_readback(hDev,imod,0,py);
        usleep(1000000);
        printf(" counter %d eprom readback status %x\n",k,i);
       }
       printf(" bulk erase done \n");
       break;

      case 4:
       printf(" type 1 for eprom testimg routine -- write RPD file to the EPROM \n");
       scanf("%d", &ik);
       ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
//
//
//
//    reset eprom   - reset address
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_reset_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
       printf(" reset done type 1 to continue \n");
       scanf("%d", &ik);
       is=0;
       inpf = fopen("/home/chi/sphenix_adc_eprom.rpd","r");
       count = 0;
       counta =0;
       addr_w =0;
       while (fread(&charchannel,sizeof(char),1,inpf)==1) {
        carray[counta] = charchannel;
        count++;
        counta++;
        if((count%1000) ==0) printf(" write data to address %d address %x,lower %x, upper %x\n", count, addr_w, (addr_w & 0xffff),((addr_w>>16) & 0xffff));
        if(counta == 256) {
         ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
//
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_l + ((addr_w & 0xffff)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//          usleep(1);
//       printf(" add low\n");
//       scanf("%d", &ik);
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_h + (((addr_w>>16) & 0xffff)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//
///
//         printf(" set address %x \n", addr_w);
//         scanf("%d", &ik);

//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_wdata;

         for (ia=0; ia< counta; ia++) {
          ik=0;
          ik= ((carray[ia] & 0x80) >>7) + ((carray[ia] & 0x40) >>5) + ((carray[ia] & 0x20) >>3);
          ik = ik + ((carray[ia] & 0x10) >>1) + ((carray[ia] & 0x8) <<1) + ((carray[ia] & 0x4) <<3);
          ik = ik + ((carray[ia] & 0x2) <<5) + ((carray[ia] & 0x1) <<7);
          write_eprom_array[ia] = carray[ia];
          if((ia%2) ==0) {
           ij= ia/2;
           buf_send[ij]= buf_send[ij] + (ik<< 16);
//           buf_send[ij]= buf_send[ij] + (carray[ia]<< 16);
          }
          else buf_send[ij+1] = ik;

//          if((ij%8 == 0) & (ia%2 ==0)) printf("%4d", ij);
//          if((ia%2) == 0) printf ("%8x", buf_send[ij]);
//          if((((ij+1)%8) == 0) & (ia%2 ==0)) printf("\n");
         }
//         printf ("%8x\n", buf_send[ij]);  // last data word
//         printf(" type 1 to send the data packet \n");
//         scanf("%d", &ik);

         i= 1;
         k= 129;
//         printf(" type 1 to send the write packet \n");
//         scanf("%d", &ik);
         i = pcie_send_1(hDev, i, k, px);
//
//       slow control clock rate is 15 MHz.
//       only use half of 16 bits.
//       16 Mhz per bytes
//       66ns * 256 *2  = 33 us;
//       wait for 1.5 time longer

         usleep(50);

//         printf(" type 1 to send the write pulse \n");
//         scanf("%d", &ik);

//       printf(" add low\n");
//       scanf("%d", &ik);

//
//
/*
          if ((is ==0) & (ia ==0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_wdata + (ik<<16);
          else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_wdata + ((ik+ 0x8000)<<16);
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
*/
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_w_pulse + (ik<<16);
//          if(is ==0) {
//           if((ia%8)==0) printf("%d", ia);
//      printf("%4x",carray[ia]);
//           printf("%4x",ik);
//           if((ia+1)%8 == 0) printf("\n");
 //         }
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//         usleep(1000);
//
//

         i= eprom_readback(hDev,imod,0,py);
         k=0;
         if(is <= 20) printf(" status readback %x \n", i);
         while ((i & 0x1000000) !=0)  {
          k=k+1;
          usleep(1);
          i= eprom_readback(hDev,imod,0,py);
          if(k>=2) printf(" status readback %x \n", i);
         }
         if(is <= 10) printf(" wait period %d \n",k);

         counta =0;
         is=is+1;
/*
         if(is == 1) {
           printf(" first block type 1 to continue \n");
           scanf("%d", &ik);
         }
*/
//
//      readback routine
//
         if(is == 0) {
         for (ia=0; ia< 256; ia++ ) {
//
          ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
          buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_l + (((ia+addr_w) & 0xffff)<<16) ;
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
//       printf(" add low\n");
//       scanf("%d", &ik);
//
          buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_h + ((((ia+addr_w)>>16) & 0xffff)<<16) ;
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
//       printf(" add low\n");
//          scanf("%d", &ik);
          usleep(10);
          buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_read_pulse + (0<<16) ;
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
//       printf(" read\n");
//          scanf("%d", &ik);
//
//
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
          nword = 2;
          ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
          buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
          i=1;
          k=1;
          i = pcie_send_1(hDev, i, k, px);
//
          i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
          ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
          buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
          i=1;
          k=1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
          py = &read_array;
          i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//       printf("module %d address %d receive data word = %x, %x \n", imod, ia, read_array[0], read_array[1]);
//        printf(" address = %x, data = %x \n", ia, (read_array[1] & 0xff));
//          if((ia%16)==0) printf("%7d", ia);
//      printf("%4x",carray[ia]);
          i = ((read_array[1] & 0x1) <<7 |
          (read_array[1] & 0x2) <<5 |
          (read_array[1] & 0x4) <<3 |
          (read_array[1] & 0x8) <<1 |
          (read_array[1] & 0x10) >>1 |
          (read_array[1] & 0x20) >>3 |
          (read_array[1] & 0x40) >>5 |
          (read_array[1] & 0x80) >>7);
//        printf("%4x",(read_array[1] & 0xff));
//          printf("%4x",(i & 0xff));
//          if((ia+1)%16 == 0) printf("\n");
          read_eprom_array[ia] = i;
         }
//
//
         for (ia=0; ia< 256; ia++) {
          if( read_eprom_array[ia] != write_eprom_array[ia] ) {
           printf(" block %d, ia= %d \n", is, ia);
           printf(" write = %x, read= %x \n", write_eprom_array[ia], read_eprom_array[ia]);
           scanf("%d", &ik);
          }
         }
         }
         ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
         addr_w = addr_w+256;
        }
       }
       if(feof(inpf)) {
        is =0;
        ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
        printf("You have reached the end-of-file word count= %d %d\n", counta, count);
        if(counta != 0) {
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_l + ((addr_w & 0xffff)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//          usleep(1);
         printf(" add %x\n", addr_w);
         printf(" counta = %d\n", counta);
//       scanf("%d", &ik);
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_h + (((addr_w>>16) & 0xffff)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_wdata;

         for (ia=0; ia< counta; ia++) {
          ik=0;
          ik= ((carray[ia] & 0x80) >>7) + ((carray[ia] & 0x40) >>5) + ((carray[ia] & 0x20) >>3);
          ik = ik + ((carray[ia] & 0x10) >>1) + ((carray[ia] & 0x8) <<1) + ((carray[ia] & 0x4) <<3);
          ik = ik + ((carray[ia] & 0x2) <<5) + ((carray[ia] & 0x1) <<7);
          if((ia%2) ==0) {
           ij= ia/2;
           buf_send[ij]= buf_send[ij] + (ik<< 16);
//           buf_send[ij]= buf_send[ij] + (carray[ia]<< 16);
          }
          else buf_send[ij+1] = ik;

          if((ij%8) == 0) printf("%4d", ij);
          if((ia%2) == 0) printf ("%8x", buf_send[ij]);
          if(((ij+1)%8) == 0) printf("\n");
         }
         printf ("%8x\n", buf_send[ij]);  // last data word
         printf(" type 1 to send the data packet\n");
         scanf("%d", &ik);

         i= 1;
         k= (counta/2)+1;
         i = pcie_send_1(hDev, i, k, px);

         usleep(50);

//       printf(" type 1 to send the write pulse");
//       scanf("%d", &ik);

         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_w_pulse + (ik<<16);

         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//
//
         i= eprom_readback(hDev,imod,0,py);
         k=0;
         while ((i & 0x1000000) !=0)  {
          k=k+1;
          i= eprom_readback(hDev,imod,0,py);
         }
        }
//
       }
       printf(" write is done \n");
       break;
      case 5:
       printf(" type 1 for eprom testimg routine -- read status \n");
       scanf("%d", &ik);
       ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
//
//    read eprom id
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_read_status_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//
//
//
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       i= eprom_readback(hDev,imod,0,py);
       printf(" eprom readback status %x\n",i);
       printf("module %d receive data word = %x, %x %x\n", imod, read_array[0], read_array[1], read_array[2]);
//
       nword = 3;
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       printf("module %d receive data word = %x, %x %x\n", imod, read_array[0], read_array[1], read_array[2]);
       break;
//
//
      case 6:
       printf(" eprom testimg routine -- write sector protect \n");
       printf(" enter sector protect bits \n");
       ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
       scanf("%x", &ik);
       ik = (ik & 0xff) <<2;
       printf(" block protector load in data = %x \n",ik);
//
//    load eprom data
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_wdata + (ik<<16);
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" type 1 to continue \n");
       scanf("%d", &ik);

//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_sector_protect_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//
//
//
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       i= eprom_readback(hDev,imod,0,py);
       k=0;
       while ((i & 0x1000000) !=0)  {
        k=k+1;
        i= eprom_readback(hDev,imod,0,py);
       }
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_read_status_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
       i= eprom_readback(hDev,imod,0,py);
       printf(" eprom readback status %x\n",i);
       printf("module %d receive data word = %x, %x %x\n", imod, read_array[0], read_array[1], read_array[2]);
//
       break;
//
//
      case 7:
       printf(" type 1 for eprom testimg routine -- sector erase \n");
       scanf("%d", &ik);
       printf(" enter starting address for erasing (in hex) \n");
       scanf("%x", &ik);
       printf(" enter number sector to erase \n");
       scanf("%d", &nsector);
//
//
//
       for (ij=0; ij<nsector; ij++) {
        ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section

//
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_l + ((ik & 0xffff)<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//      printf(" add low\n");
//      scanf("%d", &ik);
//
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_h + (((ik>>16) & 0xffff)<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        if(ij == 0) {
         printf(" issue sector erase command \n");
         scanf("%d", &ia);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_erase_sector + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
//       printf(" add low\n");
//       scanf("%d", &ik);

//
//    read eprom status
//

        i= eprom_readback(hDev,imod,0,py);
        k=0;
        while ((i & 0x1000000) !=0)  {
         k=k+1;
         i= eprom_readback(hDev,imod,0,py);
         usleep(1000000);
//         printf(" counter %d eprom readback status %x\n",k,i);
        }
        printf(" counter %d eprom readback status %x\n",k,i);
        if(ij%2 ==0) printf(" loop counter %d , address = %x \n", ij, ik);
        ik =ik+0x10000;
       }
       printf(" bulk erase done \n");
       break;
//
//
      case 8:
       printf(" type 1 for eprom reloading testing \n");
       printf(" send the eprom remote update reset \n");
       scanf("%d", &ik);
//
//
//
       ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
//
//    reset remote update ip core
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_reset + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//
//     set remote parameter   -- timeout value
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_param + (0x5<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
       printf(" setting the configuration mode \n");
       scanf("%d", &ik);
       ij= 0x1;  // set timer upper 12 bits to 0x100
//
//    time out vale is 29 bits, upper 12 bits is what we are loading.
//    bits 0 is egula to 0x20000, with 15 Mhz clock = 8.65 ms
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_l + ((ij & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//       usleep(10);
//       printf(" load data high %x %x\n", ij, (ij>>16));
//       scanf("%d", &ik);
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_h + (((ij>>16) & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" done loading... \n");
       printf(" enter 1 to write configuration mode parameter \n");
       scanf("%d", &ik);
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_write_param + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" finish write configuration mode value \n");
       scanf("%d", &ik);
//
       printf(" set the eprom remote update parameter --- timeout value -- page \n");
       scanf("%d", &ik);
//
//
//
//
//     set remote parameter   -- timeout value
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_param + (0x2<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" set the eprom remote update timeer value \n");
       scanf("%d", &ik);
       ij= 0x400;  // set timer upper 12 bits to 0x100
//
//    time out vale is 29 bits, upper 12 bits is what we are loading.
//    bits 0 is egula to 0x20000, with 15 Mhz clock = 8.65 ms
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_l + ((ij & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//       usleep(10);
//       printf(" load data high %x %x\n", ij, (ij>>16));
//       scanf("%d", &ik);
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_h + (((ij>>16) & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" done loading... \n");
       printf(" enter 1 to write timer the parameter \n");
       scanf("%d", &ik);
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_write_param + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" finish write timeout value \n");
       scanf("%d", &ik);
//
//
//
//
//     set remote parameter   --  time out enable
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_param + (0x3<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" finish the eprom remote update timeout enable page \n");
       scanf("%d", &ik);
       ij= 0x1;  // set timer upper 12 bits to 0x100
//
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_l + ((ij & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//       usleep(10);
//       printf(" load data high %x %x\n", ij, (ij>>16));
//       scanf("%d", &ik);
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_h + (((ij>>16) & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" done loading... \n");
       printf(" enter 1 to write timeout enable the parameter \n");
       scanf("%d", &ik);
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_write_param + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" finish write timeout enable \n");
       scanf("%d", &ik);
//
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_reset_timer + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" finish reset timer  -- going to set boot address \n");
       scanf("%d", &ik);
//



//
//     set remote parameter   -- page select
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_param + (0x4<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" set the eprom remote update data \n");
       scanf("%d", &ik);
       ij= 0x1000000;  // address of secor 256
//
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_l + ((ij & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" load data %x high order 16 bits %x\n", ij, (ij>>16));
       scanf("%d", &ik);
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_h + (((ij>>16) & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" done loading... \n");
       printf(" enter 1 to write the parameter \n");
       scanf("%d", &ik);
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_write_param + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" ready to reconfigure \n");
       scanf("%d", &ik);
//
//         update reset timer again
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_reset_timer + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//       printf(" finish reset timer  -- going to set boot address \n");
 //      scanf("%d", &ik);
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_reconfig + (1<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" reconfigure done \n");
       break;
//
//

//#define  sp_adc_update_data_in_l   60
//#define  sp_adc_update_data_in_h   61
//#define  sp_adc_update_reset_timer 62
//#define  sp_adc_update_write_param 63
//#define  sp_adc_update_reconfig    64
//#define  sp_adc_update_param       65
//#define  sp_adc_update_reset       66
     }
//#define  sp_adc_eprom_addr_l       50
//#define  sp_adc_eprom_addr_h       51
//#define  sp_adc_eprom_wdata        52
//#define  sp_adc_eprom_w_pulse      53
//#define  sp_adc_eprom_read_pulse   54
//#define  sp_adc_eprom_bulk_erase_p 55
//#define  sp_adc_eprom_read_status_p  56
//#define  sp_adc_eprom_read_id_p    57
//#define  sp_adc_eprom_reset_p      58

     break;




    case 8:
     inpf = fopen("/home/chi/sphenix_adc_eprom.rpd","r");
     count = 0;
     printf(" controller init done \n");
        /* read data as characters (28941) */
     while (fread(&charchannel,sizeof(char),1,inpf)==1) {
     printf(" controller init done \n");
       carray[count] = charchannel;
       count++;
       if(count == 30000) break;
     }
//     if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d\n", count);
//     }

     for (ia=0; ia<1000; ia++) {
      ik=0;
      ik= ((carray[ia] & 0x80) >>7) + ((carray[ia] & 0x40) >>5) + ((carray[ia] & 0x20) >>3);
      ik = ik + ((carray[ia] & 0x10) >>1) + ((carray[ia] & 0x8) <<1) + ((carray[ia] & 0x4) <<3);
      ik = ik + ((carray[ia] & 0x2) <<5) + ((carray[ia] & 0x1) <<7);
      if((ia%8)==0) printf("%d", ia);
//      printf("%4x",carray[ia]);
      printf("%4x",ik);
      if((ia+1)%8 == 0) printf("\n");
     }

     break;


    case 9:
     printf(" ADC trigger testing routine \n");
//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     imod = 18;
     nsample_trig = 20;
     ndelay_trig = 14;
     ifake_width = 10;
     ifake_start = 70;
     trig_rw_delay =2;


     px = &buf_send;
     py = &read_array;

//     fake_pulse = {0x1ff, 0xfff, 0x1fff, 0x2fff, 0x1fff, 0xfff, 0x1ff, 0x0, 0x0, 0x0};
/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

/*     printf(" trigger routine test option \n");
     printf("  1) trigger table loading test \n");
     printf("  2) load fake data \n");
     scanf("%d", &itest);
     switch (itest){
*/
/*
#define  sp_adc_trig_sub_delay      1
#define  sp_adc_trig_tbl_chnl       2
#define  sp_adc_trig_lkp_addr       3
#define  sp_adc_trig_lkp_data       4
#define  sp_adc_trig_smpl_phase     5
#define  sp_adc_trig_lkp_write     10
*/
 //     case 1:
       ichip = sp_adc_trigproc_sub;
       for (ia =0; ia <64; ia ++) {
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_tbl_chnl + (ia<<16);  // set channel 0 to 63
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
//        printf("type 1 to continue \n");
//        scanf("%d",&i);
        for (ik=0; ik<1023; ik++) {
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_addr + (ik<<16);  // set table write address
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//         printf("load address type 1 to continue \n");
//         scanf("%d",&i);
         itrig_lk_data = ik+ia+1;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_data + ( itrig_lk_data <<16);  // set lookup table data word
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//         printf("load data type 1 to continue \n");
//         scanf("%d",&i);
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_write + (ik<<16);  // just a write pulse
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
 //        printf("issue write type 1 to continue \n");
//         scanf("%d",&i);
         trig_lookup[ia][ik]= itrig_lk_data;
        }
//        printf(" end of channel %d \n", ia);
//        scanf("%d", &i);
       }
//
//
//
/*
       printf(" print fake data after lookup \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6d" , trig_lookup[ich][iad]);
        }
        printf("\n");
       }
*/

       printf(" end of load channel %d \n", ia);
        scanf("%d", &i);

//       break;
//      case 2:
       printf(" fake data loading starting position \n");
       scanf("%d", &ifake_start);

       ichip = sp_adc_input_sub ;   // controller data go to ADC input section

       for (ich=0; ich< 64; ich++) {
        if(ich== 0)  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (64<<16);  // set channel 0 to 64
        else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (ich<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
//        usleep(1);
//        printf(" load testram ch = %d, module %d\n", ich, imod);
//        scanf("%d", &i);
        is=0;
//
//
        for (iad =0; iad<512 ; iad++) {
         idata =  ich +1+ iad;
         if((iad > (ifake_start+ich)) & ( iad< ((ifake_start+ifake_width)+ich))) {
          idata = idata+fake_pulse[is];
          is=is+1;
         }
//         if(ich <4 ) idata =0;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_data + (idata<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         fake_data_array[ich][iad] = idata;

//         usleep(1);
//         printf(" load testram ch = %d, address %d, idata %x\n", ich, iad, idata);
//         scanf("%d", &i);
        }
//        scanf("%d", &i);
       }
//
/*
       printf(" print fake data after lookup \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6d" , trig_lookup[ich][iad]);
        }
        printf("\n");
       }
*/
//
       printf(" print fake data array \n");
       scanf("%d", &i);

       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6x" , fake_data_array[ich][iad]);
        }
        printf("\n");
       }
/*
       printf(" print fake data after lookup table \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%5d" , adc_data[is][k]);
        }
        printf("\n");
       }
*/


//
//     set up parameter before the run
//
//#define  sp_adc_trig_read_delay     6
//#define  sp_adc_trig_read_size      7
//#define  sp_adc_trig_sub_delay      1
       ichip = sp_adc_trigproc_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_sub_delay + (trig_rw_delay<<16);  // set trigger substract delay to 2
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//

       for (ich =0; ich< 64; ich++) {
        for (iad =0; iad< 512 ; iad++) {
         if (iad < (trig_rw_delay+3)) fake_data_array_sub[ich][iad] = fake_data_array[ich][iad];
         else {
          if (fake_data_array[ich][iad] >= fake_data_array[ich][iad-trig_rw_delay-3] )
          i=  fake_data_array[ich][iad]- fake_data_array[ich][iad-trig_rw_delay-3];
          else i =0;
          fake_data_array_sub[ich][iad] = i;
         }
        }
       }
//
//
       printf(" print fake data after substraction \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6x" , fake_data_array_sub[ich][iad]);
        }
        printf("\n");
       }

       for (ich =0; ich< 64; ich++) {
        for (iad =0; iad< 512 ; iad++) {
          fake_data_array_sub_lk[ich][iad] = fake_data_array_sub[ich][iad] >>4;
        }
       }
//
//
//
       printf(" print fake data before lookup \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6x" , fake_data_array_sub_lk[ich][iad]);
        }
        printf("\n");
       }
//
//
//
       printf(" print fake data after lookup \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         i= fake_data_array_sub_lk[ich][iad];
         printf("%6x" , trig_lookup[ich][i]);
        }
        printf("\n");
       }

       for (ia=0; ia<16; ia++) {
        ich = ia*4;
        for (iad=0; iad<512; iad++) {
          i = fake_data_array_sub_lk[ich][iad];
          fake_data_array_sub_lk_sum[ia][iad] = trig_lookup[ich][i];
          i = fake_data_array_sub_lk[ich+1][iad];
          fake_data_array_sub_lk_sum[ia][iad] = trig_lookup[ich+1][i] + fake_data_array_sub_lk_sum[ia][iad] ;
          i = fake_data_array_sub_lk[ich+2][iad];
          fake_data_array_sub_lk_sum[ia][iad] = trig_lookup[ich+2][i] + fake_data_array_sub_lk_sum[ia][iad] ;
          i = fake_data_array_sub_lk[ich+3][iad];
          fake_data_array_sub_lk_sum[ia][iad] = trig_lookup[ich+3][i] + fake_data_array_sub_lk_sum[ia][iad] ;
        }
       }
//
//
       printf(" print fake data after sum \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6x" , fake_data_array_sub_lk_sum[ich][iad]);
        }
        printf("\n");
       }

//
//
       printf(" print fake data after sum  4 bits shift \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6x" , (fake_data_array_sub_lk_sum[ich][iad] >>4));
        }
        printf("\n");
       }
//fake_data_trig_out[16,100], ntrig_w, ntrig_st;
//
       ntrig_st =1;
       for (ich =0; ich< 16; ich++) {
        i = ntrig_st;
        ntrig_w = 0;
        for (iad =0; iad< 512 ; iad++) {
         i=i+1;
         if((i%6) == 0) {
           ntrig_w = ntrig_w+1;
           fake_data_trig_out[ich][(ntrig_w -1)] = (fake_data_array_sub_lk_sum[ich][iad] >>4);
         }
        }
       }
//
//
//
       printf(" print fake trigger output \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6x" , fake_data_trig_out[ich][iad]);
        }
        printf("\n");
       }



//
//#define  sp_adc_trig_smpl_phase      5
       ichip = sp_adc_trigproc_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_smpl_phase + (0x5<<16);  // set trigger sample phase 5
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//#define  sp_adc_trig_smpl_phase      5
       ichip = sp_adc_trigproc_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_read_size + ((nsample_trig & 0xff)<<16);  // set trigger read size to 6
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//#define  sp_adc_trig_smpl_phase      5
       ichip = sp_adc_trigproc_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_read_delay + ((ndelay_trig & 0xff)<<16);  // set trigger read delay to 7
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//     select test trig generated from the pulse to generate L1 trigger
//
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
       i = pcie_send_1(hDev, i, k, px);
//
//       set readback from the controller
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//       printf(" type 1 to set test ram trigger delay \n");
//       scanf("%d",&is);
//
//
//     set L1 trigger delay for test pulse
//
       ichip = sp_adc_input_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_trig_delay + (0x60<<16) ;
       i = pcie_send_1(hDev, i, k, px);

//
//   send init to the controller
//
       buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
       printf(" type 1 to send reset \n");
       scanf("%d",&is);

       buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);

//
       printf(" send test pulse trigger \n");
       scanf("%d", &i);
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
       i = pcie_send_1(hDev, i, k, px);
//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_trig       4
//
//
       printf(" send readback signal \n");
       scanf("%d", &i);
       ichip = sp_adc_readback_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_trig + (0x0<<16) ;
       i = pcie_send_1(hDev, i, k, px);
//
//
//       printf(" how many word to readback \n");
//       scanf("%d", &nread);
         nread = ((nsample_trig+1)*4)+3;

//
//
//
//       nread =2+(64*nsample/2)+1;
       i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);
//
//
       i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words

       printf(" header 1 = %x\n", read_array[0]);
       printf(" header 2 = %x\n", read_array[1]);

/*
       k=0;
       for (is=0; is< (nread-2); is++) {
        if(is%8 ==0) printf(" %d ", is);
        printf(" %x", (read_array[is+2]));
        k=k+1;
        if((k%8) ==0) printf("\n");
       }
*/



       for (ia=0; ia< 4; ia++) {
        for (is=0; is < (nsample_trig+1) ; is++) {
          i= ia*(nsample_trig+1)+is+2;
          trig_smp_data[(ia*4)+2][is] = (read_array[i] & 0xff);
          trig_smp_data[(ia*4)+3][is] = ((read_array[i]>>8) & 0xff);
          trig_smp_data[(ia*4)+0][is] = ((read_array[i]>>16) & 0xff);
          trig_smp_data[(ia*4)+1][is] = ((read_array[i]>>24) & 0xff);
        }
       }
//
//
//
       for (ia=0; ia<16; ia++) {
        printf(" %3d ", ia);
        for (is=0; is< (nsample_trig+1); is++) {
         printf(" %6x", trig_smp_data[ia][is]);
        }
        printf("\n");
       }
/*
         printf(" %d ", is);
         printf(" %4x", (read_array[is+2] & 0xff));

       for (is=0; is< (nread-2); is++) {
        if(is%8 ==0) printf(" %d ", is);
        printf(" %x", (read_array[is+2] & 0xff));
        printf(" %x", ((read_array[is+2] >>8) & 0xff));
        printf(" %x", ((read_array[is+2] >>16) & 0xff));
        printf(" %x", ((read_array[is+2] >>24) & 0xff));
        printf(" \n");
//        k=k+1;
//        if((k%8) ==0) printf("\n");
       }
*/
       scanf("%d", &i);
//      break;
//     }

    break;

    case 10:
     printf(" controllerf lopp back test \n");
     nsend=500;

     px = &buf_send;
     py = &read_array;
// 
//   reset controller with first data word equal to zero
//
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     printf(" reset controller \n");
     printf(" enter 1 to tune loopback on \n");
     scanf("%d", &i);
     buf_send[0]=0x1;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
     printf(" nword to lopback \n");
     scanf("%d", &nread);
     printf(" number of time to run the loopback test \n");
     scanf("%d", &nloop);
     printf (" enter 1 for random number \n");
     scanf("%d", &irand);
     printf (" enter 1 to compare \n");
     scanf("%d", &icheck);
     printf(" enter 1 for print \n");
     scanf("%d", &iprint);

     for (ia=0; ia<nloop; ia++) {
//
//     nread = 10;
      i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
//
//
      buf_send[0]=0x1;
//      if((j%10)== 1) printf(" event %d", j);
      for (j=0; j<nread; j++) {
       if(irand == 1) buf_send[j+1] = rand();
       else buf_send[j+1] =j;
      }
      i=1;
      k=nread;
      i = pcie_send_1(hDev, i, k, px);
      if(iprint == 1) {
       printf(" sending data %d \n", nread);
       for (is=0; is< (nread+1); is++) {
        if((is%8) == 0) printf("%6d", is);
        printf(" %8x", buf_send[is]);
        if(((is+1)%8) == 0) printf("\n");
       }
       if(((is)%8) != 0) printf("\n");
      }
      if(iprint ==1 ) {
       printf(" finish sending nprint \n");
       scanf("%d", &i);
      }
//
//
      i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
//      if((j%10)== 1) printf(" event %d", j);
      if(iprint == 1) {
       printf(" read data %d \n", nread);
       for (is=0; is< (nread+1); is++) {
        if((is%8) == 0) printf("%6d", is);
        printf(" %8x", read_array[is]);
        if(((is+1)%8) == 0) printf("\n");
       }
       if(((is)%8) != 0) printf("\n");
      }
      if(iprint ==1 ) {
       printf(" finish reading print \n");
       scanf("%d", &i);
      }
      if(icheck ==1) {
       ierror =0;
       for (is=0; is<nread; is++) {
        if(buf_send[is] != read_array[is]) ierror =1;
       }
       if(ierror == 1) {
        printf(" error event = %d \n", ia);
        printf(" sending data %d \n", nread);
        for (is=0; is< (nread+1); is++) {
         if((is%8) == 0) printf("%6d", is);
         printf(" %8x", buf_send[is]);
         if(((is+1)%8) == 0) printf("\n");
        }
        if(((is)%8) != 0) printf("\n");
        printf(" read data %d \n", nread);
        for (is=0; is< (nread+1); is++) {
         if((is%8) == 0) printf("%6d", is);
         printf(" %8x", read_array[is]);
         if(((is+1)%8) == 0) printf("\n");
        }
        if(((is)%8) != 0) printf("\n");
       }
      }
      if((ia%100) ==1 )printf(" event %d \n", ia);
     }

    break;

    case 11:
     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     printf(" enter 1 to continue \n");
     scanf("%d", &itest);
     i = pcie_send_1(hDev, i, k, px);
     printf(" controller init done \n");
//
//
// #define  sp_cntrl_loopback_on       1
// #define  sp_cntrl_loopback_off      2
// #define  sp_cntrl_offline           3
// #define  sp_cntrl_online            4
// #define  sp_cntrl_isprst_on         5
// #define  sp_cntrl_isprst_off        6
// #define  sp_cntrl_seldisc_off       0
// #define  sp_cntrl_seldisc_on        7
//
//
     printf(" controller test routine \n");
     printf("    1 for on/line off line \n");
     printf("    2 for loop backup test \n");
     printf("    3 reset for the lattice clock chip \n");
     printf("    4 set for beam beam data \n");
     printf("    5 for controller status readback\n");
     scanf("%d", &itest);
     switch (itest){
      case 1:
       printf(" enter online/offline testing routine \n");
       for (ik=0; ik<1000; ik++) {
        printf(" enter 1 to set be offline state, 10 to get off the loop\n");
        scanf("%d", &ia);
        if(ia ==10) break;
        imod=0;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
//
        printf(" enter 1 to set be online state \n");
        scanf("%d", &ia);
        imod=0;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable online run on
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
       }
      case 2:
       printf(" enter loopback testing routine \n");
       for (ik=0; ik<1000; ik++) {
        printf(" enter 1 to set be offline state, 10 to get off the loop\n");
        scanf("%d", &ia);
        if(ia ==10) break;
        imod=0;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_loopback_on)+(0x0<<16); //enable loopback on
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        printf(" command send \n");
        imod=30;
        nsend=100;
        nread =100;
//
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
//
        for (ib=0; ib<nsend; ib++) {
         if(ib==0) buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_loopback_on)+(ib<<16);
         else buf_send[ib]=((ib*2)-1)+((ib*2)<<16);
        }
        k=nsend;
        i=1;
        i = pcie_send_1(hDev, i, k, px);
        printf(" data send \n");
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        printf(" read data %d \n", nread);
        for (is=0; is< (nread+1); is++) {
         if((is%8) == 0) printf("%6d", is);
         printf(" %8x", read_array[is]);
         if(((is+1)%8) == 0) printf("\n");
        }
        if(((is)%8) != 0) printf("\n");
//
        printf(" enter 1 to set loop back to off state\n");
        scanf("%d", &ia);
//
        imod=0;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_loopback_off)+(0x0<<16); //enable loopback on
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);

       }
      case 3:
       printf(" lattice chip reset study\n");
       printf(" set the device to offline state before reset can be applied \n");
//
       imod=0;
       ichip=0;
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       for (ik=0; ik<1000; ik++) {
        printf(" enter 1 to ssend reset, 10 to get off the loop\n");
        scanf("%d", &ia);
        if(ia ==10) break;
        imod=0;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0x0<<16); //enable offline run on
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
//
        printf(" enter 1 to remove the reset\n");
        scanf("%d", &ia);
        imod=0;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_off)+(0x0<<16); //enable online run on
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
       }
      case 4:
       printf(" discriminator traffic study\n");
//
//
       for (ik=0; ik<1000; ik++) {
        printf(" enter 1 to set data packet to discriminatir, 10 to get off the loop\n");
        scanf("%d", &ia);
        if(ia ==10) break;
        imod=31;
        ichip=7;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0xffff<<16); // crate alternative bit pattern
        buf_send[1]=(0)+(0xffff<<16);
        i=1;
        k=2;
        i = pcie_send_1(hDev, i, k, px);
//
//
        printf(" enter 1 to remove data packet go to discriminator\n");
        scanf("%d", &ia);
        imod=31;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0xffff<<16); // crate alternative bit pattern
        buf_send[1]=(0)+(0xffff<<16);
        i=1;
        k=2;
        i = pcie_send_1(hDev, i, k, px);
       }
      }
      break;

     break;

    case 12:
//
//
     nloop=100 ;
     nevent =200;
     imod_start=18;
     nmod=1;
     isel_xmit =0;
     iwrite =0;
     ipulse =0;
     iext_trig =0;
     igen = 0;
     l1_delay=12;
     itest_ram = 0;
//
     printf(" number of loop \n");
//     scanf("%d",&nloop);
     printf(" number per event \n");
//     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
//     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
//     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     printf(" type 1 to write data to file \n");
//     scanf("%d",&iwrite);
//     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
//
//
//
     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
//     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
     }


     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
     nsample = 12;

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;
///
/// initialize **/
//      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
     printf(" enter 1 to ssend reset, 10 to get off the loop\n");
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0x0<<16); //enable reset on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000000);
//
//
     printf(" enter 1 to remove the reset\n");
     scanf("%d", &ia);
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_off)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);

//      set devicd to online state
//     printf(" enter 1 to set system to online state \n");
//     scanf("%d",&i);

     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
     printf(" enter 1 to initial through ADC, module %d\n", imod_start);
     scanf("%d",&i);
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212

//
//   send init to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_init+ (0<<16);
     printf(" imod = %x, ichip = %x, buf_send[0] = %x\n", imod, ichip, buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
//
     printf(" enter 1 to enter discriminator loop \n");
     scanf("%d",&ia);
     if(ia == 1) {
       for (ib=0; ib< 1000000; ib++) {
         imod =31;
         ichip =7;
         buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
         scanf("%d",&ia);
//
//
         printf(" enter discriminator threshold DAC setup loop \n");
         for (ic=0; ic< 8; ic++) {
          imod =14;  //clock fanout module address
          ichip =0;
          buf_send[0]= (imod<<11)+(ichip<<8)+1+ (((ic<<12)+ 0xfff)<<16);   // set channel IC DAC value
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
          printf(" channel %d DAC set \n", ic);
          scanf("%d",&ia);
//
          imod =14;  //clock fanout module address
          ichip =0;
          buf_send[0]= (imod<<11)+(ichip<<8)+1+ (((ic<<12))<<16);   // pulse
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
         }



         printf(" enter the pulse loop \n");
         for (ic=0; ic< 1000000; ic++) {
//          imod =22;  //clock fanout module address
//          ichip =0;
//          buf_send[0]= (imod<<11)+(ichip<<8)+1+ (0<<16);   // pulse
//          i= 1;
//          k= 1;
//          i = pcie_send_1(hDev, i, k, px);
//          usleep(10);
//
          imod =14;  //clock fanout module address
          ichip =0;
          buf_send[0]= (imod<<11)+(ichip<<8)+1+ (0x1fff<<16);   // pulse
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
//
//
          imod =14;  //clock fanout module address
          ichip =0;
          buf_send[0]= (imod<<11)+(ichip<<8)+4+ (0<<16);   // pulse
          i= 1;
          k= 1;
//          i = pcie_send_1(hDev, i, k, px);
//          usleep(10);


         }
         scanf("%d",&ia);
//
         printf(" enter the set delay loop \n");
         for (ic=0; ic< 1000000; ic++) {
          imod =22;  //clock fanout module address
          ichip =0;
          buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // sel delay off
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
//         scanf("%d",&ia);
//
          imod =22;  //clock fanout module address
          ichip =0;
          buf_send[0]= (imod<<11)+(ichip<<8)+2+ (0<<16);   // sel delay on
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
         }
         scanf("%d",&ia);


//
//
         imod =31;
         ichip =0;
         buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);  // slecdisc off
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
         scanf("%d",&ia);
       }
     }

     printf(" enter 1 to reset through ADC\n");
     scanf("%d",&i);
//
//   send reset to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_reset+ (0<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);


//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)



     imod = ik+imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
      printf(" type 1 to set L1 delay \n");
      scanf("%d",&is);
     if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
     printf(" buf_send = %x\n", buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set select L1 trigger on
//
     printf(" type 1 to select L1 trigger \n");
     scanf("%d",&is);
     if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
     if(isel_xmit == 1) {
      if(imod != imod_start) {
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" rx_off called , module %d\n", imod);
      }
     }
     printf(" call adc setup  module %d\n", imod);
     i = adc_setup(hDev,imod, 1);
     scanf("%d",&is);
//sp_adc_sel_link_rxoff


//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
      for (ia=0; ia<nevent; ia++) {
       if(iwrite != 1) {
        printf(" type 1 to send L1 trigger \n");
        scanf("%d",&is);
       }

       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
         printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
         printf (" module address = %d \n" ,(read_array[0] & 0x1f));
         printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
         printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
         printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
         printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
         printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
         printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
         printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
         printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
         printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
         printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
         printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
        }
       }



//     for (ijk=0; ijk<1000000000; ijk++) {
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212

//
//   send init to the controller
//
       printf(" enter 1 to send L1 trigger\n");
       scanf("%d",&i);

       imod = imod_start;
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_l1+ (0<<16);
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
///




//      }
/*
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }
*/


//
//
//

//

       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
         iparity = iparity ^ read_array[is];
        }
        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
         if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }

        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
           printf(" %4x", adc_data[is][k]);
          }
          printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
//     }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
       if(iwrite ==1) {
        if((ia%10) == 0) printf(" write event = %d \n", ia);
       }
      }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
    break;






    case 14:
//
//
//

     printf(" enter discriminator module address \n");
     scanf("%d",&imod_disc);

     px = &buf_send;
     py = &read_array;

     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;
///
/// initialize **/
//      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
     printf(" enter 1 to ssend reset\n");
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0x0<<16); //enable reset on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000000);
//
//
     printf(" enter 1 to remove the reset\n");
//     scanf("%d", &ia);
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_off)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);

//      set devicd to online state
//     printf(" enter 1 to set system to online state \n");
//     scanf("%d",&i);

     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
     printf(" enter 1 to initial through ADC, module %d\n", imod_start);
//     scanf("%d",&i);
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212

//
//   send init to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_init+ (0<<16);
     printf(" imod = %x, ichip = %x, buf_send[0] = %x\n", imod, ichip, buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_on;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set controller slow control go to MBD system \n");
//     scanf("%d",&ia);
//
     printf(" number of loop, 1 for single loop\n");
     scanf("%d",&ia);
     nloop =10000000;
     if(ia == 1) nloop =1;
//
/*
#define  sp_mbd_disc_led           10
#define  sp_mbd_disc_charge_dac     4
#define  sp_mbd_disc_pulse_even     6
#define  sp_mbd_disc_pulse_odd      5
#define  sp_mbd_disc_disc_dac       1

#define  sp_mbd_clk_pulse           1
#define  sp_mbd_clk_delay_off       0
#define  sp_mbd_clk_delay_on        2
#define  sp_mbd_clk_add            22
#define  sp_cntrl_loopback_on       1
#define  sp_cntrl_loopback_off      2
#define  sp_cntrl_offline           3
#define  sp_cntrl_online            4
#define  sp_cntrl_isprst_on         5
#define  sp_cntrl_isprst_off        6
#define  sp_cntrl_seldisc_off       0
#define  sp_cntrl_seldisc_on        7
#define  sp_cntrl_seldisc_add      31
*/
     for (ic=0; ic<100000; ic++ ){
      printf(" MBD sytem test routine \n");
      printf("    1 set the clock fanout delay \n");
      printf("    2 send test pulse from clock module \n");
      printf("    3 set discriminator charge injector DAC \n");
      printf("    4 set discriminator firing pattern \n");
      printf("    5 set discriminator threshold level\n");
      scanf("%d", &itest);
      switch (itest){
       case 1:
        printf(" set clock fanout delay, 1 for on, 0 for off \n");
        scanf("%d",&ia);
        for (ik=0; ik<nloop; ik++) {
        imod = sp_mbd_clk_add;
        ichip=0;
        if(ia == 0) buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_off)+(0x0<<16); //enable delay on
        else buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_on)+(0x0<<16); //enable delay ff
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//        scanf("%d",&ia);
        usleep(10);
        }
        scanf("%d",&ia);
        break;
       case 2:
        printf(" send test pulse from clock module \n");
        for (ik=0; ik<nloop; ik++) {
         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
        break;
       case 3:
        printf(" set discriminator charge injector DAC \n");
//        printf(" enter channel number \n");
//        scanf("%d",&idisc_ch);
        printf(" enter charge injector DAC value \n");
        scanf("%d",&idisc_dac);
//
         imod = imod_disc;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_charge_dac)+((idisc_dac & 0xfff)<<16) ;
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
         break;
       case 4:
        printf(" discrimintaor pulse, 1 for odd, 0 for even \n");
        scanf("%d",&ia);
        if(ia == 0) ijk = sp_mbd_disc_pulse_even;
        else ijk = sp_mbd_disc_pulse_odd;
        for (ik=0; ik<nloop; ik++) {
         imod = imod_disc;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(0x1<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
//
//
         imod = imod_disc;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

        }
        break;
//
//
       case 5:
        printf(" dicriminator threshold DAC setting \n");
        printf(" enter the channel number, 8 for all channel \n");
        scanf("%d", &idisc_ch);
        printf(" enter the DAC value in hex \n");
        scanf("%x", &idisc_thr);

        if(idisc_ch !=8) {
         imod = imod_disc;
         ichip=0;
         ijk = ((idisc_ch & 0x7)<<12) + (idisc_thr &0xfff);
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_disc_dac)+(ijk<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
        else {
         for (ib=0; ib<8; ib++) {
          imod = imod_disc;
          ichip=0;
          ijk = ((ib & 0x7)<<12) + (idisc_thr &0xfff);
          buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_disc_dac)+(ijk<<16);
          i=1;
          k=1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
         }
        }
        break;
//
//
       }
      }
     break;


    case 15:
//
//
     nloop=100 ;
     nevent =6000;
     imod_start=18;
     nmod=1;
     isel_xmit =0;
     iwrite =0;
     ipulse =0;
     iext_trig =0;
     igen = 0;
     l1_delay=12;
     itest_ram = 0;
     imod_disc = 10;
     nsample = 20;
//
     printf(" l1 delay \n");
     scanf("%d",&l1_delay);
     printf(" number of loop \n");
//     scanf("%d",&nloop);
     printf(" number per event \n");
//     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
//     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
//     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite == 1) {
      printf(" type 1 for binary write \n");
      scanf("%d",&ibin);
      if(ibin == 1) outf = fopen("/home/chi/test_binary.dat","w");
      else outf = fopen("/home/chi/test.dat","w");
     }
     printf(" test pulse firing pattern \n");
     printf(" 0 for no test pulse, 1 for odd, 2 for even and 3 for both \n");
     scanf("%d",&itest_pattern);
     printf(" type 1 for alternate delay to test pulse \n");
     scanf("%d",&test_pulse_d);
//
//
//
     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
//     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
     }


     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;


//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;
///
/// initialize **/
//      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
     printf(" enter 1 to ssend reset, 10 to get off the loop\n");
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0x0<<16); //enable reset on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000000);
//
//
     printf(" enter 1 to remove the reset\n");
     scanf("%d", &ia);
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_off)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);

//      set devicd to online state
//     printf(" enter 1 to set system to online state \n");
//     scanf("%d",&i);

     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//   set slow control to discriminator system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_on;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set controller slow control go to MBD system \n");
//     scanf("%d",&ia);
//
//
//
//*************
     idisc_dac = 4000;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_charge_dac)+((idisc_dac & 0xfff)<<16) ;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set the discriminator charge injector \n");
     scanf("%d",&i);
//
//    low true
//
     if(itest_pattern == 0) {
       itest_odd =1;
       itest_even =1;
     }
     else if (itest_pattern == 1) {
       itest_odd =0;
       itest_even =1;
     }
     else if (itest_pattern == 2) {
       itest_odd =1;
       itest_even =0;
     }
     else {
       itest_odd =0;
       itest_even =0;
     }


     ijk = sp_mbd_disc_pulse_odd;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_odd<<16);
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

     ijk = sp_mbd_disc_pulse_even;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_even<<16);
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set the discriminator charge injector  patten \n");
     scanf("%d",&i);
//
//
//
     idisc_thr =20; // set discriminator threshold level
     for (ib=0; ib<8; ib++) {
      imod = imod_disc;
      ichip=0;
      ijk = ((ib & 0x7)<<12) + (idisc_thr &0xfff);
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_disc_dac)+(ijk<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
     printf(" set the discriminator threshold level \n");
     scanf("%d",&i);



//
//
/*
     for (ik=0; ik<100000000; ik++) {
      imod = sp_mbd_clk_add;
      ichip=0;
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
*/
//
//   set slow control back to ADC system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_off;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

//
//
     printf(" enter 1 to initial through ADC, module %d\n", imod_start);
     scanf("%d",&i);
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212

//
//   send init to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_init+ (0<<16);
     printf(" imod = %x, ichip = %x, buf_send[0] = %x\n", imod, ichip, buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
     printf(" enter 1 to reset through ADC\n");
     scanf("%d",&i);
//
//   send reset to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_reset+ (0<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);


//
//   set sample size  -- to 10
//
     printf(" type 1 to send sample size \n");
     scanf("%d",&is);



     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
      printf(" type 1 to set L1 delay \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//    if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
     printf(" buf_send = %x\n", buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set select L1 trigger on
//
     printf(" type 1 to select L1 trigger \n");
     scanf("%d",&is);
     if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
     if(isel_xmit == 1) {
      if(imod != imod_start) {
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" rx_off called , module %d\n", imod);
      }
     }
     printf(" call adc setup  module %d\n", imod);
     i = adc_setup(hDev,imod, 1);
     scanf("%d",&is);
//sp_adc_sel_link_rxoff


//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
      for (ia=0; ia<nevent; ia++) {
       if(iwrite != 1) {
        printf(" type 1 to send L1 trigger \n");
        scanf("%d",&is);
       }

       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
         printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
         printf (" module address = %d \n" ,(read_array[0] & 0x1f));
         printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
         printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
         printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
         printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
         printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
         printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
         printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
         printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
         printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
         printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
         printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
        }
       }



//     for (ijk=0; ijk<1000000000; ijk++) {
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212
//
//
//
//   set slow control to discrimeter
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_on;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);
       if(iwrite != 1) {
        printf(" set slow control to discriminator  \n");
        scanf("%d",&is);
       }


//
//#define  sp_mbd_clk_delay_off       0
//#define  sp_mbd_clk_delay_on        2//   send init to the controller
//
       if(iwrite != 1) {
        printf(" enter 1 to send MBD test pulse and L1 trigger\n");
        scanf("%d",&i);
       }
//      for (ik=0; ik<100000000; ik++) {
       if(test_pulse_d == 1) {
        if((ia%2) ==0 ) {
         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_off)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
        else {
         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_on)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
       }
       else {
        imod = sp_mbd_clk_add;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_off)+(0x0<<16);
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
       }
//       printf(" set discriminator pulse  \n");
//       scanf("%d",&is);


       imod = sp_mbd_clk_add;
       ichip=0;
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }
//       printf(" set slow control to discriminator  \n");
//       scanf("%d",&is);


///

//
//   set slow control back to ADC system
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_off;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0x0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);


//      }
/*
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }
*/


//
//
//

//

       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
         iparity = iparity ^ read_array[is];
        }
        if ((iwrite == 1)) {
         if(ibin ==0) fprintf(outf," %x\n", read_array[0]);
         if(ibin ==0) fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if((iwrite == 1)) {
          if(ibin == 0) fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if((iwrite == 1)) {
          if(((k%8) ==0) && (ibin ==0)) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
//         if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }
        if((iwrite ==1) && (ibin == 1)) {
         fwrite(&nread, sizeof(UINT32), 1, outf);
         fwrite(&read_array, sizeof(UINT32), nread, outf);
        }
        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) {
          if(ibin == 0) fprintf(outf,"\n");
        }
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
           printf(" %4x", adc_data[is][k]);
          }
          printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
//     }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
       if(iwrite ==1) {
        if((ia%10) == 0) printf(" write event = %d \n", ia);
       }
      }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
    break;


    case 16:
//
//
     nloop=100 ;
     nevent =6000;
     imod_start=18;
     nmod=1;
     isel_xmit =0;
     iwrite =0;
     ipulse =0;
     iext_trig =0;
     igen = 0;
     l1_delay=12;
     itest_ram = 0;
     imod_disc = 10;
     nsample = 20;
//
     printf(" l1 delay \n");
     scanf("%d",&l1_delay);
     printf(" number of loop \n");
//     scanf("%d",&nloop);
     printf(" number per event \n");
//     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
//     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
//     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite == 1) {
      printf(" type 1 for binary write \n");
      scanf("%d",&ibin);
      if(ibin == 1) outf = fopen("/home/chi/test_binary.dat","w");
      else outf = fopen("/home/chi/test_l_dac.dat","w");
     }
     printf(" test pulse firing pattern \n");
     printf(" 0 for no test pulse, 1 for odd, 2 for even and 3 for both \n");
     scanf("%d",&itest_pattern);
     printf(" type 1 for alternate delay to test pulse \n");
     scanf("%d",&test_pulse_d);
//
//
//
     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     printf(" enter 1 to test charge inject DAC \n");
     scanf("%d", &idac_scan);
//     scanf("%d", &igen);
     if(idac_scan == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      nevent = nstep*nstep_event;
//      printf(" enter test pattern %x \n");
//      scanf("%x", &ipattern);
     }


     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;


//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;
///
/// initialize **/
//      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
     printf(" enter 1 to ssend reset, 10 to get off the loop\n");
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0x0<<16); //enable reset on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000000);
//
//
     printf(" enter 1 to remove the reset\n");
     scanf("%d", &ia);
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_off)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);

//      set devicd to online state
//     printf(" enter 1 to set system to online state \n");
//     scanf("%d",&i);

     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//   set slow control to discriminator system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_on;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set controller slow control go to MBD system \n");
//     scanf("%d",&ia);
//
//
//
//*************
     idisc_dac = 4000;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_charge_dac)+((idisc_dac & 0xfff)<<16) ;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set the discriminator charge injector \n");
     scanf("%d",&i);
//
//    low true
//
     if(itest_pattern == 0) {
       itest_odd =1;
       itest_even =1;
     }
     else if (itest_pattern == 1) {
       itest_odd =0;
       itest_even =1;
     }
     else if (itest_pattern == 2) {
       itest_odd =1;
       itest_even =0;
     }
     else {
       itest_odd =0;
       itest_even =0;
     }


     ijk = sp_mbd_disc_pulse_odd;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_odd<<16);
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

     ijk = sp_mbd_disc_pulse_even;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_even<<16);
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set the discriminator charge injector  patten \n");
     scanf("%d",&i);
//
//
//
     idisc_thr =10; // set discriminator threshold level
     for (ib=0; ib<8; ib++) {
      imod = imod_disc;
      ichip=0;
      ijk = ((ib & 0x7)<<12) + (idisc_thr &0xfff);
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_disc_dac)+(ijk<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
     printf(" set the discriminator threshold level \n");
     scanf("%d",&i);



//
//
/*
     for (ik=0; ik<100000000; ik++) {
      imod = sp_mbd_clk_add;
      ichip=0;
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
*/
//
//   set slow control back to ADC system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_off;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

//
//
     printf(" enter 1 to initial through ADC, module %d\n", imod_start);
     scanf("%d",&i);
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212

//
//   send init to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_init+ (0<<16);
     printf(" imod = %x, ichip = %x, buf_send[0] = %x\n", imod, ichip, buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
     printf(" enter 1 to reset through ADC\n");
     scanf("%d",&i);
//
//   send reset to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_reset+ (0<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);


//
//   set sample size  -- to 10
//
     printf(" type 1 to send sample size \n");
     scanf("%d",&is);



     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
      printf(" type 1 to set L1 delay \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//    if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
     printf(" buf_send = %x\n", buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set select L1 trigger on
//
     printf(" type 1 to select L1 trigger \n");
     scanf("%d",&is);
     if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
     if(isel_xmit == 1) {
      if(imod != imod_start) {
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" rx_off called , module %d\n", imod);
      }
     }
     printf(" call adc setup  module %d\n", imod);
     i = adc_setup(hDev,imod, 1);
     scanf("%d",&is);
//sp_adc_sel_link_rxoff


//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
      for (ia=0; ia<nevent; ia++) {
       if(iwrite != 1) {
        printf(" type 1 to send L1 trigger \n");
        scanf("%d",&is);
       }

       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
         printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
         printf (" module address = %d \n" ,(read_array[0] & 0x1f));
         printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
         printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
         printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
         printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
         printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
         printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
         printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
         printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
         printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
         printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
         printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
        }
       }



//     for (ijk=0; ijk<1000000000; ijk++) {
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212
//
//
//
//   set slow control to discrimeter
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_on;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);
       if(iwrite != 1) {
        printf(" set slow control to discriminator  \n");
        scanf("%d",&is);
       }
//*************
       if(idac_scan == 1) {
        ijk = ia%nstep_event;
        ib= (ia-ijk)/nstep_event;
        if(ijk ==0) {
         idisc_dac = ib*nstep_dac;
         imod = imod_disc;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_charge_dac)+((idisc_dac & 0xfff)<<16) ;
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
//        printf(" set the discriminator charge injector \n");
//        scanf("%d",&i);
       }
       if((ia ==0) && (iwrite ==1) && (idac_scan ==1)) {
        fprintf(outf," %d\n", nstep);
        fprintf(outf," %d\n", nstep_event);
        fprintf(outf," %d\n", nstep_dac);
       }
//
//#define  sp_mbd_clk_delay_off       0
//#define  sp_mbd_clk_delay_on        2//   send init to the controller
//
       if(iwrite != 1) {
        printf(" enter 1 to send MBD test pulse and L1 trigger\n");
        scanf("%d",&i);
       }
//      for (ik=0; ik<100000000; ik++) {
       if(test_pulse_d == 1) {
        if((ia%2) ==0 ) {
         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_off)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
        else {
         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_on)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
       }
       else {
        imod = sp_mbd_clk_add;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_off)+(0x0<<16);
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
       }
//       printf(" set discriminator pulse  \n");
//       scanf("%d",&is);


       imod = sp_mbd_clk_add;
       ichip=0;
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }
//       printf(" set slow control to discriminator  \n");
//       scanf("%d",&is);


///

//
//   set slow control back to ADC system
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_off;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0x0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);


//      }
/*
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }
*/


//
//
//

//

       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
         iparity = iparity ^ read_array[is];
        }
        if ((iwrite == 1)) {
         if(ibin ==0) fprintf(outf," %x\n", read_array[0]);
         if(ibin ==0) fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if((iwrite == 1)) {
          if(ibin == 0) fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if((iwrite == 1)) {
          if(((k%8) ==0) && (ibin ==0)) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
//         if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }
        if((iwrite ==1) && (ibin == 1)) {
         fwrite(&nread, sizeof(UINT32), 1, outf);
         fwrite(&read_array, sizeof(UINT32), nread, outf);
        }
        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) {
          if(ibin == 0) fprintf(outf,"\n");
        }
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
           printf(" %4x", adc_data[is][k]);
          }
          printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
//     }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
       if(iwrite ==1) {
        if((ia%10) == 0) printf(" write event = %d \n", ia);
       }
      }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
    break;

    case 17:
//
//
     nloop=100 ;
     nevent =60000;
     imod_start=18;
     nmod=1;
     isel_xmit =0;
     iwrite =0;
     ipulse =0;
     iext_trig =0;
     igen = 0;
     l1_delay=12;
     itest_ram = 0;
     imod_disc = 10;
     nsample = 20;
     itest_pattern =0;
     test_pulse_d =0;
//
     printf(" l1 delay \n");
     scanf("%d",&l1_delay);
     printf(" number of loop \n");
//     scanf("%d",&nloop);
     printf(" number per event \n");
//     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
//     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
//     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite == 1) {
      printf(" type 1 for binary write \n");
      scanf("%d",&ibin);
      if(ibin == 1) outf = fopen("/home/chi/test_binary.dat","w");
      else outf = fopen("/home/chi/test.dat","w");
     }
/*
     printf(" test pulse firing pattern \n");
     printf(" 0 for no test pulse, 1 for odd, 2 for even and 3 for both \n");
     scanf("%d",&itest_pattern);
     printf(" type 1 for alternate delay to test pulse \n");
     scanf("%d",&test_pulse_d);
*/
//
//
//
     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
//     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
     }


     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;


//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;
///
/// initialize **/
//      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
     printf(" enter 1 to ssend reset, 10 to get off the loop\n");
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0x0<<16); //enable reset on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000000);
//
//
     printf(" enter 1 to remove the reset\n");
     scanf("%d", &ia);
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_off)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);

//      set devicd to online state
//     printf(" enter 1 to set system to online state \n");
//     scanf("%d",&i);

     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//   set slow control to discriminator system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_on;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set controller slow control go to MBD system \n");
//     scanf("%d",&ia);
//
//
//
//*************
     idisc_dac = 4000;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_charge_dac)+((idisc_dac & 0xfff)<<16) ;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set the discriminator charge injector \n");
     scanf("%d",&i);
//
//    active low
//

     if(itest_pattern == 0) {
       itest_odd =1;
       itest_even =1;
     }
     else if (itest_pattern == 1) {
       itest_odd =0;
       itest_even =1;
     }
     else if (itest_pattern == 2) {
       itest_odd =1;
       itest_even =0;
     }
     else {
       itest_odd =0;
       itest_even =0;
     }


     ijk = sp_mbd_disc_pulse_odd;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_odd<<16);
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

     ijk = sp_mbd_disc_pulse_even;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_even<<16);
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

     printf(" set the discriminator charge injector  patten \n");
     scanf("%d",&i);
//
//
//
     idisc_thr =20; // set discriminator threshold level
     for (ib=0; ib<8; ib++) {
      imod = imod_disc;
      ichip=0;
      ijk = ((ib & 0x7)<<12) + (idisc_thr &0xfff);
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_disc_dac)+(ijk<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
     printf(" set the discriminator threshold level \n");
     scanf("%d",&i);



//
//
/*
     for (ik=0; ik<100000000; ik++) {
      imod = sp_mbd_clk_add;
      ichip=0;
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
*/
//
//   set slow control back to ADC system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_off;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

//
//
     printf(" enter 1 to initial through ADC, module %d\n", imod_start);
     scanf("%d",&i);
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212

//
//   send init to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_init+ (0<<16);
     printf(" imod = %x, ichip = %x, buf_send[0] = %x\n", imod, ichip, buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
     printf(" enter 1 to reset through ADC\n");
     scanf("%d",&i);
//
//   send reset to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_reset+ (0<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);


//
//   set sample size  -- to 10
//
     printf(" type 1 to send sample size \n");
     scanf("%d",&is);



     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
      printf(" type 1 to set L1 delay \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//    if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
     printf(" buf_send = %x\n", buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set select L1 trigger on
//
     printf(" type 1 to select L1 trigger \n");
     scanf("%d",&is);

     if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
     if(isel_xmit == 1) {
      if(imod != imod_start) {
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" rx_off called , module %d\n", imod);
      }
     }
     printf(" call adc setup  module %d\n", imod);
     i = adc_setup(hDev,imod, 1);
     scanf("%d",&is);
//sp_adc_sel_link_rxoff


//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
      for (ia=0; ia<nevent; ia++) {
       if(iwrite != 1) {
        printf(" type 1 to send L1 trigger \n");
        scanf("%d",&is);
       }
       
//
//   set slow control to discrimeter
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_on;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);
       if(iwrite != 1) {
        printf(" set slow control to discriminator  \n");
        scanf("%d",&is);
       }
//
//     reset discriminator busy
//
       imod = sp_mbd_clk_add;
       ichip=0;
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_busy_reset)+(0x0<<16);
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);


//
//   set slow control back to ADC system
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_off;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0x0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);

       for (ik=0; ik<12000000; ik++) {
        imod = imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
         printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
         printf (" module address = %d \n" ,(read_array[0] & 0x1f));
         printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
         printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
         printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
         printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
         printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
         printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
         printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
         printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
         printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
         printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
         printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
        }
        if(((read_array[0]>>21) & 0x1) == 0) break;
        if(iwrite != 1) {
          printf(" receive trigger type 1 to continue\n");
          scanf("%d", &is);
        }
       }



//     for (ijk=0; ijk<1000000000; ijk++) {
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212
//
//
//


//      }
/*
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }
*/


//
//
//

//

       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
         iparity = iparity ^ read_array[is];
        }
        if ((iwrite == 1)) {
         if(ibin ==0) fprintf(outf," %x\n", read_array[0]);
         if(ibin ==0) fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if((iwrite == 1)) {
          if(ibin == 0) fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if((iwrite == 1)) {
          if(((k%8) ==0) && (ibin ==0)) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
//         if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }
        if((iwrite ==1) && (ibin == 1)) {
         fwrite(&nread, sizeof(UINT32), 1, outf);
         fwrite(&read_array, sizeof(UINT32), nread, outf);
        }
        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) {
          if(ibin == 0) fprintf(outf,"\n");
        }
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
           printf(" %4x", adc_data[is][k]);
          }
          printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
//     }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
       if(iwrite ==1) {
        if((ia%10) == 0) printf(" write event = %d \n", ia);
       }
      }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
    break;

    case 18:
     printf(" feb boot test \n");
     printf(" enable number of loop\n");
//***     scanf("%d",&nloop);
//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck = 0;
     irand =0;
     if(icheck != 1) {
      printf(" 1 for print event\n");
//***      scanf("%d",&iprint);
     }
     else iprint =0;
     printf(" number event \n");
//***     scanf("%d",&nevent);
     iprint =1;
     nloop=10;
     nevent=10;
//****

//****

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
       printf(" enter 1 to reset the dram \n");
 //****      scanf("%d",&ik);
       ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);

//
//        set adc operatio -- soft reset
//
       for (is=0; is<8; is++) {
        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
//       printf(" spi port %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0x0))+((0x3c)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x0, data =0x3c;
//

        i=1;
        k=2;
//       i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
       }
//       usleep(2000);   // sleep for 2ms
       printf(" enter 1 to continue after soft reset\n");
//***       scanf("%d",&ik);
//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
       for (is=0; is<8; is++) {
        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }

       printf(" enter 1 to continue FPGA ADC receiver reset\n");
//***       scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_reset+(0x1<<16);  // FPGA ADC receiver reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       printf(" enter 1 to continue FPGA ADC receiver align\n");
//***       scanf("%d",&ik);
//
//    send FPGA ADC align
//
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_align+(0x0<<16);  // FPGA ADC receiver reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(2000);   // sleep for 2ms

       printf(" finish align \n");
//****       scanf("%d",&ik);
//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
       for (is=0; is<8; is++) {
        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xd))+((0xb)<<24)+((0x0)<<16);          // send 1 bit high
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }




       itrig_delay = 51;
       nword =1;
//
// set to not use test generator 2, set test =2
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x0<<16);  // set test source to 0
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
       imod=0;
       ichip=1;
       iframe= 255;    //1023
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       timesize =4;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0x20;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); //wait for 5 ms


       for (is=0; is<nevent; is++) {



        imod=0;
        ichip=1;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);



//      set module number again to enable the FEB module read back

        imod=11;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        usleep(5000); // wait for 5 ms


        nword = 5;
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

        imod=11;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iprint ==1) printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
        if(iprint == 1) {
          printf(" header word %x \n",(read_array[0] & 0xffff));
          k=(read_array[0]>>16) & 0xfff;
          printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
          printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
          printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
          printf(" frame number %d\n", (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12)));
          printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
        }
        nread = ((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12);
//        if(iprint ==1) printf(" number of data word to read = %d\n",nread);

//        ik =  read_array[0] & 0x1f;
//        if(iprint ==1) printf(" module number = %d",ik);
//        ik =  (read_array[0] >> 5) & 0x7f;
//        if(iprint ==1) printf(" data ID = %d",ik);
//        ik =  (((read_array[2] >>16) & 0xfff)<<12) + (read_array[2] & 0xfff);
//        if(iprint ==1) printf(" event number = %d",ik);
//        ik =  (((read_array[3] >>16) & 0xfff)<<12) + (read_array[3] & 0xfff);
//        if(iprint ==1) printf(" frame number = %d\n",ik);
//        ik =  (((read_array[4] >>16) & 0xfff)<<12) + (read_array[4] & 0xfff);
//        if(iprint ==1) printf(" checksum = %x\n",ik);

        if(iprint ==1 )scanf("%d",&ik);
        nword = (nread+1)/2;                    // short words
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

        imod=11;
        ichip=mb_feb_pass_add;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

        if(iprint == 1) {
         for (i=0; i< nword; i++) {
          if((i%8) ==0) printf("%4d",i);
          printf(" %8x",read_array[i]);
          if(((i+1)%8) ==0 ) printf("\n");
         }
        }

        ik=0;
        for (i=0; i< nword; i++) {
          read_array_s[ik] = read_array[i] &0xffff;
          read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
          ik=ik+2;
        }

//
//      printout formatted word
//
        if(iprint ==1) {
         iset = 0;
         for(i=0; i< 2*nword; i++) {
          if((read_array_s[i] & 0xf000) == 0x4000) {
            iset=1;
            ncount=0;
            printf(" channel %d\n",(read_array_s[i] & 0xfff));
          }
          else if ((read_array_s[i] & 0xf000) == 0x5000) printf(" channel end %d\n",(read_array_s[i] &0xfff));
          else if (iset ==1) {
            printf(" %4x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
          }
          else {
            printf("%x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
          }
         }
        }

        if(icheck ==1 ){
         if((2*nword) == (64*timesize*3)){
          for (i=0; i<64; i++){
           k=i*(timesize*3);
           ij= i*256;
           if(read_array_s[k] != (0x4000+i))
            printf(" first word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x4000+i));
           for (ik=0; ik< ((3*timesize)-2); ik++) {
            if(read_array_s[k+1+ik] != send_array[ij+ik])
             printf(" data word error, event %d ch = %d, received %x, expected %x\n",is,i,read_array_s[k+1+ik], send_array[ij+ik]);
           }
           k=(i+1)*(timesize*3)-1;
           if(read_array_s[k] != (0x5000+i))
            printf(" last word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x5000+i));
          }
         }
         else {
          printf(" event %d number word receive = %d, expected=  %d \n", is, (2*nword), (64*timesize*3));
         }
        }
        if(icheck ==1) {
          k = is%1000;
          if(k ==0) printf("event %d\n",is);
        }
        if(iprint == 1) scanf("%d",&ik);
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }





     }

     break;

    case 19:
     printf(" feb boot test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" frame length \n");
     scanf("%d",&iframe_length);
     ik=iframe_length%64;
     if(ik != 0) printf(" frame_length problem \n");

     printf(" drift time (< %d) \n", iframe_length/8);
     scanf("%d",&idrift_time);
     printf(" enter triger delay \n");
     scanf("%d",&itrig_delay);
     printf("number of triggers per loop \n");
     scanf("%d",&itrig);
//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck=0;
     irand=0;
     if(icheck != 1) {
      printf(" 1 for print event\n");
      scanf("%d",&iprint);
     }
     else iprint =0;
     printf(" number event \n");
     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);
//       itrig_delay = 51;
       nword =1;
//
// set to use test generator 2, set test =2
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
       imod=0;
       ichip=1;
//       iframe= 255;    //1023
       iframe = iframe_length-1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    start loading the test 2 data memory
//
       imod =11;
       ichip=3;
       for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); //enable test mode
        i = pcie_send(hDev, 1, 1, px);
        ibase = 32*is;
        il = is%8;
        if(il == 0) printf(" loading channel %d\n",is);
        for (ik=0; ik< 256; ik++) {                 // loop over all possible address
         if(irand ==1) ijk = rand() & 0xfff ;        // use random number
         else ijk= (ibase+ik*8) & 0xfff;
         k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); //enable test mode
         i = pcie_send(hDev, 1, 1, px);
         send_array[is*256+ik]=ijk;           //load up data map
        }
       }

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       timesize =4;
       timesize = idrift_time;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0x20;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); //wait for 5 ms
       scanf("%d",&ik);


       for (is=0; is<nevent; is++) {


//
//     send out multiple triggers
//
        for (ijtrig=0; ijtrig<itrig; ijtrig++) {
         printf(" itrig %d, itrig_delay %d\n", ijtrig,itrig_delay);
         imod=0;
         ichip=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         usleep(10000);  //put some space between triggers
//
// load trig 1 position relative to the frame..
//
         itrig_delay = itrig_delay+2;
         imod=0;
         ichip=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         scanf("%d",&ik);

         usleep(10000);

        }



//      set module number again to enable the FEB module read back

        imod=11;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        usleep(5000); // wait for 5 ms

        for (ijtrig=0; ijtrig<itrig; ijtrig++) {
         nword = 5;
         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

         if(iprint ==1) printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
         if(iprint == 1) {
          printf(" header word %x \n",(read_array[0] & 0xffff));
          k=(read_array[0]>>16) & 0xfff;
          printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
          printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
          printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
          printf(" frame number %d\n", (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12)));
          printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
         }
         nread = ((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12);
         if(iprint ==1 )scanf("%d",&ik);
         nword = (nread+1)/2;                    // short words
         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=mb_feb_pass_add;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

         if(iprint == 1) {
          for (i=0; i< nword; i++) {
           if((i%8) ==0) printf("%4d",i);
           printf(" %8x",read_array[i]);
           if(((i+1)%8) ==0 ) printf("\n");
          }
         }

         ik=0;
         for (i=0; i< nword; i++) {
          read_array_s[ik] = read_array[i] &0xffff;
          read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
          ik=ik+2;
         }

//
//      printout formatted word
//
         if(iprint ==1) {
          iset = 0;
          for(i=0; i< 2*nword; i++) {
           if((read_array_s[i] & 0xf000) == 0x4000) {
            iset=1;
            ncount=0;
            printf(" channel %d\n",(read_array_s[i] & 0xfff));
           }
           else if ((read_array_s[i] & 0xf000) == 0x5000) printf(" channel end %d\n",(read_array_s[i] &0xfff));
           else if (iset ==1) {
            printf(" %4x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
           }
           else {
            printf("%x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
           }
          }
         }

         if(icheck ==1 ){
          if((2*nword) == (64*timesize*3)){
           for (i=0; i<64; i++){
            k=i*(timesize*3);
            ij= i*256;
            if(read_array_s[k] != (0x4000+i))
             printf(" first word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x4000+i));
            for (ik=0; ik< ((3*timesize)-2); ik++) {
             if(read_array_s[k+1+ik] != send_array[ij+ik])
              printf(" data word error, event %d ch = %d, received %x, expected %x\n",is,i,read_array_s[k+1+ik], send_array[ij+ik]);
            }
            k=(i+1)*(timesize*3)-1;
            if(read_array_s[k] != (0x5000+i))
             printf(" last word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x5000+i));
           }
          }
          else {
           printf(" event %d number word receive = %d, expected=  %d \n", is, (2*nword), (64*timesize*3));
          }
         }
        }
        if(icheck ==1) {
          k = is%1000;
          if(k ==0) printf("event %d\n",is);
        }
        if(iprint == 1) scanf("%d",&ik);
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }





     }

     break;

    case 20:
     printf(" BNL ADC testing \n");
//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     nloop = 1;
     printf(" number event \n");
     scanf("%d",&nevent);
     printf(" type 1 to use trigger board\n");
     scanf("%d",&itrig_c);
     printf(" type 1 to write dat to file \n");
     scanf("%d",&iwrite);
//    iwrite =0;
     if(iwrite == 1) {
       iprint = 0;
       outf = fopen("/home/ub/test.dat","w");
     }
     else {
       printf(" type 1 for scope loop \n");
       scanf("%d",&is);
       if(is == 0) iprint=1;
       else iprint=0;
     }
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test   --- from the controoller
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//
//
     imod_trig=4;
     if(itrig_c == 1) {
//disable the run command   --- from the trigger board
       imod=imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_run)+((0x0)<<16); //set up run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
     else {
//disable the run command   --- from the controller
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
     }
 //
 //     set the trigger board deadtime size
 //
     imod_trig=4;
     if(itrig_c == 1) {
 // set offline test off   --- from the controoller
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_off)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
 //
 //
 //
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_deadtime_size)+((0x1)<<16); //set trigger deadtime size
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
 //     printf(" enter 1 to reset the dram \n");
 //     scanf("%d",&ik);
      ik =1;
      if(ik ==1) {
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000);    // wait for 5 ms for DRAM to be initialized

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


      }
      ik=1;
      nword =1;
      if(ik ==1) {


       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iprint == 1) printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
      }

//**

//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
       for (is=0; is<8; is++) {
        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }

//       printf(" enter 1 to continue FPGA ADC receiver reset\n");
//       scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_reset+(0x1<<16);  // FPGA ADC receiver reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//       printf(" enter 1 to continue FPGA ADC receiver align\n");
//       scanf("%d",&ik);
//
//    send FPGA ADC align
//
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_align+(0x0<<16);  // FPGA ADC receiver reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(1000);

//       printf(" finish align \n");
//       scanf("%d",&ik);
//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
       for (is=0; is<8; is++) {
        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0x9)<<24)+((0x0)<<16);
        buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }




//**


//      printf(" enter 1 to continue \n");
//      scanf("%d",&ik);

      itrig_delay = 51;
      nword =1;
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
      if(itrig_c == 1) {
       imod=imod_trig;
       iframe= 1023;    //1023
       buf_send[0]=(imod<<11)+(mb_trig_frame_size)+((iframe & 0xffff)<<16); //set up frame size.
//       printf("buf_send =%x\n",buf_send[0]);
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
      else {
       imod=0;
       ichip=1;
       iframe= 1023;    //1023
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }

//
// set to not use any test generator
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x0<<16);  // set test source to 0
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
// load trig 1 position relative to the frame..
//
      if(itrig_c != 1) {
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }

      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      timesize =40;
      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      a_id =0x20;
      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      imod=11;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      if(itrig_c == 1) {
       imod=imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_run)+((0x1)<<16); //set up run
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
      else {
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }

//      printf(" enter 1 to continue (run on sync on \n");
//      scanf("%d",&ik);
      usleep(5000); //wait for 5 ms
      printf(" enter event trigger loop \n");


      for (is=0; is<nevent; is++) {


       if(itrig_c == 1) {
        imod =imod_trig;  /* trigger module */
        buf_send[0]=(imod<<11)+mb_trig_pctrig+((0x0)<<16);
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }
       else {
        imod=0;
        ichip=1;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }



//      set module number again to enable the FEB module read back

       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); // wait for 5 ms


       nword = 5;
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       
       if(iwrite ==1) fprintf(outf," %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);        if(iprint ==1) printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
       if(iprint == 1) {
         printf(" header word %x \n",(read_array[0] & 0xffff));
         k=(read_array[0]>>16) & 0xfff;
         printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
         printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
         printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
         printf(" frame number %d\n", (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12)));
         printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
       }
       nread = ((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12);
//        if(iprint ==1) printf(" number of data word to read = %d\n",nread);

//        ik =  read_array[0] & 0x1f;
//        if(iprint ==1) printf(" module number = %d",ik);
//        ik =  (read_array[0] >> 5) & 0x7f;
//        if(iprint ==1) printf(" data ID = %d",ik);
//        ik =  (((read_array[2] >>16) & 0xfff)<<12) + (read_array[2] & 0xfff);
//        if(iprint ==1) printf(" event number = %d",ik);
//        ik =  (((read_array[3] >>16) & 0xfff)<<12) + (read_array[3] & 0xfff);
//        if(iprint ==1) printf(" frame number = %d\n",ik);
//        ik =  (((read_array[4] >>16) & 0xfff)<<12) + (read_array[4] & 0xfff);
//        if(iprint ==1) printf(" checksum = %x\n",ik);

       if(iprint ==1 ) {
        printf(" enter 1 to continue \n");
        scanf("%d",&ik);
       }
       nword = (nread+1)/2;                    // short words
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

       if(iprint == 1) {
        for (i=0; i< nword; i++) {
         if((i%8) ==0) printf("%4d",i);
         printf(" %8x",read_array[i]);
         if(((i+1)%8) ==0 ) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf," %d\n",nword);
        for (i=0; i< nword; i++) {
         if((i%8) ==0) fprintf(outf,"%4d",i);
         fprintf(outf," %8x",read_array[i]);
         if(((i+1)%8) ==0 ) fprintf(outf,"\n");
        }
        if(((i+1)*8) != 0)fprintf(outf,"\n");
       }

       ik=0;
       for (i=0; i< nword; i++) {
        read_array_s[ik] = read_array[i] &0xffff;
        read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
        ik=ik+2;
       }

//
//      printout formatted word
//
       if(iprint ==1) {
        iset = 0;
        for(i=0; i< 2*nword; i++) {
         if((read_array_s[i] & 0xf000) == 0x4000) {
           iset=1;
           ncount=0;
           printf(" channel %d\n",(read_array_s[i] & 0xfff));
         }
         else if ((read_array_s[i] & 0xf000) == 0x5000) printf(" channel end %d\n",(read_array_s[i] &0xfff));
         else if (iset ==1) {
           printf(" %4x",read_array_s[i]);
           ncount = ncount+1;
           if((ncount%8) == 0) printf("\n");
         }
         else {
           printf("%x",read_array_s[i]);
           ncount = ncount+1;
           if((ncount%8) == 0) printf("\n");
         }
        }
       }
       if((iwrite == 1)&&((is%100) ==0)) printf("nevent = %d\n",is);
      }
      if(iprint == 1) {
       printf(" enter 1 to continue \n");
       scanf("%d",&ik);
      }
      if((iwrite == 1)&&((is%100) ==0)) printf("nevent = %d\n",is);

     }





    break;


    case 21:
     printf(" SuperNova readout test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" enter 1 to turn on huffman encoding \n");
     scanf("%d",&ihuff);
     printf("tyep 1 to compare with the 1st event\n");
     scanf("%d",&comp_s);

//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck =0;
     ifr=0;
     irand = 0;
     islow_read =0;
//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//    }
//     else iprint =0;
     iprint = 1;
//     printf(" number event \n");
//     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;
     imod_xmit=10;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //trun off run
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for (j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms

//
//    boot up xmit module 1st
//
      printf(" boot xmit module \n");
      inpf = fopen("/home/ub/xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
      printf(" xmit done, booting FEM \n");
      scanf("%d",&ik);

//
//    Boot stratix after XMIT module
//
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
//    start testing routine
//
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);
       itrig_delay = 51;
       nword =1;
//
// set to use test generator 2, set test =2
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 255 --- there will be 256/8 = 32 adc samples.
//
       imod=0;
       ichip=1;
       iframe= 255;    //1023
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    start loading the test 2 data memory
//
       imod =11;
       ichip=3;
       for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); //enable test mode
        i = pcie_send(hDev, 1, 1, px);
        ibase = 32*is;
        il = is%8;
        if(il == 0) printf(" loading channel %d\n",is);
        for (ik=0; ik< 256; ik++) {                 // loop over all possible address
         if(irand ==1) ijk = rand() & 0xfff ;        // use random number
         else ijk= (ibase+ik*8) & 0xfff;
//         if(ihuff == 1) {
           if((ik%4) ==0) ic =ijk;        // set data to repeat for 4 samples....
           ijk=ic;
//         }
         k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); //enable test mode
         i = pcie_send(hDev, 1, 1, px);
         send_array[is*256+ik]=ijk;           //load up data map
        }
       }

       imod=11;
       ichip=3;
       if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16);  // turn the compression
       else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x1<<16);  // set b channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       timesize =4;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0xf;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     set max word in the pre-buffer memory
//
       ik=8000;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_max+(ik<<16);  // set pre-buffer max word
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       imod=11;
//       ichip=3;
//       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
//       i=1;
//       k=1;
//       if(islow_read == 1) i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//     set up xmit module  -- module count
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+(0x0<<16);  // set number of module to 1 to enable output
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     rest optical
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     enable superNova Token Passing
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x1<<16);  // enable token 1 pass
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
       printf(" enter 1 to reset the DPA \n");
       scanf("%d",&ik);

//
//     reset XMIT LINK IN DPA
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     wait for 10ms just in case
//
       usleep(10000);
       printf(" XMIT FIFO reset \n");
//
//     reset XMIT FIFO reset
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//
//

       for (is=0; is<1; is++) {
//
//      test re-align circuit
//
        imod=imod_xmit;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_word_align+(0x1<<16);  //  send alignment pulse
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

//        printf(" enter 1 to set continue on re-align circuit \n");
//        scanf("%d",&ik);
       }

       usleep(5000); //wait for 5 ms
       printf(" XMIT re-align done \n");

       dwDMABufSize = 200000;
       if(ifr ==0) {
        ifr=1;
        printf(" buffer allocation \n");
        dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
        if (WD_STATUS_SUCCESS != dwStatus) {
         printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
         printf("enter 1 to continue \n");
         scanf("%d",&is);
        }
       }

/* set tx mode register */

       u32Data = 0xf0000fff;
       dwOffset = tx_md_reg;
       dwAddrSpace =cs_bar;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       buffp_rec32 = pbuf_rec;

/* synch cache */
       WDC_DMASyncCpu(pDma_rec);
       printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
       nwrite =(dwDMABufSize/8);  //remove factor 2 
//       nwrite = 4000;

       for (is=1; is<3; is++) {
        tr_bar = t1_tr_bar;
        r_cs_reg = r1_cs_reg;
        dma_tr = dma_tr1;
        if(is == 2) {
         tr_bar = t2_tr_bar;
         r_cs_reg = r2_cs_reg;
         dma_tr = dma_tr2;
        }
        printf(" is = %d\n",is);
/** initialize the receiver ***/
        u32Data = cs_init;
        dwOffset = r_cs_reg;
        dwAddrSpace =cs_bar;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
        dwAddrSpace = cs_bar;
        u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
        dwOffset = r_cs_reg;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
       printf(" initial receiver \n");
       scanf("%d",&ik);
/** set up DMA for both transceiver together **/

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
       u32Data = dma_tr12+dma_4dw_rec;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       printf(" DMA set up done \n");

//
//      turn the run on to start data flow
//
       printf(" enter 1 to set the RUN on \n");
       scanf("%d",&ik);

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

/***    check to see if DMA is done or not **/
       idone =0;
       for (is=0; is<2000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
       }
	/* synch DMA i/O cache **/

       WDC_DMASyncIo(pDma_rec);
//
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t1_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t2_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));

//
       for (is=0; is<nwrite*2; is++) {
         read_array[is]= *buffp_rec32++;
       }

       for (is=0; is< nwrite*2; is++) {
        if((is%8) ==0) printf("%4d",is);
        printf(" %8x",read_array[is]);
        if(((is+1)%8) ==0 ) printf("\n");
       }
       if(((is+1)*8) != 0)printf("\n");

       for(is=0; is< nwrite; is++) {
         read_array_s[is*2] = (read_array[is] & 0xffff);
         read_array_s[is*2+1] = ((read_array[is] >>16) & 0xffff);
       }
       nread = ((read_array_s[4] & 0xfff) << 12)+ (read_array_s[5] & 0xfff);
       nread =nread+1;
       nread = nread/2;
       for (is=0; is< nread+7; is++) {       // 6 header + 1 trailer.
        read_comp[is] = read_array[is];
       }

       icomp_l = nwrite/nread; // only compare complete event
       printf(" compare %d of event in the loop \n",icomp_l);
       if(comp_s == 1) {
        for(is=0; is<icomp_l; is++) {
         for (ik=6; ik< nread+6; ik++) {   //for the moment skip header
          k=ik+is*(nread+7);
          if(read_comp[ik] != read_array[k]) {
            printf(" data error %d %d, first event data word = %8x, data = %8x \n", ik,k,read_comp[ik], read_array[k]);
            scanf("%d",&k);
          }
         }
        }
       }

       is=0;
       while (is < nwrite*2) {
         if(((nwrite*2)-is) <= 12) printf(" not enough word header \n");
         if(((nwrite*2)-is) <= 12) break;
         if((read_array_s[is] == 0xffff) && (read_array_s[is+1] == 0xffff)) {
          printf(" event header %8x \n", read_array_s[is]+(read_array_s[is+1] << 16));
          is=is+2;
          printf(" module header = %4x\n", read_array_s[is]);
          is=is+1;
          printf(" address word = %4x, aid = %2x, module numebr %3d\n", read_array_s[is], ((read_array_s[is]>>5) &0x7f), (read_array_s[is] &0x1f));
          is=is+1;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          nread=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          nread = nread+1;
          printf(" word count word = %8x, word count = %8d \n", ik,nread);
          is = is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" event number word = %8x, event number = %8d \n", ik,k);
          is = is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" frame number word = %8x, frame number = %8d \n", ik,k);
          is =is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" checksum word = %8x, checksum = %8x \n", ik,k);
          is=is+2;
         if(((nwrite*2)-is) <= (nread+2)) printf(" not enough word for the event \n");
         if(((nwrite*2)-is) <= (nread+2)) break;
          is=is+nread;
          printf("end of packet word, %8x \n", read_array_s[is]+ (read_array_s[is+1]<<16));
          is = is+2;
          scanf("%d", &ik);
         }
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }

     break;


    case 22:
     printf(" PMT fake data testing \n");
     printf(" type 1 to use the new code \n");
     scanf("%d",&inewcode);
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" number event \n");
     scanf("%d",&nevent);
     printf(" type 1 to use trigger module for pulser\n");
     scanf("%d", &itrig_ext);
     if(itrig_ext == 1) {
      printf(" type 1 to use trigger module as pulse, 2 for fixed frame trigger \n");
      scanf("%d", &itrig_pulse);
      if (itrig_pulse == 1) {
       printf(" enter pulse 1 delay \n");
       scanf("%d", &p1_delay);
       printf(" enter pulse 1 width \n");
       scanf("%d", &p1_width);
       printf(" enter pulse 2 delay \n");
       scanf("%d", &p2_delay);
       printf(" enter pulse 2 width \n");
       scanf("%d", &p2_width);
       printf(" enter trigger delay (<7)\n");
       scanf("%d", &pulse_trig_delay);
      }
     }
     printf(" type 1 to set up PMT ADC \n");
     scanf("%d", &use_pmt);
     if(use_pmt == 1) {
      printf(" type 1 to fire test pulse  \n");
      scanf("%d", &pmt_testpulse);
      if(pmt_testpulse == 1) {
       printf(" type 1 to step through DAC \n");
       scanf("%d", &pmt_dac_scan);
       if(pmt_dac_scan != 1) {
        printf(" enter DAC value \n");
        scanf("%d",&idac_shaper);
       }
      }
      else idac_shaper = 256;
     }

     icheck = 0;
     irand =0;
     iprint=1;
     imod_trig = 18;
     imod_shaper =4;
     itrig_delay = 51;
     imod_fem = 10;
     iframe= 2047; //8191;    //1023
//     pmt_deadtime = 20;
//     pmt_deadtime =  ///set deadtime long so it will not double fired on trailling edge
     pmt_mich_window = 2;
     printf(" PMT ADC module address = %d \n", imod_fem);
     printf(" Shaper address = %d \n", imod_shaper);
     printf(" Trigger module address = %d \n", imod_trig);
//
//
     threshold0 = 100;   // 100 discriminator threshold 0
     threshold1 = 150;   // 150 discriminator threshold 1
     cos_mult = 1;       // cosmic ray multiplicity threshold
     cos_thres = 20;    // cosmic ray sum ph threshold
     pmt_precount=1;   // set PMT precount
     pmt_words=40;     // number of word to read
     pmt_deadtime = 10;
//     pmt_deadtime =  ///set deadtime long so it will not double fired on trailling edge
     pmt_mich_window = 2;
//
//
     printf(" type 1 for write the event \n");
     scanf("%d", &iwrite);
     if(iwrite == 1) {
       iprint = 0;
       outf = fopen("/home/ub/test_pmt.dat","w");
     }


//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//     }
//     else iprint =0;
//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

//
//
//
    if(itrig_ext == 1) {
 //
 //  set trigger module run off
 //
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_run)+((0x0)<<16); //set up run off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
 //
 //  set trigger module dead time size
 //
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_deadtime_size)+(0x1<<16); //set trigger module deadtime size
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
 // set offline test
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_off)+(0x0<<16); //set controller test off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

     }
     else {
//
//disable the run command
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
// load trig 1 position relative to the frame..
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }

 // turn on the Stratix III power supply
     imod=imod_fem;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( iv=0; iv<nloop; iv++) {
      usleep(10000); // wait for 10ms
//      if(inewcode ==1 ) inpf = fopen("/home/ub/feb_pmt_fpga_test_new","r");
      if(inewcode ==1 ) inpf = fopen("/home/ub/feb_pmt_fpga_test_new_link","r");
      else if(inewcode ==2) inpf = fopen("/home/ub/feb_pmt_fpga_test_new_head_allch","r");
      else inpf = fopen("/home/ub/feb_pmt_fpga_test_1","r");
      imod=imod_fem;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

       for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
       }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
//
//
      printf(" enter 1 to reset the dram \n");
      scanf("%d",&ik);
 //      ik =1;
      if(ik ==1) {
        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        usleep(5000);    // wait for 5 ms for DRAM to be initialized
        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);


      }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);

      ik=1;
      nword =1;
      if(ik ==1) {


        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
      }
//
//     set PMT inhibit size to 625
//
//      imod=imod_fem;
//      ichip=3;
//      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_inhib_size+(625<<16);  // set module number
//      i=1;
//      k=1;
//      i = pcie_send(hDev, i, k, px);
//
      
      for (is =0; is< 48; is++) {

       imod=imod_fem;
       ichip=3;

       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_ch_set+(is<<16);  // set channel number to be download
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(100);

//     set PMT delay 0 to 4
//
       imod=imod_fem;
       ichip=3;
       idelay0=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_delay0+(idelay0<<16);  // set delay0
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     set PMT delay1 to 12
//
       imod=imod_fem;
       ichip=3;
       idelay1=12;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_delay1+(idelay1<<16);  // set delay 1
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//     set PMT precount
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_precount+(pmt_precount<<16);  // set pmt precount
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
//      for (is =0; is< 40; is++) {
//
//     set PMT threshold 0 to 10
//
       imod=imod_fem;
       ichip=3;
//      threshold0=100;
       if(is <= 39) {
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh0+((threshold0+is)<<16);  // set threshold 0
       }
       else {
//         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh0+((1000)<<16);  // set beam threshold to 1000
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh0+((threshold0+is)<<16);  // set threshold 0
       }
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     set PMT threshold 1 to 20
//
       imod=imod_fem;
       ichip=3;
//      threshold1=150;
       if(is <= 39) {
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh1+((threshold1+is)<<16);  // set threshold 1
       }
       else {
//        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh1+((1000)<<16);  // set threshold 1
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh1+((threshold1+is)<<16);  // set threshold 1
       }
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//     set PMT data words to 40
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_words+(pmt_words<<16);  // set pmt_words
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//     set PMT deadtime
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_deadtime+(pmt_deadtime<<16);  // set pmt_words
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     set PMT Michael window
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_window+(pmt_mich_window<<16);  // set pmt_words
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
//
//     set PMT beam input beam delay
//
      imod=imod_fem;
      ichip=3;
//      cos_mult=2;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_trig_delay+(7<<16);  // set beam delay
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_trig1_delay+(7<<16);  // set beam delay
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);


//
//     set PMT cosmic ray trigger multiplicity to 2
//
      imod=imod_fem;
      ichip=3;
//      cos_mult=2;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_cos_mul+(cos_mult<<16);  // set cosmic ray trigger mul
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     set PMT cosmic ray trigger pulse height
//
      imod=imod_fem;
      ichip=3;
//      cos_thres=20;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_cos_thres+(cos_thres<<16);  // set cosmic ray trigger peak
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     disable the top chanell
//
      imod=imod_fem;
      ichip=3;
      en_top=0xff;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_top+(en_top<<16);  // enable/disable channel
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     disable the upper chanell
//
      imod=imod_fem;
      ichip=3;
      en_upper=0xffff;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_upper+(en_upper<<16);  // enable/disable channel
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     enable all lower channel
//
      imod=imod_fem;
      ichip=3;
      en_lower=0xffff;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_lower+(en_lower<<16);  // enable/disable channel
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     set maximum block size
//
      imod=imod_fem;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_blocksize+(0xffff<<16);  // set max block size
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      if(inewcode != 0) {
//
//    set beam data recording gate size
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_gate_size+(0x50<<16);  // set gate size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    set beam delay
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam_delay+(0x30<<16);  // set gate size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    set beam size window
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam_size+(0x40<<16);  // set beam size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    set trigger input delay
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_trig_delay+(0x7<<16);  // set beam size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
//
//    set beam data recording gate size
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_gate1_size+(0x50<<16);  // set gate size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    set beam delay
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam1_delay+(0x30<<16);  // set gate size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    set beam size window
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam1_size+(0x40<<16);  // set beam size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    set trigger input delay
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_trig1_delay+(0x20<<16);  // set beam size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

      }

     if(itrig_ext == 1) {
      imod=imod_trig;
//      iframe= 511;    //1023
      buf_send[0]=(imod<<11)+(mb_trig_frame_size)+((iframe & 0xffff)<<16); //set up frame size.
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }
     else {
//
// set frame set to be 1023 --- there will be 1023/8 = 128 adc samples.
//
      imod=0;
      ichip=1;
//      iframe= 511;    //1023
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); // set frame length
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }
//
//
//
     if(itrig_ext == 1) {
//
//    set mask1 bit 3 high
//
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_mask1)+(0x8<<16); //set mask1[3] on.
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//    set prescale1 to 0
//
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_prescale1)+(0x0<<16); //set prescale1 0
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }

//
//     set a channel no compression
//
      imod=imod_fem;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
 //
 //     set a_test on  -- slow readback
 //
      imod=imod_fem;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable slow readback
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     set a_id
//
      a_id =0x20;
      imod=imod_fem;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      if(use_pmt == 1) {
//
//     work on the ADC -- set reset pulse
//
       imod=imod_fem;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=imod_fem;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x1<<16); // reset goes low
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=imod_fem;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//      enable ADC clock,
//
       imod=imod_fem;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x7<<16); //set spi address
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       imod=imod_fem;
       ichip=5;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0xffff<<16); //load spi data, clock gate enable
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//        load ADC sync data pattern  + set MSB 1st
//
       for (is=1; is<7; is++) {
        imod=imod_fem;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        imod=imod_fem;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0b00<<16); //sync pattern, b for sync, 7 for skew, 3 for normal
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        imod=imod_fem;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x1400<<16); //msb 1st
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }
       printf(" enter 1 to continue FPGA ADC receiver reset\n");
       scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_rxreset+(0x1<<16);  // FPGA ADC receiver reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//      readback status
//
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       printf("receive data word -- after reset = %x, %x \n", read_array[0], read_array[1]);
       printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
       printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
       printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
       printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
       printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
       printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
       printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
       printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
       printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
       printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
       printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
       printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
       printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
       printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
       printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
       printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
//
//
//
       printf(" enter 1 to continue FPGA ADC receiver align\n");
       scanf("%d",&ik);
//
//    send FPGA ADC align
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_align_pulse+(0x0<<16);  // FPGA ADC receiver reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); // wait for 5ms

//
//      readback status
//
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       printf("receive data word -- after align = %x, %x \n", read_array[0], read_array[1]);
       printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
       printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
       printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
       printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
       printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
       printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
       printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
       printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
       printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
       printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
       printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
       printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
       printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
       printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
       printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
       printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
       printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
//
//
//
//
       printf(" enter 1 to continue after ADC alignment \n");
       scanf("%d",&ik);
//
//
//
       for (is=1; is<7; is++) {
        imod=imod_fem;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        imod=imod_fem;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //sync pattern, b for sync, 7 for skew, 3 for normal
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }
      }

      if(use_pmt ==1) {
       if(pmt_testpulse == 1) {
//
//     set dac value and write
//
        imod =imod_shaper;  /* set shaper module DAC value */
        buf_send[0]=(imod<<11)+mb_shaper_dac+((0xfff & idac_shaper)<<16);
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(10);
        imod =imod_shaper;  /* write to the DAC */
        buf_send[0]=(imod<<11)+mb_shaper_write+((0xfff)<<16);
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(1000);
 //
 //     set up pulse time
 //
        imod =imod_shaper;  /* write pulse time */
        idiv =1;
        isample =1;
        buf_send[0]=(imod<<11)+mb_shaper_pulsetime+(((idiv&0x7)+((isample&0xfff)<<3))<<16);  // all bits on
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(1000);
//
//      set firing patterm
//

        imod =imod_shaper;  /* write to test pattern register */
        buf_send[0]=(imod<<11)+mb_shaper_pattern+((0xf)<<16);  // all bits on
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(1000);
       }
//
//     set up enable trigger or not
//
       if(pmt_testpulse == 1) {
        imod =imod_shaper;
        if(itrig_ext == 1) is = 0;
        else is = 1;
        buf_send[0]=(imod<<11)+mb_shaper_entrig+((is)<<16);  // all bits on
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(1000);
       }

      }
//
//     enable PMT test mode, only when we are not using trigger module as pulser
//
      else if (itrig_pulse < 1) {
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_test+(0x1<<16);  // set PMT test data on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
      }
//
//
//
//      iwrite = 0;
      for (ib=0; ib<nevent; ib++) {
//
//
//
       if(use_pmt ==1) {
        if((pmt_testpulse == 1) & (pmt_dac_scan ==1)) {
         if(idac_shaper == 4096) idac_shaper = 256;
         else idac_shaper = idac_shaper+256;
//
//     set dac value and write
//
         imod =imod_shaper;  /* set shaper module DAC value */
         buf_send[0]=(imod<<11)+mb_shaper_dac+((0xfff & (idac_shaper-1))<<16);
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         usleep(10);
         imod =imod_shaper;  /* write to the DAC */
         buf_send[0]=(imod<<11)+mb_shaper_write+((0xfff)<<16);
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         usleep(1000);
        }
       }

//
//     set up test pulse
//
       if((use_pmt != 1) & (itrig_pulse < 1)) {
//
//     clear PMT test FIFO
//
        printf(" enter 1 to continue on sending clear\n");
        scanf("%d",&ik);
        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_clear+(0x1<<16);  // clear PMT test data FIFO
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
//
//     load PMT test data
//
        imod=imod_fem;
        ichip=3;
        irise=100;
        ifall=1;
        ibase =0;
        istart_time = 50;
        for (i=0; i< 256; i++) {
//        printf(" enter 1 to continue, loop %d, t_upper \n", i);
//        scanf("%d",&ik);
         is = ((istart_time<<12) & 0xfff) + 0x8000;
         ijk=1;
         k=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_test_data+(is<<16);  // load PMT test data
         ijk = pcie_send(hDev, ijk, k, px);
//        printf(" enter 1 to continue, loop %d, t_lower \n", i);
//        scanf("%d",&ik);
         is = (istart_time & 0xfff) + 0x8000;
         ijk=1;
         k=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_test_data+(is<<16);  // load PMT test data
         istart_time = istart_time+1;
         ijk = pcie_send(hDev, ijk, k, px);
//        printf(" istart_time %d, loop %d\n", istart_time, i);
         for (j=0; j<32; j++) {   // load data reverse order
          if(i <= 10) is= ibase+(31-j);
          else if((i > 10) && (i <= 16)) is= irise*(i-10)+ibase+(31-j);
          else is= (irise*6+ibase+(31-j))-(i-16)*ifall;
          if(is <= 0) is =0;
          if(is >= 4095) is = 4095;
          if(j != 31) il = (is & 0xfff)+ 0x8000;
          else il =(is & 0xfff)+ 0xc000;
//          printf("is = %x, loop %d, chnl %d \n", is, i,j);
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_test_data+(il<<16);  // load PMT test data
          ijk=1;
          k=1;
          ijk = pcie_send(hDev, ijk, k, px);
         }
//        scanf("%d",&ik);
        }
//
//     set PMT test data pulse
//
        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_pulse+(0x1<<16);  // send pulse for PMT test data
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }
//
//     set up PMT
//

//
       imod = imod_trig;
       buf_send[0]=(imod<<11)+(mb_trig_output_select)+((0x2)<<16); // trigger out
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       if(itrig_ext ==1) {
//
//     only need to restart the run if the we use the test data or 1st run
//
        if((ib == 0)|| (use_pmt != 1)) {
         imod=imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_run)+((0x1)<<16); //set up run
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
        }
        if(itrig_pulse == 1) {
//
//
         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_output_select)+((0x1)<<16); // select test pulse output
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
//
         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_p1_delay)+((p1_delay)<<16); // set up p1 delay;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_p1_width)+((p1_width)<<16); // set up p1 width;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_p2_delay)+((p2_delay)<<16); // set up p1 delay;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_p2_width)+((p2_width)<<16); // set up p1 width;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_pulse_delay)+((pulse_trig_delay)<<16); // set up triger delay;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);



         usleep(10);

         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_pulse1)+((0x1)<<16); // fire pulse 1;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
//
//
         usleep(1000);
        }
        else if( itrig_pulse == 2) {
         usleep(10);

         imod = imod_trig;
         buf_send[0]=(imod<<11)+(mb_trig_frame_trig)+((0x1)<<16); // fire pulse 1;
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
        }

       }
       else {
//
//      if not use trigger module, controller provide trigger and fire test pulse
//
        if(ib == 0) {
         imod=0;
         ichip=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         usleep(5000);
        }

        imod=0;
        ichip=1;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

       }
//
//     figure out the test pulse firing and trigger setup
//
       if(pmt_testpulse == 1) {
//        if(itrig_ext == 1) {
//**         printf(" enter 1 to continue on sending test pulse\n");
//**         scanf("%d",&ik);
         imod =imod_shaper;  /* arm test pulse firing*/
         buf_send[0]=(imod<<11)+mb_shaper_pulse+((0xf)<<16);  // all bits on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
//        }
       }
       usleep(1000);
//
//
//
       if(iprint == 1) {
        printf(" ready to receive trigger \n");
        scanf("%d",&ik);
       }

       for (ijk=0; ijk<100000000; ijk++){
//
//      readback status
//
        nword = 1;
        i = pcie_rec(hDev,0,1,nword,0,py);     // init the receiver

        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,0,py);     // read out 2 32 bits words
//
//      readback status
//
        i = pcie_rec(hDev,0,1,nword,0,py);     // init the receiver

        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,0,py);     // read out 2 32 bits words
//
//
//
        if(iwrite !=1 ) {
         printf("receive data word -- after reset = %x, %x \n", read_array[0], read_array[1]);
         printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
         printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
         printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
         printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
         printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
         printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
         printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
         printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
         printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
         printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
         printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
         printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
         printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
         printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
         printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
         printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
        }

        if(((read_array[0] >> 31) &0x1) == 0) break;
        else {
          usleep(1000);
          printf(".");
        }
//        break;
       }

//
//

//      set module number again to enable the FEB module read back

       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(50000); //wait for 500 ms
//
//
       if(inewcode == 2) nword = 6;
       else nword = 5 ;

       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
//
//
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
//
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//
       if(inewcode == 2) {
        if(iwrite ==1) fprintf(outf," %x %x %x %x %x %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4],read_array[4]);
//
        if(iprint ==1)
         printf("receive data word = %x, %x, %x, %x, %x %x \n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4], read_array[5]);
        if(iprint == 1) {
         printf(" header word %x \n",(read_array[0] & 0xffff));
         k=(read_array[0]>>16) & 0xfff;
         printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
         printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
         printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
         k= (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12));
         printf(" frame number %d %x(hex)\n", k, k);
         printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
         printf(" trigger pointer %x\n", (((read_array[5]>>16) & 0xfff)+((read_array[5] &0xfff) <<12)));
         printf(" trigger pointer %x\n", (((read_array[5]>>16) & 0xff)+((read_array[5] &0xff) <<8)));
         k = ((read_array[5]>>16) & 0xff)+((read_array[5] & 0xff) <<8);
         printf(" trigger pointer frame, sample %x %x\n", ((k>>12) & 0xf), (k &0xfff));

        }
       }
       else {
        if(iwrite ==1) fprintf(outf," %x %x %x %x %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
//
        if(iprint ==1)
         printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
        if(iprint == 1) {
         printf(" header word %x \n",(read_array[0] & 0xffff));
         k=(read_array[0]>>16) & 0xfff;
         printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
         printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
         printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
         printf(" frame number %d\n", (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12)));
         printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
        }
       }

//       printf(" enter 1 to continue \n");
//       scanf("%d",&ik);

       nread = ((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12);
//       printf(" event %d, nread %d \n",ib,nread);
//
//
//
//**       if(iprint ==1 )scanf("%d",&ik);
       nword = (nread+1)/2;                    // short words
//       if(inewcode == 1) nword = nword+1;
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

       imod=imod_fem;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

       if(iprint == 1) {
        for (i=0; i< nword; i++) {
         if((i%8) ==0) printf("%4d",i);
         printf(" %8x",read_array[i]);
         if(((i+1)%8) ==0 ) printf("\n");
        }
        if((i%8) !=0 ) printf("\n");
       }
       if(iwrite == 1) {
        fprintf(outf," %d\n %d\n",nread, idac_shaper);
        for (i=0; i< nword; i++) {
         if((i%8) ==0) fprintf(outf,"%4d",i);
         fprintf(outf," %8x",read_array[i]);
         if(((i+1)%8) ==0 ) fprintf(outf,"\n");
        }
        if(((i+1)*8) != 0)fprintf(outf,"\n");
       }

//
//
//
//**       printf(" enter 1 to continue \n");
//**       scanf("%d",&ik);
//
       if(iprint == 1) {
        if(inewcode != 0) {
         ik=0;
         for (i=0; i< nword; i++) {
          read_array_s[ik] = read_array[i] &0xffff;
          read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
          ik=ik+2;
         }
         for (i=0; i< ik; i++) {
          if((i%8) == 0) printf("%4d",i);
          printf(" %4x",read_array_s[i]);
          if(((i+1)%8) ==0 ) printf("\n");
         }
         if(((i+1)*8) != 0)printf("\n");
         for (i=0; i< ik; i++) {
          if((read_array_s[i] & 0xc000) == 0x4000) {
           printf(" first word in the event %x\n", read_array_s[i]);
          }
          else if((read_array_s[i] & 0xc000) == 0xc000) {
           printf(" last word in the event %x\n", read_array_s[i]);
          }
          else if((read_array_s[i] & 0xc000) == 0x8000) {   // data word encoding
           ijk = read_array_s[i] & 0x3fff;         // grep data word
           if((ijk & 0x3000) == 0x1000) {
            printf(" header word, id= %d, channel = %d \n", (ijk & 0xe00)>> 9, (ijk & 0x3f));
            ijk= read_array_s[i+1] & 0x3fff;
            is = ((ijk & 0x1f) << 12) + (read_array_s[i+2] & 0xfff);
            printf(" frame = %d, sample = %d\n",(read_array_s[i+1] & 0xe0)>>5,is);
            i= i+2;
            k=0;
           }
           else if ((ijk & 0x2000) == 0x2000) {
            k=k+1;
            printf("  %4X", ijk & 0xfff);
            if((k%8) == 0 ) printf("\n");
            if ((ijk & 0x3000) == 0x3000) {
             if((k%8) != 0 ) printf("\n");
             printf( "last word -- channel \n");
            }
           }
           else if ((ijk & 0x2000) == 0x0000) {
            k=k+1;
            printf(" %4X*", ijk & 0xfff);
            if((k%8) == 0 ) printf("\n");
           }

           else printf(" wrong header lable, %4x\n",read_array_s[i]);
          }
         }
        }
        else {
         ik=0;
         ich_head=0;
         count =0;
         for (i=0; i< nword; i++) {
          read_array_s[ik] = read_array[i] &0xffff;
          read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
          ik=ik+2;
         }
         for (i=0; i<(nread+1); i++) {
          if((read_array_s[i] & 0xf000) == 0x5000) {
           printf(" first word in the event %x\n", read_array_s[i]);
          }
          else if((read_array_s[i] & 0xf000) == 0x9000) {
           printf(" header -- channel %d, id = %d \n",(read_array_s[i] & 0x1f), ((read_array_s[i] & 0xc00)>>10));
           ich_head =2;
          }
          else if(((read_array_s[i] & 0xf000) == 0xa000) && (ich_head !=0)) {
           if(ich_head == 2) {
             ich_sample = ((read_array_s[i] & 0x1f)<<12);    // temp hold the upper bits
             ich_frm = ((read_array_s[i] & 0xe0)>>5);
           }
           else {
             ich_sample = (read_array_s[i] & 0xfff) + ich_sample;
             printf(" 2 header words -- frame %x, sample %x \n", ich_frm, ich_sample);
           }
           ich_head = ich_head -1;
          }
          else if (((read_array_s[i] & 0xf000) == 0xa000) && (ich_head ==0)) {
           if(count == 0) printf(" adc sample \n");
           printf(" %d", read_array_s[i] & 0xfff);
           count = count+1;
           if(count%8 == 0) printf("\n");
          }
          else if ((read_array_s[i] & 0xf000) == 0xb000) {
           printf(" %d", read_array_s[i] & 0xfff);
           count =0;
           printf(" ---last channel word \n");
          }
          else if((read_array_s[i] & 0xc000) == 0xc000) {
           printf(" last word in the event %x\n", read_array_s[i]);
          }
          else printf(" wrong word type 1 %x \n", read_array_s[i]);
         }
        }
       }


//
//      readback status
//
       if(iprint == 1) {
        nword = 1;
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//
//      readback status
//
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//
//
//
        if(iwrite != 1) {
         printf("receive data word -- after reset = %x, %x \n", read_array[0], read_array[1]);
         printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
         printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
         printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
         printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
         printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
         printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
         printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
         printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
         printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
         printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
         printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
         printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
         printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
         printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
         printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
         printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
        }
       }

//
//
//


       if(iprint == 1) {
        printf(" enter 1 to continue \n");
        scanf("%d",&ik);
       }

//
//     only need to stop the run if we are not using PMT
//
       if((itrig_ext == 1) && (use_pmt != 1)) {
 //
 //  set trigger module run off
 //
        imod=imod_trig;
        buf_send[0]=(imod<<11)+(mb_trig_run)+((0x0)<<16); //set up run off
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
       }
//       else {
//
//disable the run command
//
//        imod=0;
//        ichip=1;
//        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
//        i=1;
//        k=1;
//        i = pcie_send(hDev, i, k, px);
//       }
      if((iwrite == 1)&&((ib%100) ==0)) printf("nevent = %d\n",ib);
//      if(((ib%100) ==0)) printf("nevent = %d\n",ib);
      }
     }

     break;


    case 23:
     printf(" XMIT boot test \n");
     printf(" number of boot lopp \n");
     scanf("%d", &nloop);
     printf(" number event \n");
     scanf("%d",&nevent);
     printf(" number of fake data word to send \n");
     scanf("%d",&nsend_f);

     imod_xmit=10;
     nsend=500;

// once the fpga is booted we should let system receive fill frame before send any data.
// set system with normal transmitter mode

     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, return the hold
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, return the hold
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x24;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


     dwAddrSpace =2;
     u32Data = 0xfff;    // set mode off with 0xfff...
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


     ifr =0;
     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      printf(" type 1 for continue \n");
      scanf("%d",&i);
//
//   /* set tx mode register */
//
     if(ibusy_test== 1)
      u32Data = 0x00000050;  // set up hold coming back from the XMIT module
     else
      u32Data = 0xfff;
     printf("u32Data = %x\n",u32Data);
     dwOffset = 0x28;
     dwAddrSpace =2;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
//
//   set up hold
//
     printf(" set up the hold condition \n");
     dwAddrSpace =2;
     u32Data = 0x8000000;    // initial transmitter, return the hold
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x8000000;    // initial transmitter, return the hold
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);



//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
      imod=0;
      ichip=1;
      iframe= 255;    //1023
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
// load trig 1 position relative to the frame..
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+(0x0<<16);  // set number of module to 1 to enable output
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);


      for (is=0; is<nevent; is++) {
       iprint=1;
       nword = 1;
       py = &read_array;
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_rdstatus+(0x0<<16);  // read a header
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
//
//
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_test2+(0x1<<16);  // enable test fiber 1
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
//
       dwDMABufSize = 200000;
       if(ifr ==0) {
        ifr=1;
        printf(" buffer allocation \n");
        dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
        if (WD_STATUS_SUCCESS != dwStatus) {
         printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
         printf("enter 1 to continue \n");
         scanf("%d",&is);
        }
       }
//
//
//     set up for busy test read 20 words first then reset of the words
//
//     buffer allocation
//           (8 bytes header + 8 bytes trailer) + nsend_f * 4 bytes)/(2 fibers * 2 bytes per allocation on DMA)
//     single word read is done through 64 bits data read per fiber
//     pcie_rec_6_x set up to receive (nword/4+1) * 64 bits read per fiber
//
//
//       nwrite = (nsend_f*4+8)/8;
       nwrite = 80;

/* set tx mode register */

       u32Data = 0x00000050;
       dwOffset = tx_md_reg;
       dwAddrSpace =cs_bar;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       buffp_rec32 = pbuf_rec;

       for (is=0; is<nwrite*2; is++) {
         *(buffp_rec32+is) =0;
       }


/* synch cache */
       WDC_DMASyncCpu(pDma_rec);
       printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
//       nwrite =(dwDMABufSize/8);  //remove factor 2
//       nwrite = 4000;

       for (is=1; is<3; is++) {
        tr_bar = t1_tr_bar;
        r_cs_reg = r1_cs_reg;
        dma_tr = dma_tr1;
        if(is == 2) {
         tr_bar = t2_tr_bar;
         r_cs_reg = r2_cs_reg;
         dma_tr = dma_tr2;
        }
        printf(" is = %d\n",is);
/** initialize the receiver ***/
        u32Data = cs_init;
        dwOffset = r_cs_reg;
        dwAddrSpace =cs_bar;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
        dwAddrSpace = cs_bar;
        u32Data = cs_start+(nwrite*8);   /* 32 bits mode == 4 bytes per word *2 fibers **/
//        u32Data = cs_start+ 20*8;             // readout 40 32 bytes words
        dwOffset = r_cs_reg;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
       printf(" initial receiver \n");
       scanf("%d",&ik);
/** set up DMA for both transceiver together **/

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
       u32Data = (nwrite)*8;      /** twice more data - from fiber 1& 2**/
//       u32Data = 20*8;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
       u32Data = dma_tr12+dma_4dw_rec;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       printf(" DMA set up done \n");

//
//     send fake data
//
       imod=imod_xmit;
       ichip=3;
       nsend=nsend_f;
       for (k=0; k<nsend; k++) {
         if(k==0) buf_send[k] = (imod<<11)+(ichip<<8)+mb_xmit_testdata+(k<<16);
         else buf_send[k]=(2*k-1)+((2*k)<<16);
       }
       i=1;
       k=nsend;
       i = pcie_send(hDev, i, k, px);

       usleep(1000);

/***    check to see if DMA is done or not **/
       idone =0;
       for (is=0; is<2000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
       }
	/* synch DMA i/O cache **/

       WDC_DMASyncIo(pDma_rec);
//
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t1_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t2_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));

//
       for (is=0; is<nwrite*2; is++) {
         read_array[is]= *buffp_rec32++;
       }
       for (is=0; is< nwrite*2; is++) {
        if((is%8) ==0) printf("%4d",is);
        printf(" %8x",read_array[is]);
        if(((is+1)%8) ==0 ) printf("\n");
       }
       if(((is+1)*8) != 0)printf("\n");
//
//
//
       printf(" receive 1st block of data,, type 1 to continue \n");
       scanf("%d",&i);
//
//
//
//       nwrite = ((nsend_f*8+16))/8-20;
       nwrite = ((nsend_f*4+8)/8) -80;

/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
//       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
//       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       buffp_rec32 = pbuf_rec;

/* synch cache */
       WDC_DMASyncCpu(pDma_rec);
       printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
//       nwrite =(dwDMABufSize/8);  //remove factor 2
//       nwrite = 4000;

       for (is=1; is<3; is++) {
        tr_bar = t1_tr_bar;
        r_cs_reg = r1_cs_reg;
        dma_tr = dma_tr1;
        if(is == 2) {
         tr_bar = t2_tr_bar;
         r_cs_reg = r2_cs_reg;
         dma_tr = dma_tr2;
        }
        printf(" is = %d\n",is);
/** initialize the receiver ***/
        u32Data = cs_init;
        dwOffset = r_cs_reg;
        dwAddrSpace =cs_bar;
//        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
        dwAddrSpace = cs_bar;
        u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
//        u32Data = cs_start+ 20*8;             // readout 40 32 bytes words
        dwOffset = r_cs_reg;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
       printf(" initial receiver \n");
       scanf("%d",&ik);
/** set up DMA for both transceiver together **/

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
//       u32Data = 20*8;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
       u32Data = dma_tr12+dma_4dw_rec;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       printf(" DMA set up done \n");

//
//     send fake data
//
       imod=imod_xmit;
       ichip=3;
       nsend=nsend_f;
       for (k=0; k<nsend; k++) {
         if(k==0) buf_send[k] = (imod<<11)+(ichip<<8)+mb_xmit_testdata+(k<<16);
         else buf_send[k]=(2*k-1)+((2*k)<<16);
       }
       i=1;
       k=nsend;
//       i = pcie_send(hDev, i, k, px);

       usleep(1000);

/***    check to see if DMA is done or not **/
       idone =0;
       for (is=0; is<2000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
       }
	/* synch DMA i/O cache **/

       WDC_DMASyncIo(pDma_rec);
//
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t1_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t2_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));

//
       for (is=0; is<nwrite*2; is++) {
         read_array[is]= *buffp_rec32++;
       }
       for (is=0; is< nwrite*2; is++) {
        if((is%8) ==0) printf("%4d",is);
        printf(" %8x",read_array[is]);
        if(((is+1)%8) ==0 ) printf("\n");
       }
       if(((is+1)*8) != 0)printf("\n");
//
//
//
       printf(" receive 2nd block of data,, type 1 to continue \n");
       scanf("%d",&i);
      }
     }

     break;


    case 24:
     printf(" SuperNova readout test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" enter 1 to turn on huffman encoding \n");
     scanf("%d",&ihuff);
     printf("tyep 1 to compare with the 1st event\n");
     scanf("%d",&comp_s);
     printf("type 1 for print out debug information in dma loop\n");
     scanf("%d",&idebug);
     printf("type 1 for raw data print \n");
     scanf("%d",&irawprint);
     printf(" enter buffer size in bytes \n");
     scanf("%d",&dwDMABufSize);


//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck =0;
     ifr=0;
     irand = 0;
     islow_read =0;
//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//    }
//     else iprint =0;
     iprint = 1;
//     printf(" number event \n");
//     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;
     imod_xmit=10;

// once the fpga is booted we should let system receive fill frame before send any data.
// set system with normal transmitter mode

     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, no hold
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, no hold
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial receiver
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;   // initial receiver
     dwOffset = 0x24;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


     dwAddrSpace =2;
     u32Data = 0xfff;    // set mode off with 0xfff...
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

//
//
//
     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //trun off run
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for (j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms

//
//    boot up xmit module 1st
//
      printf(" boot xmit module \n");
      inpf = fopen("/home/ub/xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
      printf(" xmit done, booting FEM \n");
      scanf("%d",&ik);

//
//    Boot stratix after XMIT module
//
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
//    both FEM and XMIT bootted.
//
//
//   /* set tx mode register */
//
     u32Data = 0x00003fff;  // set up number of words hold coming back from the XMIT module
     printf(" number of words for hold be send back = %x\n",u32Data);
     dwOffset = 0x28;
     dwAddrSpace =2;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
//
//   set up hold
//
     printf(" set up the hold condition \n");
     dwAddrSpace =2;
     u32Data = 0x8000000;    // set up transmitter to return the hold -- upper transciever
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x8000000;    // set up transmitter to return the hold -- lower transciever
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);



//
//    start testing routine
//
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);
       itrig_delay = 51;
       nword =1;
//
// set to use test generator 2, set test =2
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 255 --- there will be 256/8 = 32 adc samples.
//
       imod=0;
       ichip=1;
       iframe= 255;    //1023
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    start loading the test 2 data memory
//
       imod =11;
       ichip=3;
       for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); //enable test mode
        i = pcie_send(hDev, 1, 1, px);
        ibase = 32*is;
        il = is%8;
        if(il == 0) printf(" loading channel %d\n",is);
        for (ik=0; ik< 256; ik++) {                 // loop over all possible address
         if(irand ==1) ijk = rand() & 0xfff ;        // use random number
         else ijk= (ibase+ik*8) & 0xfff;
//         if(ihuff == 1) {
           if((ik%4) ==0) ic =ijk;        // set data to repeat for 4 samples....
           ijk=ic;
//         }
         k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); //enable test mode
         i = pcie_send(hDev, 1, 1, px);
         send_array[is*256+ik]=ijk;           //load up data map
        }
       }

       imod=11;
       ichip=3;
       if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16);  // turn the compression
       else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x1<<16);  // set b channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       timesize =4;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0xf;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     set max word in the pre-buffer memory
//
       ik=8000;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_max+(ik<<16);  // set pre-buffer max word
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     enable hold
//
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_hold_enable+(0x1<<16);  // enable the hold
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       imod=11;
//       ichip=3;
//       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
//       i=1;
//       k=1;
//       if(islow_read == 1) i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//     set up xmit module  -- module count
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+(0x0<<16);  // set number of module to 1 to enable output
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     rest optical
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     enable superNova Token Passing
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x1<<16);  // enable token 1 pass
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
       printf(" enter 1 to reset the DPA \n");
       scanf("%d",&ik);

//
//     reset XMIT LINK IN DPA
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     wait for 10ms just in case
//
       usleep(10000);
       printf(" XMIT FIFO reset \n");
//
//     reset XMIT FIFO reset
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//
//

       for (is=0; is<1; is++) {
//
//      test re-align circuit
//
        imod=imod_xmit;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_word_align+(0x1<<16);  //  send alignment pulse
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

//        printf(" enter 1 to set continue on re-align circuit \n");
//        scanf("%d",&ik);
       }

       usleep(5000); //wait for 5 ms
       printf(" XMIT re-align done \n");


//       dwDMABufSize = 200000;
       ndma_loop =dma_buffer_size/dwDMABufSize;  // set DMA loop for 100 M 32bits words
       printf(" DMA will run %d loop\n", ndma_loop);
       ntot_rec=0;
       for (iv=0; iv<ndma_loop; iv++) {
        if(ifr ==0) {
//         ifr=1;
         printf(" buffer allocation \n");
         dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
         if (WD_STATUS_SUCCESS != dwStatus) {
          printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
          printf("enter 1 to continue \n");
          scanf("%d",&is);
         }
         else {
           u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
           printf(" buffer allocation lower address = %x\n", u32Data);
           u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
           printf(" buffer allocation higher address = %x\n", u32Data);
         }
/* set tx mode register */

         u32Data = 0x00001000;
         dwOffset = tx_md_reg;
         dwAddrSpace =cs_bar;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will abort previous DMA */
         dwAddrSpace =2;
         dwOffset = cs_dma_msi_abort;
         u32Data = dma_abort;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
         dwAddrSpace =2;
         dwOffset = cs_dma_msi_abort;
         u32Data = 0;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
         printf(" initial abort finished \n");
        }

        buffp_rec32 = pbuf_rec;

/* synch cache */
        WDC_DMASyncCpu(pDma_rec);
        printf(".");
        if(idebug ==1) printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
        nwrite =(dwDMABufSize/8);  //remove factor 2
//       nwrite = 4000;

        for (is=1; is<3; is++) {
         tr_bar = t1_tr_bar;
         r_cs_reg = r1_cs_reg;
         dma_tr = dma_tr1;
         if(is == 2) {
          tr_bar = t2_tr_bar;
          r_cs_reg = r2_cs_reg;
          dma_tr = dma_tr2;
         }
         if(idebug ==1) printf(" is = %d\n",is);
/** initialize the receiver ***/
         u32Data = cs_init;
         dwOffset = r_cs_reg;
         dwAddrSpace =cs_bar;
//
// rreceiver only get initialize for the 1st time
//
         if(ifr ==0) WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
         dwAddrSpace = cs_bar;
         u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
         dwOffset = r_cs_reg;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
        }
        if((ifr ==0) &&(idebug ==1)) printf(" initial receiver \n");
//       scanf("%d",&ik);
/** set up DMA for both transceiver together **/

        dwAddrSpace =cs_bar;
        dwOffset = cs_dma_add_low_reg;
        u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

        dwAddrSpace =cs_bar;
        dwOffset = cs_dma_add_high_reg;
        u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
        dwAddrSpace =cs_bar;
        dwOffset = cs_dma_by_cnt;
        u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
        dwAddrSpace =2;
        dwOffset = cs_dma_cntrl;
        u32Data = dma_tr12+dma_3dw_rec;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
        if(idebug ==1) printf(" DMA set up done \n");

        if(ifr ==0) {
         ifr=1;
//
//      turn the run on to start data flow
//
         printf(" enter 1 to set the RUN on \n");
         scanf("%d",&ik);

         imod=0;
         ichip=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
        }

/***    check to see if DMA is done or not **/
        idone =0;
        for (is=0; is<6000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  if(idebug ==1) printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            if(idebug ==1) printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
        }
        if(idone == 0) {
         printf(" loop %d, DMA is not finished \n", iv);
         dwAddrSpace =cs_bar;
         dwOffset = cs_dma_by_cnt;
         WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
         printf (" DMA word count = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//
         WDC_DMASyncIo(pDma_rec);
         nred = (((nwrite)*4*2)-(u64Data &0xffff))/4;
         printf(" number of words received %d %d\n",nred, ntot_rec);
         for (is=0; is<nred; is++) {
          read_array[is+(iv*(nwrite*2))]= *buffp_rec32++;
         }
         ntot_rec = ntot_rec+nred;


/* write this will abort previous DMA */
         dwAddrSpace =2;
         dwOffset = cs_dma_msi_abort;
         u32Data = dma_abort;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
         dwAddrSpace =2;
         dwOffset = cs_dma_msi_abort;
         u32Data = 0;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
         scanf("%d",&is);
        }
        if(idone == 0) break;
	/* synch DMA i/O cache **/

        WDC_DMASyncIo(pDma_rec);
//
        if(idebug == 1) {
         dwAddrSpace =cs_bar;
         u64Data =0;
         dwOffset = t1_cs_reg;
         WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
         printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
         dwAddrSpace =cs_bar;
         u64Data =0;
         dwOffset = t2_cs_reg;
         WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
         printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
        }

//
//     copy of the data array
//
        for (is=0; is<nwrite*2; is++) {
         read_array[is+(iv*(nwrite*2))]= *buffp_rec32++;
        }
        ntot_rec = ntot_rec+(nwrite*2);
       }

//
//
//
       if(irawprint ==1) {
        for (is=0; is< ntot_rec; is++) {
         if((is%8) ==0) printf("%4d",is);
         if(((is%250000) ==0) && (is !=0)) {
          printf(" type 1 to continue\n");
          scanf("%d", &dummy1);
         }
         printf(" %8x",read_array[is]);
         if(((is+1)%8) ==0 ) printf("\n");
        }
        if(((is+1)*8) != 0)printf("\n");
       }

//       for(is=0; is< 6*nwrite; is++) {
//         read_array_s[is*2] = (read_array[is] & 0xffff);
//         read_array_s[is*2+1] = ((read_array[is] >>16) & 0xffff);
//       }
//       nread = ((read_array_s[4] & 0xfff) << 12)+ (read_array_s[5] & 0xfff);

       nread = (((read_array[2] & 0xfff)<<12) + ((read_array[2] & 0xfff0000)>>16));
       nread =nread+1;
       nread = nread/2;
       printf(" no. of word within the frame is %d\n", nread);
       for (is=0; is< nread+7; is++) {       // 6 header + 1 trailer.
        read_comp[is] = read_array[is];
       }

       icomp_l = (ntot_rec)/(nread+7); // only compare complete event  // have to add header
       if(comp_s ==1) printf(" compare %d of event in the loop, nread = %d \n",icomp_l, nread);
       if(comp_s == 1) {
        for(is=0; is<icomp_l; is++) {
         for (ik=6; ik< nread+6; ik++) {   //for the moment skip header
          k=ik+is*(nread+7);
          if(read_comp[ik] != read_array[k]) {
            printf(" data error seq = %d, seq= %d, event = %d, first event data word = %8x, data = %8x \n", ik,k,is,read_comp[ik], read_array[k]);
            scanf("%d",&k);
          }
         }
        }
       }
       printf(" compare finished \n");
       scanf("%d",&is);
       is=0;
       while (is < nwrite*2) {
         if(((nwrite*2)-is) <= 12) printf(" not enough word header \n");
         if(((nwrite*2)-is) <= 12) break;
         if((read_array_s[is] == 0xffff) && (read_array_s[is+1] == 0xffff)) {
          printf(" event header %8x \n", read_array_s[is]+(read_array_s[is+1] << 16));
          is=is+2;
          printf(" module header = %4x\n", read_array_s[is]);
          is=is+1;
          printf(" address word = %4x, aid = %2x, module numebr %3d\n", read_array_s[is], ((read_array_s[is]>>5) &0x7f), (read_array_s[is] &0x1f));
          is=is+1;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          nread=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          nread = nread+1;
          printf(" word count word = %8x, word count = %8d \n", ik,nread);
          is = is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" event number word = %8x, event number = %8d \n", ik,k);
          is = is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" frame number word = %8x, frame number = %8d \n", ik,k);
          is =is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" checksum word = %8x, checksum = %8x \n", ik,k);
          is=is+2;
         if(((nwrite*2)-is) <= (nread+2)) printf(" not enough word for the event \n");
         if(((nwrite*2)-is) <= (nread+2)) break;
          is=is+nread;
          printf("end of packet word, %8x \n", read_array_s[is]+ (read_array_s[is+1]<<16));
          is = is+2;
          scanf("%d", &ik);
         }
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }

     break;


    case 25:
     printf(" SuperNova readout test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" enter 1 to turn on huffman encoding \n");
     scanf("%d",&ihuff);
     printf("tyep 1 to compare with the 1st event\n");
     scanf("%d",&comp_s);
     printf("type 1 for print out debug information in dma loop\n");
     scanf("%d",&idebug);
     printf(" enter buffer size in bytes \n");
     scanf("%d",&dwDMABufSize);

//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck =0;
     ifr=0;
     irand = 0;
     islow_read =0;
//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//    }
//     else iprint =0;
     iprint = 1;
//     printf(" number event \n");
//     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;
     imod_xmit=10;

// once the fpga is booted we should let system receive fill frame before send any data.
// set system with normal transmitter mode

     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, no hold
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial transmitter, no hold
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     dwAddrSpace =2;
     u32Data = 0x20000000;    // initial receiver
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x20000000;   // initial receiver
     dwOffset = 0x24;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


     dwAddrSpace =2;
     u32Data = 0xfff;    // set mode off with 0xfff...
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

//
//
//
     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //trun off run
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=11;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for (j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms

//
//    boot up xmit module 1st
//
      printf(" boot xmit module \n");
      inpf = fopen("/home/ub/xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
      printf(" xmit done, booting FEM \n");
      scanf("%d",&ik);

//
//    Boot stratix after XMIT module
//
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=11;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
//
//    both FEM and XMIT bootted.
//
//
//   /* set tx mode register */
//
     u32Data = 0x00003fff;  // set up number of words hold coming back from the XMIT module
     printf(" number of words for hold be send back = %x\n",u32Data);
     dwOffset = 0x28;
     dwAddrSpace =2;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
//
//   set up hold
//
     printf(" set up the hold condition \n");
     dwAddrSpace =2;
     u32Data = 0x8000000;    // set up transmitter to return the hold -- upper transciever
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x8000000;    // set up transmitter to return the hold -- lower transciever
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);



//
//    start testing routine
//
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=11;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);
       itrig_delay = 51;
       nword =1;
//
// set to use test generator 2, set test =2
//
       imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 255 --- there will be 256/8 = 32 adc samples.
//
       imod=0;
       ichip=1;
       iframe= 255;    //1023
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    start loading the test 2 data memory
//
       imod =11;
       ichip=3;
       for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); //enable test mode
        i = pcie_send(hDev, 1, 1, px);
        ibase = 32*is;
        il = is%8;
        if(il == 0) printf(" loading channel %d\n",is);
        for (ik=0; ik< 256; ik++) {                 // loop over all possible address
         if(irand ==1) ijk = rand() & 0xfff ;        // use random number
         else ijk= (ibase+ik*8) & 0xfff;
//         if(ihuff == 1) {
           if((ik%4) ==0) ic =ijk;        // set data to repeat for 4 samples....
           ijk=ic;
//         }
         k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); //enable test mode
         i = pcie_send(hDev, 1, 1, px);
         send_array[is*256+ik]=ijk;           //load up data map
        }
       }

       imod=11;
       ichip=3;
       if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16);  // turn the compression
       else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x1<<16);  // set b channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       timesize =4;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0xf;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     set max word in the pre-buffer memory
//
       ik=8000;
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_max+(ik<<16);  // set pre-buffer max word
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     enable hold
//
       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_hold_enable+(0x1<<16);  // enable the hold
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       imod=11;
//       ichip=3;
//       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
//       i=1;
//       k=1;
//       if(islow_read == 1) i = pcie_send(hDev, i, k, px);


       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=11;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//     set up xmit module  -- module count
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+(0x0<<16);  // set number of module to 1 to enable output
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     rest optical
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     enable superNova Token Passing
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x1<<16);  // enable token 1 pass
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//
       printf(" enter 1 to reset the DPA \n");
       scanf("%d",&ik);

//
//     reset XMIT LINK IN DPA
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//     wait for 10ms just in case
//
       usleep(10000);
       printf(" XMIT FIFO reset \n");
//
//     reset XMIT FIFO reset
//
       imod=imod_xmit;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//
//
//

       for (is=0; is<1; is++) {
//
//      test re-align circuit
//
        imod=imod_xmit;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_word_align+(0x1<<16);  //  send alignment pulse
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

//        printf(" enter 1 to set continue on re-align circuit \n");
//        scanf("%d",&ik);
       }

       usleep(5000); //wait for 5 ms
       printf(" XMIT re-align done \n");

//       dwDMABufSize = 200000;
       if(ifr ==0) {
        ifr=1;
        printf(" buffer allocation \n");
        dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
        if (WD_STATUS_SUCCESS != dwStatus) {
         printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
         printf("enter 1 to continue \n");
         scanf("%d",&is);
        }
       }

/* set tx mode register */

       u32Data = 0x000003ff;
       dwOffset = tx_md_reg;
       dwAddrSpace =cs_bar;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       buffp_rec32 = pbuf_rec;

/* synch cache */
       WDC_DMASyncCpu(pDma_rec);
       if(idebug ==1) printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
       nwrite =(dwDMABufSize/8);  //remove factor 2 
//       nwrite = 4000;

       for (is=1; is<3; is++) {
        tr_bar = t1_tr_bar;
        r_cs_reg = r1_cs_reg;
        dma_tr = dma_tr1;
        if(is == 2) {
         tr_bar = t2_tr_bar;
         r_cs_reg = r2_cs_reg;
         dma_tr = dma_tr2;
        }
        if(idebug ==1) printf(" is = %d\n",is);
/** initialize the receiver ***/
        u32Data = cs_init;
        dwOffset = r_cs_reg;
        dwAddrSpace =cs_bar;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
        dwAddrSpace = cs_bar;
        u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
        dwOffset = r_cs_reg;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
       if(idebug ==1) printf(" initial receiver \n");
//       scanf("%d",&ik);
/** set up DMA for both transceiver together **/

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
       u32Data = dma_tr12+dma_3dw_rec;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       if(idebug ==1) printf(" DMA set up done \n");

//
//      turn the run on to start data flow
//
       printf(" enter 1 to set the RUN on \n");
       scanf("%d",&ik);

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

/***    check to see if DMA is done or not **/
       idone =0;
       for (is=0; is<6000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  if(idebug ==1) printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            if(idebug ==1) printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
       }
       if(idone == 0) {
         printf(" loop 0, DMA is not finished \n");
         scanf("%d",&is);
       }
	/* synch DMA i/O cache **/

       WDC_DMASyncIo(pDma_rec);
//
       if(idebug == 1) {
        dwAddrSpace =cs_bar;
        u64Data =0;
        dwOffset = t1_cs_reg;
        WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
        printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
        dwAddrSpace =cs_bar;
        u64Data =0;
        dwOffset = t2_cs_reg;
        WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
        printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
       }

//
//     copy of the data array
//
       for (is=0; is<nwrite*2; is++) {
         read_array[is]= *buffp_rec32++;
       }
//
//     set up for the second loop
//
//       dwDMABufSize = 20000;

/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
//       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
//       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       buffp_rec32 = pbuf_rec;

/* synch cache */
       WDC_DMASyncCpu(pDma_rec);
       if(idebug ==1) printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
       nwrite =(dwDMABufSize/8);  //remove factor 2
//       nwrite = 4000;

       for (is=1; is<3; is++) {
        tr_bar = t1_tr_bar;
        r_cs_reg = r1_cs_reg;
        dma_tr = dma_tr1;
        if(is == 2) {
         tr_bar = t2_tr_bar;
         r_cs_reg = r2_cs_reg;
         dma_tr = dma_tr2;
        }
        if(idebug ==1) printf(" is = %d\n",is);
//
//      do not init the receiver... otherwise it will remove data from the fifo
/** start the receiver **/
//
        dwAddrSpace = cs_bar;
        u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
        dwOffset = r_cs_reg;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
       if(idebug ==1) printf(" initial receiver \n");
//       scanf("%d",&ik);
//
/** set up DMA for both transceiver together **/
//
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
       u32Data = dma_tr12+dma_3dw_rec;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       if(idebug ==1) printf(" DMA set up done \n");
//
/***    check to see if DMA is done or not **/
//
       idone =0;
       for (is=0; is<6000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  if(idebug ==1) printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            if(idebug ==1) printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
       }
	/* synch DMA i/O cache **/
       if(idone == 0) {
         printf(" loop 1, DMA is not finished \n");
         scanf("%d",&is);
       }
       WDC_DMASyncIo(pDma_rec);
//
       if(idebug ==1) {
        dwAddrSpace =cs_bar;
        u64Data =0;
        dwOffset = t1_cs_reg;
        WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
        printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
        dwAddrSpace =cs_bar;
        u64Data =0;
        dwOffset = t2_cs_reg;
        WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
        printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
       }

//
//     copy of the data array
//
       for (is=0; is<nwrite*2; is++) {
         read_array[is+(nwrite*2)]= *buffp_rec32++;
       }
//
//     set up for the third loop
//
//       dwDMABufSize = 20000;

/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
//       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
//       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       buffp_rec32 = pbuf_rec;

/* synch cache */
       WDC_DMASyncCpu(pDma_rec);
       if(idebug ==1) printf(" synch CPU \n");
///
///    set up the DMA size  (half buffer size limit??)
///
       nwrite =(dwDMABufSize/8);  //remove factor 2
//       nwrite = 4000;

       for (is=1; is<3; is++) {
        tr_bar = t1_tr_bar;
        r_cs_reg = r1_cs_reg;
        dma_tr = dma_tr1;
        if(is == 2) {
         tr_bar = t2_tr_bar;
         r_cs_reg = r2_cs_reg;
         dma_tr = dma_tr2;
        }
        if(idebug ==1) printf(" is = %d\n",is);
//
//      do not init the receiver... otherwise it will remove data from the fifo
/** start the receiver **/
//
        dwAddrSpace = cs_bar;
        u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
        dwOffset = r_cs_reg;
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
       if(idebug ==1) printf(" initial receiver \n");
//       scanf("%d",&ik);
//
/** set up DMA for both transceiver together **/
//
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
       u32Data = dma_tr12+dma_3dw_rec;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       if(idebug ==1) printf(" DMA set up done \n");
//
/***    check to see if DMA is done or not **/
//
       idone =0;
       for (is=0; is<6000; is++) {;
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	  if(idebug ==1) printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
            if(idebug ==1) printf(" receive DMA complete %d \n", i);
          }
	  if((u32Data & dma_in_progress) == 0) break;
       }
       if(idone == 0) {
         printf(" loop 2, DMA is not finished \n");
         dwAddrSpace =cs_bar;
         dwOffset = cs_dma_by_cnt;
         WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
         printf (" DMA word count = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
/* write this will abort previous DMA */
         dwAddrSpace =2;
         dwOffset = cs_dma_msi_abort;
         u32Data = dma_abort;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
         dwAddrSpace =2;
         dwOffset = cs_dma_msi_abort;
         u32Data = 0;
         WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
         scanf("%d",&is);
       }
	/* synch DMA i/O cache **/

       WDC_DMASyncIo(pDma_rec);
//
       if(idebug ==1) {
        dwAddrSpace =cs_bar;
        u64Data =0;
        dwOffset = t1_cs_reg;
        WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
        printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
        dwAddrSpace =cs_bar;
        u64Data =0;
        dwOffset = t2_cs_reg;
        WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
        printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
       }

//
//     copy of the data array
//
       for (is=0; is<nwrite*2; is++) {
         read_array[is+(2*(nwrite*2))]= *buffp_rec32++;
       }
//
//
//
       for (is=0; is< nwrite*6; is++) {
        if((is%8) ==0) printf("%4d",is);
        if(((is%25000) ==0) && (is !=0)) {
          printf(" type 1 to continue\n");
          scanf("%d", &dummy1);
        }
        printf(" %8x",read_array[is]);
        if(((is+1)%8) ==0 ) printf("\n");
       }
       if(((is+1)*8) != 0)printf("\n");

       for(is=0; is< 6*nwrite; is++) {
         read_array_s[is*2] = (read_array[is] & 0xffff);
         read_array_s[is*2+1] = ((read_array[is] >>16) & 0xffff);
       }
       nread = ((read_array_s[4] & 0xfff) << 12)+ (read_array_s[5] & 0xfff);
       nread =nread+1;
       nread = nread/2;
       for (is=0; is< nread+7; is++) {       // 6 header + 1 trailer.
        read_comp[is] = read_array[is];
       }

       icomp_l = (nwrite*6)/(nread+7); // only compare complete event  // have to add header
       if(comp_s ==1) printf(" compare %d of event in the loop, nread = %d \n",icomp_l, nread);
       if(comp_s == 1) {
        for(is=0; is<icomp_l; is++) {
         for (ik=6; ik< nread+6; ik++) {   //for the moment skip header
          k=ik+is*(nread+7);
          if(read_comp[ik] != read_array[k]) {
            printf(" data error seq = %d, seq= %d, event = %d, first event data word = %8x, data = %8x \n", ik,k,is,read_comp[ik], read_array[k]);
            scanf("%d",&k);
          }
         }
        }
       }
       printf(" compare finished \n");
       scanf("%d",&is);
       is=0;
       while (is < nwrite*2) {
         if(((nwrite*2)-is) <= 12) printf(" not enough word header \n");
         if(((nwrite*2)-is) <= 12) break;
         if((read_array_s[is] == 0xffff) && (read_array_s[is+1] == 0xffff)) {
          printf(" event header %8x \n", read_array_s[is]+(read_array_s[is+1] << 16));
          is=is+2;
          printf(" module header = %4x\n", read_array_s[is]);
          is=is+1;
          printf(" address word = %4x, aid = %2x, module numebr %3d\n", read_array_s[is], ((read_array_s[is]>>5) &0x7f), (read_array_s[is] &0x1f));
          is=is+1;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          nread=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          nread = nread+1;
          printf(" word count word = %8x, word count = %8d \n", ik,nread);
          is = is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" event number word = %8x, event number = %8d \n", ik,k);
          is = is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" frame number word = %8x, frame number = %8d \n", ik,k);
          is =is+2;
          ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
          k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
          printf(" checksum word = %8x, checksum = %8x \n", ik,k);
          is=is+2;
         if(((nwrite*2)-is) <= (nread+2)) printf(" not enough word for the event \n");
         if(((nwrite*2)-is) <= (nread+2)) break;
          is=is+nread;
          printf("end of packet word, %8x \n", read_array_s[is]+ (read_array_s[is+1]<<16));
          is = is+2;
          scanf("%d", &ik);
         }
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }

     break;



    case 26:
     printf(" multiple ADC board test \n");
     printf(" enable number of loop\n");
//***     scanf("%d",&nloop);
//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck = 0;
     irand =0;
     if(icheck != 1) {
      printf(" 1 for print event\n");
//***      scanf("%d",&iprint);
     }
     else iprint =0;
     printf(" number event \n");
//***     scanf("%d",&nevent);
     iprint =1;
     nloop=10;
     nevent=10;
//****

     printf(" first FEM module address \n");
     scanf("%d", &ifem_fst);
     printf(" last FEM module address \n");
     scanf("%d", &ifem_lst);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);



//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
//
//disable the run command
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      itrig_delay = 51;
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
      imod=0;
      ichip=1;
      iframe= 255;    //1023
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

//
//

      for (ifem_loop=ifem_fst; ifem_loop< (ifem_lst+1); ifem_loop++) {
 // turn on the Stratix III power supply
       printf(" starting boot module %d\n", ifem_loop);
       imod=ifem_loop;
       ichip =1;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(200000);  // wait for 200 ms
       usleep(10000); // wait for 10ms
       inpf = fopen("/home/ub/feb_fpga_test","r");
//       imod=11;
       ichip=mb_feb_conf_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
       usleep(1000);   // wait fior a while
       count = 0;
       counta= 0;
       ichip_c = 7; // set ichip_c to stay away from any other command in the
       dummy1 =0;
       while (fread(&charchannel,sizeof(char),1,inpf)==1) {
        carray[count] = charchannel;
        count++;
        counta++;
        if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
         buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
         send_array[0] =buf_send[0];
         if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
         for (ij=0; ij< nsend; ij++) {
          if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
          else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
          send_array[ij+1] = buf_send[ij+1];
         }
         nword =nsend+1;
         i=1;
//       if(dummy1 == 0)
         ij = pcie_send(hDev, i, nword, px);
         nanosleep(&tim , &tim2);
         dummy1 = dummy1+1;
         count =0;
        }
       }
       if(feof(inpf)) {
        printf("You have reached the end-of-file word count= %d %d\n", counta, count);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        if ( count > 1) {
         if( ((count-1)%2) ==0) {
          ik =(count-1)/2;
         }
         else {
          ik =(count-1)/2+1;
         }
         ik=ik+2;   // add one more for safety
         printf("ik= %d\n",ik);
         for (ij=0; ij<ik; ij++){
          if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
          else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
          send_array[ij+1] = buf_send[ij+1];
         }
        }
        else ik=1;

        for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
        }
        nword =ik+1;
        i=1;
        i = pcie_send(hDev, i, nword, px);
        usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       }

       fclose(inpf);
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
//       ik =1;
//       if(ik ==1) {
//         imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//         imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000);    // wait for 5 ms for DRAM to be initialized

//         imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//        }
//      printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
//        ik=1;
       nword =1;
//        if(ik ==1) {


       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

//         imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
//        }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);

//
//        set adc operatio -- soft reset
//
       for (is=0; is<8; is++) {
//         imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
//       printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0x0))+((0x3c)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x0, data =0x3c;
//

        i=1;
        k=2;
//       i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
       }
//       usleep(2000);   // sleep for 2ms
       printf(" enter 1 to continue after soft reset\n");
//***       scanf("%d",&ik);
//
//     set to double terminate the ADC driver
//
       for (is=0; is<8; is++) {
//         imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0x15))+((0x30)<<24)+((0x0)<<16);
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x15, data =0x30;
//

        i=1;
        k=2;
//        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
//        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }
//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
       for (is=0; is<8; is++) {
//         imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xd))+((0xc)<<24)+((0x0)<<16);
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }

       printf(" enter 1 to continue FPGA ADC receiver reset\n");
//***       scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
//       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_reset+(0x1<<16);  // FPGA ADC receiver reset on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       printf(" enter 1 to continue FPGA ADC receiver align\n");
//***       scanf("%d",&ik);
//
//    send FPGA ADC align
//
//       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_align+(0x0<<16);  // FPGA ADC receiver reset off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(2000);   // sleep for 2ms

       printf(" finish align \n");
//****       scanf("%d",&ik);
//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
       for (is=0; is<8; is++) {
//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xd))+((0xb)<<24)+((0x0)<<16);          // send 1 bit high
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms
        printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
        ichip=5;
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
        buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

        i=1;
        k=2;
        i = pcie_send(hDev, i, k, px);
        usleep(2000);   // sleep for 2ms

       }




//        itrig_delay = 51;
       nword =1;
//
// set to not use test generator 2, set test =2
//
//        imod=11;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x0<<16);  // set test source to 0
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       timesize =4;
//        imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       a_id =0x20;
//       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(imod<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//       imod=11;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

      }
//
//
      printf(" FEM boot and setup done\n");

//
//
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      usleep(5000); //wait for 5 ms


      for (is=0; is<nevent; is++) {



       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); // wait for 5 ms

//      set module number again to enable the FEB module read back
       for (ifem_loop=ifem_fst; ifem_loop< (ifem_lst+1); ifem_loop++) {
        imod=ifem_loop;

//        imod=11;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(imod<<16);  // set a_id
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
//
//
//
//       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
//       ichip=3;
//       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
//       i=1;
//       k=1;
//       i = pcie_send(hDev, i, k, px);
//       py = &read_array;
//       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//       printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
//
//
//        usleep(1000);
        nword = 5;
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

//        imod=11;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iprint ==1) printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
        if(iprint == 1) {
          printf(" *** module number %d ***\n", imod);
          printf(" header word %x \n",(read_array[0] & 0xffff));
          k=(read_array[0]>>16) & 0xfff;
          printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
          printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
          printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
          printf(" frame number %d\n", (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12)));
          printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
        }
        nread = ((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12);
//        if(iprint ==1) printf(" number of data word to read = %d\n",nread);

//        ik =  read_array[0] & 0x1f;
//        if(iprint ==1) printf(" module number = %d",ik);
//        ik =  (read_array[0] >> 5) & 0x7f;
//        if(iprint ==1) printf(" data ID = %d",ik);
//        ik =  (((read_array[2] >>16) & 0xfff)<<12) + (read_array[2] & 0xfff);
//        if(iprint ==1) printf(" event number = %d",ik);
//        ik =  (((read_array[3] >>16) & 0xfff)<<12) + (read_array[3] & 0xfff);
//        if(iprint ==1) printf(" frame number = %d\n",ik);
//        ik =  (((read_array[4] >>16) & 0xfff)<<12) + (read_array[4] & 0xfff);
//        if(iprint ==1) printf(" checksum = %x\n",ik);

        if(iprint ==1 )scanf("%d",&ik);
        nword = (nread+1)/2;
        nword =384;                  // short words
        i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

//        imod=11;
        ichip=mb_feb_pass_add;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

        if(iprint == 1) {
         for (i=0; i< nword; i++) {
          if((i%8) ==0) printf("%4d",i);
          printf(" %8x",read_array[i]);
          if(((i+1)%8) ==0 ) printf("\n");
         }
        }

        ik=0;
        for (i=0; i< nword; i++) {
          read_array_s[ik] = read_array[i] &0xffff;
          read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
          ik=ik+2;
        }

//
//      printout formatted word
//
        if(iprint ==1) {
         iset = 0;
         for(i=0; i< 2*nword; i++) {
          if((read_array_s[i] & 0xf000) == 0x4000) {
            iset=1;
            ncount=0;
            printf(" channel %d\n",(read_array_s[i] & 0xfff));
          }
          else if ((read_array_s[i] & 0xf000) == 0x5000) printf(" channel end %d\n",(read_array_s[i] &0xfff));
          else if (iset ==1) {
            printf(" %4x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
          }
          else {
            printf("%x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
          }
         }
        }

        if(icheck ==1 ){
         if((2*nword) == (64*timesize*3)){
          for (i=0; i<64; i++){
           k=i*(timesize*3);
           ij= i*256;
           if(read_array_s[k] != (0x4000+i))
            printf(" first word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x4000+i));
           for (ik=0; ik< ((3*timesize)-2); ik++) {
            if(read_array_s[k+1+ik] != send_array[ij+ik])
             printf(" data word error, event %d ch = %d, received %x, expected %x\n",is,i,read_array_s[k+1+ik], send_array[ij+ik]);
           }
           k=(i+1)*(timesize*3)-1;
           if(read_array_s[k] != (0x5000+i))
            printf(" last word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x5000+i));
          }
         }
         else {
          printf(" event %d number word receive = %d, expected=  %d \n", is, (2*nword), (64*timesize*3));
         }
        }
        if(icheck ==1) {
          k = is%1000;
          if(k ==0) printf("event %d\n",is);
        }
        if(iprint == 1) scanf("%d",&ik);

       }
      }

      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      scanf("%d",&ik);
     }

     break;
     

    case 27:
     printf(" trigger borad test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck =0;
     irand = 0;
     islow_read =0;
//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//     }
//     else iprint =0;
//     iprint = 1;
//     printf(" number event \n");
//     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;
     imod_trig=18;
     printf("trigger module address %d\n", imod_trig);

     px = &buf_send;
     py = &read_array;
//
//   controller
//
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_deadtime_size)+((0x1)<<16); //set trigger deadtime size
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

//    for (j=1; j<nloop; j++) {
     imod=imod_trig;
     iframe= 255;    //1023
     buf_send[0]=(imod<<11)+(mb_trig_frame_size)+((iframe & 0xffff)<<16); //set up frame size.
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     usleep(5000);
     imod=imod_trig;
//     buf_send[0]=(imod<<11)+(mb_trig_mask8)+((0x2 & 0xffff)<<16); // enable external trigger mask
     buf_send[0]=(imod<<11)+(mb_trig_mask8)+((0x4a & 0xffff)<<16); // enable external trigger mask
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     usleep(5000);
     imod=imod_trig;         //fack module
     buf_send[0]=(imod<<11)+(mb_trig_prescale8)+((0x0 & 0xffff)<<16); // set prescale for mask 8
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);


//     }


     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_run)+((0x1)<<16); //set up run
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

      printf(" set up to run \n");
      scanf("%d",&ik);

     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_calib_delay)+((0x10)<<16); //set up calibration delay to 0x20
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     for (j=1; j<nloop; j++) {
      imod=imod_trig;
      if(j==2) printf("enter calibration test loop\n");
      buf_send[0]=(imod<<11)+(mb_trig_calib)+((0x0)<<16); //fire up calibration pulse
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(5000);
     }


     for (j=1; j<nloop; j++) {

      iprint=1;
      nread = 5;
      i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // init the receiver

      imod =imod_trig;  /* trigger module */
      buf_send[0]=(imod<<11)+mb_trig_pctrig+((0x0)<<16);
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(1000);

      printf(" enter 1 to read system status \n");
      scanf("%d",&ik);

      nword = 7;

      i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver


      scanf("%d",&ik);

      imod=imod_trig;
      ichip=3;   // don't care about ichip #
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_trig_rd_param+(0x0<<16);  // read out status
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      py = &read_array;
      i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
      printf("receive data word = %x, %x, %x, %x \n", read_array[0], read_array[1],read_array[2], read_array[3]);
      printf("receive data word = %x, %x, %x\n", read_array[4], read_array[5],read_array[6]);
//
//
//
      py = &read_array;
      i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
      printf("optical receive data word = %x, %x, %x\n", read_array[0], read_array[1],read_array[2]);

      scanf("%d",&ik);

     }

     break;
     
     


    case 28:
     printf(" feb boot test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
     printf(" enter module number \n");
     scanf("%d",&imod_fem);
//     printf(" frame length \n");
//     scanf("%d",&iframe_length);
     iframe_length =8192;
     ik=iframe_length%64;
     if(ik != 0) printf(" frame_length problem \n");

//     printf(" drift time (< %d) \n", iframe_length/8);
//     scanf("%d",&idrift_time);
     idrift_time =10;
     printf(" enter triger delay \n");
     scanf("%d",&itrig_delay);
//     printf("number of triggers per loop \n");
//     scanf("%d",&itrig);
     itrig =1;
     printf(" 1 for checking the event \n");
     scanf("%d",&icheck);
     printf(" type 1 to use random number \n");
     scanf("%d",&irand);
//     icheck=0;
//     irand=0;
     if(icheck != 1) {
      printf(" 1 for print event\n");
      scanf("%d",&iprint);
     }
     else iprint =0;
     printf(" number event \n");
     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
// set offline test
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 //disable the run command
     imod=0;
     ichip=1;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
 // turn on the Stratix III power supply
     imod=imod_fem;
     ichip =1;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);
     for ( j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=imod_fem;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
       printf(" enter 1 to reset the dram \n");
       scanf("%d",&ik);
 //      ik =1;
       if(ik ==1) {
         imod=imod_fem;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         imod=imod_fem;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         usleep(5000);    // wait for 5 ms for DRAM to be initialized

         imod=imod_fem;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);


       }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);
       ik=1;
       nword =1;
       if(ik ==1) {


         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=imod_fem;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
       }
//       printf(" enter L1 trigger delay \n");
//       scanf("%d",&itrig_delay);
//       itrig_delay = 51;
       nword =1;
//
// set to use test generator 2, set test =2
//
       imod=imod_fem;
       ichip=mb_feb_pass_add;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
// set frame set to be 1023 --- there will be 1024/8 = 128 adc samples.
//
       imod=0;
       ichip=1;
//       iframe= 255;    //1023
       iframe = iframe_length-1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


//
// load trig 1 position relative to the frame..
//
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
//
//    start loading the test 2 data memory
//
       imod =imod_fem;
       ichip=3;
       for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); //enable test mode
        i = pcie_send(hDev, 1, 1, px);
        ibase = 32*is;
        il = is%8;
        if(il == 0) printf(" loading channel %d\n",is);
        for (ik=0; ik< 256; ik++) {                 // loop over all possible address
         if(irand ==1) ijk = rand() & 0xfff ;        // use random number
         else ijk= (ibase+ik*8) & 0xfff;
         k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); //enable test mode
         i = pcie_send(hDev, 1, 1, px);
         send_array[is*256+ik]=ijk;           //load up data map
        }
       }

       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set a channel no compression
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

//       timesize =4;
       timesize = idrift_time;
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       a_id =0x20;
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);


       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       usleep(5000); //wait for 5 ms
       scanf("%d",&ik);


       for (is=0; is<nevent; is++) {


//
//     send out multiple triggers
//
        for (ijtrig=0; ijtrig<itrig; ijtrig++) {
         printf(" itrig %d, itrig_delay %d\n", ijtrig,itrig_delay);
         imod=0;
         ichip=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         usleep(10000);  //put some space between triggers
//
// load trig 1 position relative to the frame..
//
         itrig_delay = itrig_delay+2;
         imod=0;
         ichip=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         scanf("%d",&ik);

         usleep(10000);

        }



//      set module number again to enable the FEB module read back

        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

        usleep(5000); // wait for 5 ms

        for (ijtrig=0; ijtrig<itrig; ijtrig++) {
         nword = 5;
         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=imod_fem;
         ichip=3;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdhed+(0x1<<16);  // read a header
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

         if(iprint ==1) printf("receive data word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
         if(iprint == 1) {
          printf(" header word %x \n",(read_array[0] & 0xffff));
          k=(read_array[0]>>16) & 0xfff;
          printf(" module adress %d, id number %d\n", (k & 0x1f), ((k>>5) & 0x7f));
          printf(" number of data word to read %d\n", (((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12)));
          printf(" event number %d\n", (((read_array[2]>>16) & 0xfff)+((read_array[2] &0xfff) <<12)));
          printf(" frame number %d\n", (((read_array[3]>>16) & 0xfff)+((read_array[3] &0xfff) <<12)));
          printf(" checksum %x\n", (((read_array[4]>>16) & 0xfff)+((read_array[4] &0xfff) <<12)));
         }
         nread = ((read_array[1]>>16) & 0xfff)+((read_array[1] &0xfff) <<12);
         if(iprint ==1 )scanf("%d",&ik);
         nword = (nread+1)/2;                    // short words
         i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

         imod=imod_fem;
         ichip=mb_feb_pass_add;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_rdbuf+(0x0<<16);  // read a header
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);

         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words

         if(iprint == 1) {
          for (i=0; i< nword; i++) {
           if((i%8) ==0) printf("%4d",i);
           printf(" %8x",read_array[i]);
           if(((i+1)%8) ==0 ) printf("\n");
          }
         }

         ik=0;
         for (i=0; i< nword; i++) {
          read_array_s[ik] = read_array[i] &0xffff;
          read_array_s[ik+1] = ((read_array[i]>>16) & 0xffff);
          ik=ik+2;
         }

//
//      printout formatted word
//
         if(iprint ==1) {
          iset = 0;
          for(i=0; i< 2*nword; i++) {
           if((read_array_s[i] & 0xf000) == 0x4000) {
            iset=1;
            ncount=0;
            printf(" channel %d\n",(read_array_s[i] & 0xfff));
           }
           else if ((read_array_s[i] & 0xf000) == 0x5000) printf(" channel end %d\n",(read_array_s[i] &0xfff));
           else if (iset ==1) {
            printf(" %4x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
           }
           else {
            printf("%x",read_array_s[i]);
            ncount = ncount+1;
            if((ncount%8) == 0) printf("\n");
           }
          }
         }

         if(icheck ==1 ){
          if((2*nword) == (64*timesize*3)){
           for (i=0; i<64; i++){
            k=i*(timesize*3);
            ij= i*256;
            if(read_array_s[k] != (0x4000+i))
             printf(" first word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x4000+i));
            for (ik=0; ik< ((3*timesize)-2); ik++) {
             if(read_array_s[k+1+ik] != send_array[ij+ik])
              printf(" data word error, event %d ch = %d, received %x, expected %x\n",is,i,read_array_s[k+1+ik], send_array[ij+ik]);
            }
            k=(i+1)*(timesize*3)-1;
            if(read_array_s[k] != (0x5000+i))
             printf(" last word error, event %d data received %x, data expected %x\n", is, read_array_s[k], (0x5000+i));
           }
          }
          else {
           printf(" event %d number word receive = %d, expected=  %d \n", is, (2*nword), (64*timesize*3));
          }
         }
        }
        if(icheck ==1) {
          k = is%1000;
          if(k ==0) printf("event %d\n",is);
        }
        if(iprint == 1) scanf("%d",&ik);
       }

       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       scanf("%d",&ik);
      }





     }

     break;




     }

}





/* -----------------------------------------------
    Read/write memory and I/O addresses -- TEST
   ----------------------------------------------- */
/* Read/write memory or I/O space address menu options */
static void Menujsebii_test(WDC_DEVICE_HANDLE hDev)
{
/*  pci express bar setting
bar 0,1 is for transceiver 1
bar 2,3 is for command
bar 4,5 is for transceiver 2
*/

#include "wdc_defs.h"

#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/
/** GKQ: are these specific to a pcie? **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

  /** bunch of variable initializations **/
  static DWORD dwAddrSpace;

  static UINT32 u32Data, u32Data_send;
  static unsigned long long u64Data;
  static DWORD dwOffset;
  static unsigned long long buff[10000];
/*    PVOID buff_p; */
  static UINT32 *buffp_send;
  static UINT32 *buffp_rec;
  static UINT64 *buffp_rec64;
/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
  static UINT32 i,j,k,ifr,jk,nwrite,iprint,nread;
  int newcmd,itr,tr_bar,icheck,istop,iloop,t_cs_reg,r_cs_reg;
  int idone,iseq,incomp,dma_tr,isweep,nsize_sw,irand,nwrite_max,nwrite_min;
  int kwrite;
  UINT32 write_array[100000],read_array[100000];
  int n_written;
  DWORD dwDMABufSize;
  PVOID pbuf_send;
  PVOID pbuf_rec;
  WD_DMA *pDma_send;
  WD_DMA *pDma_rec;
  DWORD dwStatus;
  DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
  DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE;

  iprint =1;
  ifr =0;
  istop =0;
  icheck =1;
  
    /** main menu (options) of routine **/
  printf(" PCIe board testing routing \n");
  printf(" type 1 to use random number \n");
  scanf("%d",&irand);
  printf(" which transceiver to test (1,2 ) \n");
  scanf("%d", &itr);
  printf(" input testing method \n");
  printf(" 1) for slave loop back test \n");
  printf(" 2) DMA loop back test \n");
  //  printf(" 3) combine optical DMA test \n");
  printf(" 3) write-to-file test \n");
  scanf("%d",&newcmd);
  switch(newcmd) {

  case 1:
    if(icheck == 1) printf(" data checking on \n");
    printf("enter number words per packet, -1 for sequence test \n");
    scanf("%d",&kwrite);
    if(kwrite == -1) {
      printf("enter min number of word \n");
      scanf("%d",&nwrite_min);
      printf("enter max number of word \n");
      scanf("%d",&nwrite_max);
      nwrite=nwrite_min;
    }
    else nwrite = kwrite;
    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
    }
    
/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


      /** begin timer **/
    struct timeval starttest1, endtest1;
    gettimeofday(&starttest1,NULL);
    long mytime1, seconds1, useconds1;
    seconds1 = starttest1.tv_sec;
    useconds1 = starttest1.tv_usec;
      
    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds1,useconds1);
      //get a fresh timestamp
    gettimeofday(&starttest1,NULL);


    for (j=0; j<iloop; j++) {
	//GSK
	//       printf("started loop = %d \n",j);
/* set tx mode register */
      u32Data = 0xf0000fff;
      dwOffset = tx_md_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** initialize the tranmission ***/
      u32Data = cs_init;
      dwOffset = t_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = t_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");

/** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if (iprint ==1 && j < 2) printf(" set up receiver \n");

       //GSK
       //       if(icheck == 1) {
       //         dwAddrSpace =cs_bar;
       //         u64Data =0;
       //         dwOffset = t_cs_reg;
       //         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //         if(iprint==1 && j < 2) {
       //          u32Data=u64Data;
       //          printf (" transmitter status before send  = %8X \n",u32Data);
       //          u32Data=u64Data>>32;
       //          printf (" receiver status before send  = %8X \n",u32Data);
       //         }
       //       }

       //GSK
      u32Data = 0x22211; 

      for (i=0; i< nwrite; i++) {
        dwAddrSpace = tr_bar;
	//GSK
	//        if(irand == 1) u32Data=rand();
	//        else u32Data = i;
/*        if(i%2 == 0) u32Data =~i;   */
        dwOffset = 0;
	//GSK
	//        write_array[i]=u32Data;
        WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      }

       //GSK
       //       if(icheck ==1 ) {
       //        dwAddrSpace =cs_bar;
       //        u64Data =0;
       //        dwOffset = t_cs_reg;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        if(iprint==1 && j < 2) {
       //         u32Data=u64Data;
       //         printf (" transmitter status after send  = %8X \n",u32Data);
       //         u32Data=u64Data>>32;
       //         printf (" receiver status after send  = %8X \n",u32Data);
       //        }
       //       }
       //       nread = nwrite/2;
       //       if(nwrite%2 !=0) nread= nwrite/2 +1;
       //       for (i=0; i< nread; i++) {
       //        dwAddrSpace = tr_bar;
       //        u32Data = 0;
       //        dwOffset = 0;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        read_array[i*2] = u64Data;
       //        read_array[i*2+1] =u64Data>>32;
       //       }
       //       if(icheck == 1) {
       //        dwAddrSpace =cs_bar;
       //        u64Data =0;
       //        dwOffset = t_cs_reg;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        if(iprint==1 && j < 2) {
       //         u32Data=u64Data;
       //         printf (" transmitter status after read  = %8X \n",u32Data);
       //         u32Data=u64Data>>32;
       //         printf (" receiver status after read  = %8X \n",u32Data);
       //        }
       //        for (i=0; i< nwrite; i++) {
       //           if(iprint == 1 && j < 2) {
       //             if(i%8 ==0) printf("%d",i);
       //             printf("%9X",read_array[i]);
       //             if((i+1)%8 ==0) printf("\n");
       //           }
       //           if(read_array[i] != write_array[i]) printf("data mismatch, loop = %d word =%d read= %9X write = %9X\n",j,i,read_array[i],write_array[i]);
       //        }
       //        if((iprint ==1) && (nwrite%8 !=0) && j < 2) printf("\n");
       //       }
       //       if(j%100 ==0) printf(" loop = %d, nwrite= %d \n",j, nwrite);
       //       if(kwrite == -1) {
       //         nwrite =nwrite+1;
       //         if(nwrite > nwrite_max) nwrite =nwrite_min;
       //       }
    }

     /** end timer **/
    gettimeofday(&endtest1,NULL);
    seconds1 = endtest1.tv_sec;
    useconds1 = endtest1.tv_usec;
    
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds1,useconds1);

    seconds1 = endtest1.tv_sec - starttest1.tv_sec;
    useconds1 = endtest1.tv_usec - starttest1.tv_usec;
    
    mytime1 = seconds1*1000000. + useconds1*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime1);

    break;

  case 2:
    icheck=0;
    iprint=0;
    if(icheck == 1) printf(" data checking on \n");
    printf(" enter number of 32bits word send (< 20000), -1 for sequence test\n");
    scanf("%d",&kwrite);
    if(kwrite == -1) {
      printf("enter min number of word \n");
      scanf("%d",&nwrite_min);
      printf("enter max number of word \n");
      scanf("%d",&nwrite_max);
      nwrite=nwrite_min;
    }
    else nwrite = kwrite;

    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    printf(" DMA sequence -> 1 for DMA read after DMA write \n");
    printf("                 2 for Open DMA read and slave write \n");
    scanf("%d",&iseq);
    printf(" type 1 for incomplete DMA test \n");
    scanf("%d",&incomp);
    

/*** allocate the DMA buffer for send and receive **/
    dwDMABufSize = 80000;
    if(ifr ==0) {
      ifr=1;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
	printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
	printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
    }
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    dma_tr = dma_tr1;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
      dma_tr = dma_tr2;
    }

/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       /* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


       
       //GSK
       //rand() generation outside loop, for speed test

    buffp_send = pbuf_send;
    buffp_rec = pbuf_rec;
    //	 printf("%llX\n",buffp_send);
    //this is not actually necessary:
    int ig;
    for (ig=0; ig<nwrite; ig++) {
      if(irand == 1) *buffp_send++=rand();
      else *buffp_send++= ig;
      *buffp_rec++ =0x0;
    }
    //    }
    printf("\nGenerated data (words) for loop-back test\n");
    for (i=0; i<nwrite; i++) {
      k = i%8;
      if( k ==0) printf(" %3d", i);
      u32Data = *buffp_send++;
      printf(" %llX",u32Data);
      if(k == 7 ) printf("\n");
    }
    printf("\n");
    for (i=0; i<nwrite; i++) {
      k = i%8;
      if( k ==0) printf(" %3d", i);
      u32Data = *buffp_rec++;
      printf(" %llX",u32Data);
      if(k == 7 ) printf("\n");
    }


      /** begin timer **/
    struct timeval starttest, endtest;
    gettimeofday(&starttest,NULL);
    long mytime, seconds, useconds;
    seconds = starttest.tv_sec;
    useconds = starttest.tv_usec;
      
    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds,useconds);
      //get a fresh timestamp
    gettimeofday(&starttest,NULL);


    for (j=0; j<iloop; j++) {
/* set tx mode register */
      u32Data = 0xf0000008;
      dwOffset = tx_md_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** initialize the tranmission ***/
      u32Data = cs_init;
      dwOffset = t_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = t_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");
/** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      //GSK
       //       if(incomp ==1) u32Data = cs_start+nwrite*4+16; /* set up 4 less words to receive */
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up receiver \n");
       //       if(icheck == 1) {
       //         dwAddrSpace =cs_bar;
       //         u64Data =0;
       //         dwOffset = t_cs_reg;
       //         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //	 if(iprint==1 && j < 2) {
       //	   u32Data=u64Data;
       //	   printf (" transmitter status before send  = %8X \n",u32Data);
       //	   u32Data=u64Data>>32;
       //	   printf (" receiver status before send  = %8X \n",u32Data);
       //	 }
       //       }

      buffp_send = pbuf_send;
      buffp_rec = pbuf_rec;

       //GSK
       //do rand() generation outside the loop, and fill array(s) ahead of time
       //       for (i=0; i<nwrite+100; i++) {
       //	 if(irand == 1) *buffp_send++=rand();
       //	 else *buffp_send++= i;
       //	 *buffp_rec++ =0;
       //       }

/*
       buffp_rec = pbuf_rec;
       buffp_send = pbuf_send;

       for (i=0; i<nwrite; i++) {
	  k = i%8;
	  if(iprint ==1 && k ==0) printf(" %3d", i);
	  u32Data = *buffp_send++;
          if(iprint==1) printf(" %llX",u32Data);
	  if(k == 7 && iprint == 1) printf("\n");
       }
*/

//GSK iseq==1 by definition for this test
//       if(iseq == 1) {
/* set up transmitter DMA starting address */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      u32Data = nwrite*4;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

	/* synch cache */
      WDC_DMASyncCpu(pDma_send);

/* write this will start DMA */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_cntrl;
      u32Data = dma_tr+dma_3dw_trans;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/***    check to see if DMA is done or not **/
      idone =0;
      for (i=0; i<200; i++) {;
	dwAddrSpace =cs_bar;
	u64Data =0;
	dwOffset = cs_dma_cntrl;
	WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	  //GSK
	  //	  if(iprint ==1 && j < 2) printf(" send DMA status word %d %X \n", i, u32Data);
	if((u32Data & dma_in_progress) == 0) {
	    //GSK
	    //	    if(iprint == 1 && j < 2) printf(" send DMA complete %d \n", i);
	  idone =1;
	}
	if((u32Data & dma_in_progress) == 0) break;
      }
      if(idone == 0) {
	  //gsk
	  //	  printf(" sending dma is not finished \n");
	  //	  printf(" send DMA status word %d %X \n", i, u32Data);
	break;
      }
	//GSK
	//        if(icheck == 1) {
	//         dwAddrSpace =cs_bar;
	//         u64Data =0;
	//         dwOffset = t_cs_reg;
	//         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	//	 if(iprint==1 && j < 2) {
	//	   u32Data=u64Data;
	//	   printf (" transmitter status after send  = %8X \n",u32Data);
	//	   u32Data=u64Data>>32;
	//	   printf (" receiver status after send  = %8X \n",u32Data);
	//	 }
	//        }
	//GSK end if iseq==1
	//       }

 	/* synch DMA i/O cache **/
      WDC_DMASyncIo(pDma_send);

	//GSK iseq==1 for this test
	//       if (iseq != 1) {
	///** now write data to the transmiiter */
//        buffp_send = pbuf_send;
//        for (i=0; i< nwrite; i++) {
//         dwAddrSpace = tr_bar;
//         u32Data = *buffp_send++;
//         dwOffset = 0;
//         WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//        }
//       }


 /** set up the receiver DMA and first  **/

      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      u32Data = nwrite*4;
      if(incomp ==1) u32Data = cs_start+nwrite*4+16; /* set up 4 more words to receive */
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = cs_dma_cntrl;
      u32Data = dma_tr+dma_3dw_rec;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

	/* synch cache */
      WDC_DMASyncCpu(pDma_rec);



/***    check to see if DMA is done or not **/
      idone =0;
      for (i=0; i<200; i++) {;
	dwAddrSpace =cs_bar;
	u64Data =0;
	dwOffset = cs_dma_cntrl;
	WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	//GSK
	//	  if(iprint ==1 && j < 2) printf(" receive DMA status word %d %X \n", i, u32Data);
	if((u32Data & dma_in_progress) == 0) {
	  idone =1;
	  //GSK
	  //	    if(iprint == 1 && j < 2) printf(" receive DMA complete %d \n", i);
	}
	if((u32Data & dma_in_progress) == 0) break;
      }
      /* synch DMA i/O cache **/

      WDC_DMASyncIo(pDma_rec);

      if(idone == 0){
	 //gsk
	 //	 printf(" DMA is not done, %d, iloop = %d, nwrite= %d\n",i, j, nwrite);
	 //         if(incomp ==1) {
	 //           u32Data = dma_abort;
	 //           dwOffset = cs_dma_msi_abort;
	 //           dwAddrSpace =cs_bar;
	 //           WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
	 //           u32Data = 0;
	 //           dwOffset = cs_dma_msi_abort;
	 //           dwAddrSpace =cs_bar;
	 //           WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
	 //           dwAddrSpace =cs_bar;
	 //	   dwOffset = cs_dma_cntrl;
	 //           WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	 //	   if(iprint ==1 && j < 2) printf(" receive DMA status word after abort %d %X \n", i, u32Data);
	 //           dwAddrSpace =cs_bar;
	 //           dwOffset = t_cs_reg;
	 //           WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	 //	   if(iprint==1 && j < 2) {
	 //	     u32Data=u64Data;
	 //	     printf (" transmitter status after abort  = %8X \n",u32Data);
	 //	     u32Data=u64Data>>32;
	 //	     printf (" receiver status after abort  = %8X \n",u32Data);
	 //	   }
	 //         }
	 //         else 
	break;
      }

      if(idone == 1) {
	buffp_rec = pbuf_rec;
	buffp_send = pbuf_send;
	
	 //GSK
	 //	 for (i=0; i<nwrite; i++) {
	 //	   k = i%8;
	 //	  if(iprint ==1 && k ==0 && j < 2) printf(" %3d", i);
	 //	  u32Data = *buffp_rec++;
	 //	  u32Data_send = *buffp_send++;
	 //	  if((u32Data != u32Data_send) && (icheck ==1) ) printf(" %d, %d, %11x, %11x\n", j,i,u32Data_send,u32Data);
	 //	  if(iprint==1 && j < 2) printf(" %llX",u32Data);
	 //	  if(k == 7 && iprint == 1 && j < 2) printf("\n");
	 //	 }
	 //	 if(k !=7 && iprint ==1 && j < 2) printf("\n");
      }
       //       if(j%100 ==0) printf(" loop = %d, nwrite= %d \n",j, nwrite);

       //GSK
       //       if(kwrite == -1) {
       //        nwrite =nwrite+1;
       //        if(nwrite > nwrite_max) nwrite =nwrite_min;
       //       }
    }

      /** end timer **/
    gettimeofday(&endtest,NULL);
    seconds = endtest.tv_sec;
    useconds = endtest.tv_usec;
      
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds,useconds);

    seconds = endtest.tv_sec - starttest.tv_sec;
    useconds = endtest.tv_usec - starttest.tv_usec;

    mytime = seconds*1000000. + useconds*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime);

    break;
    
  case 3:
    printf("enter number words per packet \n");
    scanf("%d",&nwrite);
    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
    }

/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

    printf("\n\nWriting to file: -----------> test.bin\n");

    FILE * pFile;
    pFile = fopen("test.bin","w");
    if (pFile==NULL){
      printf("\nFile NOT open; Exiting.\n");
      break;
    }

    //first write some stuff

/* set tx mode register */
    u32Data = 0xf0000fff;
    dwOffset = tx_md_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** initialize the tranmission ***/
    u32Data = cs_init;
    dwOffset = t_cs_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
    dwAddrSpace = cs_bar;
    u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
    dwOffset = t_cs_reg;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");
/** initialize the receiver ***/
    u32Data = cs_init;
    dwOffset = r_cs_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** start the receiver **/
    dwAddrSpace = cs_bar;
    u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
    dwOffset = r_cs_reg;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


    //now write to transmitter ---> edit from this point on

    u32Data = 0x3333;
    for (i=0; i< nwrite; i++) {
      dwAddrSpace = tr_bar;
      dwOffset = 0;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    }


    //receiver read and write to file

    //loop read



      /** begin timer **/
    struct timeval starttest2, endtest2;
    gettimeofday(&starttest2,NULL);
    long mytime2, seconds2, useconds2;
    seconds2 = starttest2.tv_sec;
    useconds2 = starttest2.tv_usec;
      
    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds2,useconds2);
      //get a fresh timestamp
    gettimeofday(&starttest2,NULL);




      /** end timer **/
    gettimeofday(&endtest2,NULL);
    seconds2 = endtest2.tv_sec;
    useconds2 = endtest2.tv_usec;
      
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds2,useconds2);

    seconds2 = endtest2.tv_sec - starttest2.tv_sec;
    useconds2 = endtest2.tv_usec - starttest2.tv_usec;
      
    mytime2 = seconds2*1000000. + useconds2*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime2);
    

    fclose(pFile);

    break;

  }

}
  
static int dcm2_fpga_boot(WDC_DEVICE_HANDLE hDev, int imod, int fpga_t, int iprint)
{
  //    printf("LINE: %d\n", __LINE__);

#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

  //    printf("LINE: %d\n", __LINE__);

    static DWORD dwAddrSpace;

    static UINT32 u32Data;
    static unsigned short u16Data;
    static unsigned long long u64Data;
    static DWORD dwOffset;
    static long ichip;
    unsigned short *buffp;

    //    printf("LINE: %d\n", __LINE__);

/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    static UINT32 i,j,k,ifr,nread,iwrite,ik,istop,newcmd,ifr_readback;
    static UINT32 send_array[4000],read_array[4000];
    DWORD dwDMABufSize;
    PVOID pbuf;
    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck;
    UINT32 buf_send[2000];
    static int   count,num,counta,nword,ireadback,nloop;
    static int   ij,nsend,iloop,inew,idma_readback;
    unsigned char    charchannel;
    unsigned char    carray[4000];
    UINT32 *px,*py;

    //printf("LINE: %d\n", __LINE__);

    FILE *inpf;


    ifr_readback=0;
    ifr=0;
    iwrite =0;
    //    iprint =0;
    icheck =0;
    istop=0;
    ireadback =1;
    idma_readback=1;
    nsend = 1000;

    //printf("LINE: %d\n", __LINE__);

    px = &buf_send;
    py = &read_array;
    ichip=6;

/** initialize **/

//    printf("LINE: %d\n", __LINE__);

    buf_send[0]=0x0;
    buf_send[1]=0x0;
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
/** test command 1 ***/
    if (ifr == 0) {
       ifr=1;
       buf_send[0]=(imod <<11)+ (ichip << 8) + poweron;
       buf_send[1]=0x1111;
       i= 1;
       k= 2;
/** try to cover  1.5*100ms */
       i = pcie_send(hDev, i, k, px);
       for (k=0; k<150000000; k++) {
            ik=k+1;
            i=ik*ik;
       }
    }
    iloop=1;
    ik=configure_s60;
    if(fpga_t == 2) {
     iloop=4;
     ik=configure_s30;
    }
    buf_send[0]=(imod <<11)+ (ichip << 8) + ik;
    buf_send[1]=0x5555aaaa;
    i= 1;
    k= 2;
    i = pcie_send(hDev, i, k, px);
/** wait for at least 100us **/

//    printf("LINE: %d\n", __LINE__);

    for (k=0; k<1000000; k++) {
     ik=k+1;
     i=ik*ik;
    }

    //    printf("LINE: %d\n", __LINE__);

    if(ireadback == 1) {
        buf_send[0]=(imod <<11)+ (ichip << 8) + loopback;
        i= 1;
        k= 1;
        i = pcie_send(hDev, i, k, px);
    }
    //    printf("LINE: %d\n", __LINE__);

    for (j=0; j<iloop; j++) {
      //      printf("LINE, j: %d, %d\n", __LINE__, j);

       if(fpga_t == 2)
//         inpf = fopen("/home/chi/dcm2_compress.rbf","r");
         inpf = fopen("/home/phnxrc/cfmcginn/dcm2_compress_adctest.rbf","r");
       //CFM 2021.05.10: previously was /home/chi/dcm2_780_boot_adctest
       else
          inpf = fopen("/home/phnxrc/cfmcginn/eventmerge_v3.rbf","r");
       //CFM 2021.05.10: previously was /home/chi/dcm2_1152_boot_adctest

        /* read data as characters (28941) */

       if(iprint == 1) printf("LINE, j: %d, %d (fpga_t=%d)\n", __LINE__, j, fpga_t);
       count = 0;
       counta= 0;
       while (fread(&charchannel,sizeof(char),1,inpf)==1) {

         carray[count] = charchannel;
         count++;
         counta++;
         if((count%(nsend*2)) == 0){

           buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16);
           send_array[0] =buf_send[0];
/*           printf(" counta = %d, first word = %x, %x, %x \n",counta,buf_send[0], carray[0], carray[1]);  */
           for (ij=0; ij< nsend; ij++) {
            buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
            send_array[ij+1] = buf_send[ij+1];
           }
           nword =nsend+1;

           if(ireadback == 1) {
            if(idma_readback == 1) {
	      if(iprint == 1) printf("BEGIN IDMA READBACK: L%d\n", __LINE__);
              i=pcie_rec(hDev,1,1,nword,iprint,py); /** set up readback  **/ //CFM EDIT 2021.05.10: 5th position from 0 to 1 for additional printouts
	      if(iprint == 1) printf("END IDMA READBACK: L%d\n", __LINE__);
            }
            else {
              if(ifr_readback ==0) {
 //              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
               dwAddrSpace =2;
               u32Data = 0x20000000;
               dwOffset = 0x1c;
               WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
               if(iprint == 1) printf(" receiver inited \n");
              }
              ifr_readback =1;
              dwAddrSpace =2;
              u32Data = 0x40000000+nword*4;
              dwOffset = 0x1c;
              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
              dwAddrSpace =2;
              u64Data =0;
              dwOffset = 0x18;
              WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
              if(iprint==1) printf (" status word before send = %llX \n",u64Data);
            }
           }
	 
           i =1;
           i = pcie_send(hDev, i, nword, px);
//  50ns per byt, 2000 bytes*50ns*2 = 200 microsec
           if(ireadback != 1){
            for (k=0; k<200000; k++) {    /* 100000 for 100 microsec */
             ik=k+1;
             i=ik*ik;
            }
           }
	 
           if(ireadback == 1) {
            if(idma_readback == 1) {
	      if(iprint == 1) printf("BEGIN IDMA READBACK: L%d\n", __LINE__);
              i=pcie_rec(hDev,1,2,nword,iprint,py); /** set up readback  **/ //CFM EDIT 2021.05.10: 5th position from 0 to 1 for additional printouts
	      //	      return 0;
	      if(iprint == 1) printf("END IDMA READBACK: L%d\n", __LINE__);
            }
            else {
             dwAddrSpace =2;
             u64Data =0;
             dwOffset = 0x18;
             WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
             if(iprint == 1) printf (" status word before read = %llX \n",u64Data);
             k = nword%2;
             ik= nword/2+1;
             if(k == 0) ik = nword/2;
             for (i=0; i<ik; i++) {
               dwAddrSpace =0;
               u64Data =0;
               dwOffset = 0x0;
               WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
               read_array[i*2] = u64Data;
               read_array[i*2+1] = u64Data>>32;
             }
             dwAddrSpace =2;
             u64Data =0;
             dwOffset = 0x18;
             WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
             if(iprint ==1 )printf (" status word after read = %llX \n",u64Data);
//           printf (" status word after read = %llX \n",u64Data);
            }
            for (i=0; i< nword; i++) {
               if(iprint ==1 ) {
                if(i%8 == 0) printf("%d", i);
                printf("%9X",read_array[i]);
                if(((i+1)%8) ==0) printf("\n");
               }
               if(read_array[i] != send_array[i]) {
		 //CFM EDIT: 2021.05.10, commented out below line
                 //printf("\n counta=%d, i=%d, send =%9X read= %9X \n",counta,i,send_array[i],read_array[i]);
               }
            }
            if(iprint == 1) {
               if(nword%8 !=0) printf("\n");
            }
           }
/*           }  */
           count=0;
//           printf ("enter something to continue\n");
//           scanf("%d",&k);

         }
       }
       
       if(iprint) printf("LINE: %d\n", __LINE__);

       if (feof(inpf)) {
        printf("You have reached the end-of-file word count= %d %d\n", counta, count);
        buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16);
        if ( count > 1) {
           if( ((count-1)%2) ==0) {
             ik =(count-1)/2;
           }
           else {
             ik =(count-1)/2+1;
           }
           printf("ik= %d\n",ik);
           for (ij=0; ij<ik;ij++){
            buf_send[ij+1] = carray[2*ij+1]+(carray[2*ij+2]<<16);
            send_array[ij+1] = buf_send[ij+1];
           }
        }
        else ik=1;
/*
           for (ij=ik-10; ij< ik; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }
*/
        if(j == iloop-1)
         nword =ik+5;
        else
         nword =ik+1;
        if(ireadback == 1) {
//              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
            if(idma_readback == 1) {
	      //	      printf("BEGIN IDMA READBACK: L%d\n", __LINE__);
              i=pcie_rec(hDev,1,1,nword,0,py); /** set up readback  **/ //CFM EDIT 2021.05.10: 5th position from 0 to 1 for additional printouts
	      //	      printf("END IDMA READBACK: L%d\n", __LINE__);
            }
            else {
              dwAddrSpace =2;
              u32Data = 0x20000000;
              dwOffset = 0x1c;
              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
              dwAddrSpace =2;
              u32Data = 0x40000000+nword*4;
              dwOffset = 0x1c;
              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
              dwAddrSpace =2;
              u64Data =0;
              dwOffset = 0x18;
              WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
              if(iprint==1) printf (" status word before send = %llX \n",u64Data);
            }
        }
	if(iprint == 1) printf("LINE: %d\n", __LINE__);

        i=1;
        i = pcie_send(hDev, i, nword, px);
//  50ns per byt, 2000 bytes*50ns*2 = 200 microsec
//           if(ireadback != 1){
            for (k=0; k<200000; k++) {    /* 100000 for 100 microsec */
             ik=k+1;
             i=ik*ik;
            }
//           }
        if(ireadback == 1) {
         if(idma_readback == 1) {
	   //	   printf("BEGIN IDMA READBACK: L%d\n", __LINE__);
	   i=pcie_rec(hDev,1,2,nword,0,py); /** set up readback  **/ //CFM EDIT 2021.05.10: 5th position from 0 to 1 for additional printouts
	   //	   printf("END IDMA READBACK: L%d\n", __LINE__);
         }
         else {
          dwAddrSpace =2;
          u64Data =0;
          dwOffset = 0x18;
          WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
          if(iprint == 1) printf (" status word before read = %llX \n",u64Data);
          k = nword%2;
          ik= nword/2+1;
          if(k == 0) ik = nword/2;
          for (i=0; i<ik; i++) {
             dwAddrSpace =0;
             u64Data =0;
             dwOffset = 0x0;
             WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
             read_array[i*2] = u64Data;
             read_array[i*2+1] = u64Data>>32;
          }
          if(iprint ==1 )printf (" status word after read = %llX \n",u64Data);
         }
         for (i=0; i< nword; i++) {
          if(iprint ==1 ) {
            if(i%8 == 0) printf("%d", i);
            printf("%9X",read_array[i]);
            if(((i+1)%8) ==0) printf("\n");
          }
          if(read_array[i] != send_array[i]) {
            printf("\n counta=%d, i=%d, send =%9X read= %9X \n",counta,i,send_array[i],read_array[i]);
          }
         }
        }
        fclose(inpf);
//           printf ("enter something to continue\n");
//           scanf("%d",&k);
       }
    }
//   turn off readback
    if(iprint == 1) printf("LINE: %d\n", __LINE__); 
    if(ireadback == 1) {
        buf_send[0]=(imod <<11)+ ((ichip+1) << 8) + loopback;
        i= 1;
        k= 1;
        i = pcie_send(hDev, i, k, px);
    }
    if(iprint == 1) printf("LINE: %d\n", __LINE__); 

/*** reack back status ***/


    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    dwAddrSpace =2;
    u32Data = 0x20000000;
    dwOffset = 0x1c;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    if(iprint == 1) printf(" receiver inited \n");
    dwAddrSpace =2;
    u32Data = 0x40000000+4;
    dwOffset = 0x1c;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    dwAddrSpace =2;
    u64Data =0;
    dwOffset = 0x18;
    WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    printf (" status word in the status read = %llX \n",u64Data);

    buf_send[0]=(imod <<11)+ (ichip << 8) + rdstatus;  /* turn on status read*/
    buf_send[1]=0x5555aaaa;
    i= 1;
    k= 1;
    i = pcie_send(hDev, i, k, px);
//
//    wait for 10 microsec
//
    for (k=0; k<10000; k++) {    /* 100000 for 100 microsec */
      ik=k+1;
      i=ik*ik;
    }

    if(iprint == 1) printf("LINE: %d\n", __LINE__); 

    dwAddrSpace =2;
    u64Data =0;
    dwOffset = 0x18;
    WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    printf (" status word in the status read = %llX \n",u64Data);

    dwAddrSpace =0;
    u64Data =0;
    dwOffset = 0x0;
    WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    u32Data = u64Data;
    if(fpga_t ==1)
       printf(" status word from FPGA 5 = %11X \n", u32Data);
    else
       printf(" status word from FPGA 1-4 = %11X \n", u32Data);
    return i;
}


static int eprom_readback(WDC_DEVICE_HANDLE hDev, int imod, int mode, UINT32 *buff_rec)
{

#define  sp_adc_readback_sub        4
#define  sp_adc_readback_transfer   1
#define  sp_adc_readback_read       2
#define  sp_adc_readback_status     3

#define  sp_adc_slowcntl_sub        1

#define  sp_adc_eprom_addr_l       50
#define  sp_adc_eprom_addr_h       51
#define  sp_adc_eprom_wdata        52
#define  sp_adc_eprom_w_pulse      53
#define  sp_adc_eprom_read_pulse   54
#define  sp_adc_eprom_bulk_erase_p 55
#define  sp_adc_eprom_read_status_p  56
#define  sp_adc_eprom_read_id_p    57
#define  sp_adc_eprom_reset_p      58

    int ichip,ich,i,k, nword, iprint;
    UINT32 buf_send[40000];
    static UINT32 send_array[40000];
    static UINT32 read_array[10];
    UINT32 *px;
    UINT32 *py;



    py = &read_array;
    px = &buf_send;
    iprint =0;

    nword = 3;
//
//         status read is not usefull unless busy is not low
//
    ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_read_status_p + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1);
//    printf(" eprom read status send \n");
//    scanf("%d", &i);


    ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
    buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send_1(hDev, i, k, px);
//    printf(" eprom read back command send \n");
//    scanf("%d", &i);
//
    i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
    ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send_1(hDev, i, k, px);
    py = &read_array;
    i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//       printf("module %d address %d receive data word = %x, %x \n", imod, ia, read_array[0], read_array[1]);
//    printf(" data = %x \n", read_array[1]);
    i= read_array[1];
//
//  sort of strange, lazy to change other code
//
    for (k=0; k< nword; k++) {
     *buff_rec++ = read_array[k];
    }

    return i;
}

static int adc_setup(WDC_DEVICE_HANDLE hDev, int imod, int iprint)
{
#define  sp_cntrl_timing            3
#define  sp_cntrl_init           0x30
#define  sp_cntrl_reset          0x28
#define  sp_cntrl_l1             0x24
#define  sp_cntrl_pulse          0x22



#define  sp_adc_readback_sub        4
#define  sp_adc_readback_transfer   1
#define  sp_adc_readback_read       2
#define  sp_adc_readback_status     3
#
#define  sp_adc_input_sub           2
#define  sp_adc_slowcntl_sub        1

#define  sp_adc_l1_delay            1
#define  sp_adc_evt_sample          2

#define  sp_adc_rd_link             3
#define  sp_adc_rd_cntrl            4

#define  sp_adc_sel_l1              5
#define  sp_adc_sel_pulse           6
#define  sp_adc_sel_test_trig       7

#define  sp_adc_sel_linux_rxoff     8

#define  sp_adc_u_adc_align        10
#define  sp_adc_l_adc_align        11
#define  sp_adc_pll_reset          12

#define  sp_adc_rstblk             13
#define  sp_adc_test_pulse         14

#define  sp_adc_dpa_reset          15

#define  sp_adc_spi_add            20
#define  sp_adc_spi_data           30

#define  sp_adc_lnk_tx_dreset      20
#define  sp_adc_lnk_tx_areset      21
#define  sp_adc_trg_tx_dreset      22
#define  sp_adc_trg_tx_areset      23
#define  sp_adc_lnk_rx_dreset      24
#define  sp_adc_lnk_rx_areset      25

#define  sp_adc_link_mgmt_reset    26
#define  sp_adc_link_conf_w        27
#define  sp_adc_link_conf_add      30
#define  sp_adc_link_conf_data_l   31
#define  sp_adc_link_conf_data_u   32

#define  sp_xmit_lastmod            1
#define  sp_xmit_rxanalogreset      2
#define  sp_xmit_rxdigitalreset     3
#define  sp_xmit_init               4

#define  sp_xmit_sub                1


    int ichip,ich,i,k;
    UINT32 buf_send[40000];
    UINT32 *px;



    px = &buf_send;
    ichip = sp_adc_input_sub ;   // controller data go to ADC input section
    for (ich=0; ich<8; ich++) {

//    set spi address

     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
     if(iprint==1) {
       printf(" set spi address to channel %d, module %d\n", ich, imod);
       printf(" power reset \n");
//       scanf("%d",&is);
     }

//      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_)+((is & 0xf)<<16); //set spi address
//      i=1;
//        k=1;
//        i = pcie_send(hDev, i, k, px);
//       printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
//        ichip=5;
//
//
//     power reset the ADC
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0x8))+((0x03)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x8, data =0x03;
//

     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
     if(iprint==1) {
       printf(" set spi address to channel %d, module %d\n", ich, imod);
       printf(" remove power reset \n");
//       scanf("%d",&is);
     }

//
//     reove power reset
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0x8))+((0x00)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x8, data =0x00;
//

     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//     reset ADC
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0x0))+((0x3c)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x0, data =0x3c;
//

     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//       if(ich ==7) {
     if(iprint ==1) printf(" send last command ich= %d module %d\n", ich, imod);
//        scanf("%d",&is);
//       }
//
//    set LVDS termination  set addess 0x15  to 1 to 2x drive
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<12)+(0x15))+((0x20)<<24)+((0x0)<<16);   // 100 ohms termation
//     buf_send[1]=(((0x0)<<12)+(0x15))+((0x0)<<24)+((0x0)<<16);   // no ohms termation, 1x drive
//     buf_send[1]=(((0x0)<<12)+(0x15))+((0x1)<<24)+((0x0)<<16);   // no ohms termation, 2x drive
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x15, data =0x1;
//
     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//       printf(" termination set, type 1 to continue \n");
//       scanf("%d",&i);

//
//    set fix pattern  0xa = sync pattern
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xa;
//

     i=1;
     k=2;
//      i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//       printf(" fix pattern set type 1 to continue \n");
//       scanf("%d",&i);
    }


    usleep(100);
//
//    set up for ADC alignment
//
    ichip = sp_adc_slowcntl_sub ;   // controller data go to ADC input section
//
//       pll reset
//
    if(iprint == 1)printf(" send pll reset\n");
//      scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_pll_reset + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);

//
//       DPA reset
//
    if(iprint == 1) printf(" send ADC DPA reset module %d\n", imod);
//    scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_dpa_reset + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);

//
//       upper ADC alignment
//
    if(iprint==1) printf(" send upper channel align module %d \n", imod);
//    scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_u_adc_align + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);
//
//       lower ADC alignment
//
    if(iprint == 1){
      printf(" send lower channel align module %d\n", imod);
    }

//      scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l_adc_align + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);
//
//
//

   ichip = sp_adc_input_sub ;   // controller data go to ADC input section
   for (ich=0; ich<8; ich++) {
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(100);
//
//    output offset binary code
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<12)+(0x14))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x14, data =0x0;
//

    i=1;
    k=2;

    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us

//
//    unset fix pattern  0x0 for normal data taking   --- set to test condition
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0x0;
//

    i=1;
    k=2;

    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
   }
//
//  test routine
//
//    set spi address

    ich =0;
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
    i= 1;
    k= 1;
//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);
//
//    remove channel H,G,F,E from the selection list
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x4))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x4, data =0x0;
//

    i=1;
    k=2;

//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
//
//    only keep channel a from the selection list
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x5))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x5, data =0x1;
//

    i=1;
    k=2;

///    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
//
//    set fix pattern  0xa = sync pattern
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0xd))+((0xc)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xc;
//

     i=1;
     k=2;
//      i = pcie_send(hDev, i, k, px);
//     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//    restore selection list 1
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x4))+((0xf)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x4, data =0x0;
//

    i=1;
    k=2;

//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
//
//    restore selection list 2
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x5))+((0x3f)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x5, data =0x1;
//

    i=1;
    k=2;

//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us



    return i;
}


static int adc_setup_debug(WDC_DEVICE_HANDLE hDev, int imod, int iprint)
{
#define  sp_cntrl_timing            3
#define  sp_cntrl_init           0x30
#define  sp_cntrl_reset          0x28
#define  sp_cntrl_l1             0x24
#define  sp_cntrl_pulse          0x22



#define  sp_adc_readback_sub        4
#define  sp_adc_readback_transfer   1
#define  sp_adc_readback_read       2
#define  sp_adc_readback_status     3
#
#define  sp_adc_input_sub           2
#define  sp_adc_slowcntl_sub        1

#define  sp_adc_l1_delay            1
#define  sp_adc_evt_sample          2

#define  sp_adc_rd_link             3
#define  sp_adc_rd_cntrl            4

#define  sp_adc_sel_l1              5
#define  sp_adc_sel_pulse           6
#define  sp_adc_sel_test_trig       7

#define  sp_adc_sel_linux_rxoff     8

#define  sp_adc_u_adc_align        10
#define  sp_adc_l_adc_align        11
#define  sp_adc_pll_reset          12

#define  sp_adc_rstblk             13
#define  sp_adc_test_pulse         14

#define  sp_adc_dpa_reset          15

#define  sp_adc_spi_add            20
#define  sp_adc_spi_data           30

#define  sp_adc_lnk_tx_dreset      20
#define  sp_adc_lnk_tx_areset      21
#define  sp_adc_trg_tx_dreset      22
#define  sp_adc_trg_tx_areset      23
#define  sp_adc_lnk_rx_dreset      24
#define  sp_adc_lnk_rx_areset      25

#define  sp_adc_link_mgmt_reset    26
#define  sp_adc_link_conf_w        27
#define  sp_adc_link_conf_add      30
#define  sp_adc_link_conf_data_l   31
#define  sp_adc_link_conf_data_u   32

#define  sp_xmit_lastmod            1
#define  sp_xmit_rxanalogreset      2
#define  sp_xmit_rxdigitalreset     3
#define  sp_xmit_init               4

#define  sp_xmit_sub                1


    int ichip,ich,i,k, is;
    UINT32 buf_send[40000];
    UINT32 *px;



    px = &buf_send;
    ichip = sp_adc_input_sub ;   // controller data go to ADC input section

    for (ich=0; ich<8; ich++) {

//    set spi address

     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
     if(iprint==1) printf(" set spi address to channel %d, module %d\n", ich, imod);
//       scanf("%d",&is);

//
//  once per chip
//
     if(iprint==1) {
      printf(" ADC power reset \n");
      scanf("%d",&is);
     }


//
//     power reset the ADC -- Digital reset
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0x8))+((0x03)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x8, data =0x03;
//

     i=1;
     k=2;
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
     if(iprint==1) {
      printf(" remove ADC power reset \n");
      scanf("%d",&is);
     }
//
//     reove power reset
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0x8))+((0x00)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x8, data =0x00;
//

     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//
//
     if(iprint==1) {
      printf(" ADC reset and SPI mode \n");
      scanf("%d",&is);
     }
//
//     reset ADC
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0x0))+((0x3c)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x0, data =0x3c;
//

     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
     if(iprint==1) {
      printf(" set output 100 ohms termination \n");
      scanf("%d",&is);
     }

//
//    set LVDS termination  set addess 0x15  to 1 to 2x drive
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<12)+(0x15))+((0x20)<<24)+((0x0)<<16);   // 100 ohms termation
//     buf_send[1]=(((0x0)<<12)+(0x15))+((0x0)<<24)+((0x0)<<16);   // no ohms termation, 1x drive
//     buf_send[1]=(((0x0)<<12)+(0x15))+((0x1)<<24)+((0x0)<<16);   // no ohms termation, 2x drive
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x15, data =0x1;
//
     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us


//
//       if(ich ==7) {
     if(iprint ==1) {
       printf(" send last command ich= %d module %d\n", ich, imod);
       scanf("%d",&is);
     }
//       }

//       printf(" termination set, type 1 to continue \n");
//       scanf("%d",&i);

//
//    set fix pattern  0xa = sync pattern
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xa;
//

     i=1;
     k=2;
//      i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//       printf(" fix pattern set type 1 to continue \n");
//       scanf("%d",&i);
    }


    usleep(100);
//
//    set up for ADC alignment
//
    ichip = sp_adc_slowcntl_sub ;   // controller data go to ADC input section
//
//       pll reset
//
    if(iprint == 1)printf(" send pll reset\n");
//      scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_pll_reset + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);

//
//       DPA reset
//
    if(iprint == 1) printf(" send ADC DPA reset module %d\n", imod);
//    scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_dpa_reset + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);

//
//       upper ADC alignment
//
    if(iprint==1) printf(" send upper channel align module %d \n", imod);
//    scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_u_adc_align + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);
//
//       lower ADC alignment
//
    if(iprint == 1){
      printf(" send lower channel align module %d\n", imod);
    }
//      scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l_adc_align + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);
//
//
//

   ichip = sp_adc_input_sub ;   // controller data go to ADC input section
   for (ich=0; ich<8; ich++) {
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(100);
//
//    output offset binary code
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<12)+(0x14))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x14, data =0x0;
//

    i=1;
    k=2;

    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us

//
//    unset fix pattern  0x0 for normal data taking   --- set to test condition
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0x0;
//

    i=1;
    k=2;

    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
   }
//
//  test routine
//
//    set spi address

    ich =0;
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
    i= 1;
    k= 1;
//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);
//
//    remove channel H,G,F,E from the selection list
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x4))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x4, data =0x0;
//

    i=1;
    k=2;

//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
//
//    only keep channel a from the selection list
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x5))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x5, data =0x1;
//

    i=1;
    k=2;

///    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
//
//    set fix pattern  0xa = sync pattern
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0xd))+((0xc)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xc;
//

     i=1;
     k=2;
//      i = pcie_send(hDev, i, k, px);
//     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//    restore selection list 1
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x4))+((0xf)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x4, data =0x0;
//

    i=1;
    k=2;

//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
//
//    restore selection list 2
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x5))+((0x3f)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x5, data =0x1;
//

    i=1;
    k=2;

//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us



    return i;
}


static int adc_testram_load(WDC_DEVICE_HANDLE hDev, int imod, int idelay)
{
#define  sp_cntrl_timing            3
#define  sp_cntrl_init           0x30
#define  sp_cntrl_reset          0x28
#define  sp_cntrl_l1             0x24
#define  sp_cntrl_pulse          0x22



#define  sp_adc_readback_sub        4
#define  sp_adc_readback_transfer   1
#define  sp_adc_readback_read       2
#define  sp_adc_readback_status     3
#
#define  sp_adc_input_sub           2
#define  sp_adc_slowcntl_sub        1

#define  sp_adc_l1_delay            1
#define  sp_adc_evt_sample          2

#define  sp_adc_rd_link             3
#define  sp_adc_rd_cntrl            4

#define  sp_adc_sel_l1              5
#define  sp_adc_sel_pulse           6
#define  sp_adc_sel_test_trig       7

#define  sp_adc_sel_linux_rxoff     8

#define  sp_adc_u_adc_align        10
#define  sp_adc_l_adc_align        11
#define  sp_adc_pll_reset          12

#define  sp_adc_rstblk             13
#define  sp_adc_test_pulse         14

#define  sp_adc_dpa_reset          15

#define  sp_adc_spi_add            20
#define  sp_adc_spi_data           30

#define  sp_adc_testram_load_ch     4
#define  sp_adc_testram_load_data   5
#define  sp_adc_testram_trig_delay  7

#define  sp_adc_lnk_tx_dreset      20
#define  sp_adc_lnk_tx_areset      21
#define  sp_adc_trg_tx_dreset      22
#define  sp_adc_trg_tx_areset      23
#define  sp_adc_lnk_rx_dreset      24
#define  sp_adc_lnk_rx_areset      25

#define  sp_adc_link_mgmt_reset    26
#define  sp_adc_link_conf_w        27
#define  sp_adc_link_conf_add      30
#define  sp_adc_link_conf_data_l   31
#define  sp_adc_link_conf_data_u   32

#define  sp_xmit_lastmod            1
#define  sp_xmit_rxanalogreset      2
#define  sp_xmit_rxdigitalreset     3
#define  sp_xmit_init               4

#define  sp_xmit_sub                1


    int ichip,ich,i,k,idata, iad;
    UINT32 buf_send[40000];
    UINT32 *px;



    px = &buf_send;
    ichip = sp_adc_input_sub ;   // controller data go to ADC input section

    for (ich =0; ich< 64; ich++) {
     if(ich== 0)  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (64<<16);  // set channel 0 to 64
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (ich<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1);
     printf(" load testram ch = %d, module %d\n", ich, imod);
//     scanf("%d", &i);
     for (iad =0; iad<512 ; iad++) {
       idata =  ich*128 + iad;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_data + (idata<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1);
//      printf(" load testram ch = %d, address %d\n", ich, iad);
//      scanf("%d", &i);
     }
    }

    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_trig_delay + (idelay<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1);




    return i;
}



static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = pbuf_send;
    }
    iprint =0;
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100000;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }

static int pcie_send_1(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = pbuf_send;
    }
    iprint =0;
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =4;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00200000;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }


 static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint = ipr_status;
    int icomp;
    static int ifr=0;

    //    printf("LINE: %d\n", __LINE__);


    if(ifr == 0){
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if(WD_STATUS_SUCCESS != dwStatus){
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint = ipr_status; //CFM EDIT (2021.05.21): WAS HARDCODED AS 0 BUT GAVE IT SHARED ipr_status
//    printf(" istart = %d\n", istart);
//   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)){
// initalize transmitter mode register...
//     printf(" nword = %d \n",nword);
/*
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before set = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }
*/

//    printf("LINE: %d\n", __LINE__);

     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =2;
     u32Data = 0x40000000+nword*4;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x, %d \n",(u64Data>>32), (u64Data &0xffff), __LINE__);
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/2+1;
      if(nword%2 == 0) nread = nword/2;
      for (j=0; j< nread; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x, %d \n",(u64Data>>32), (u64Data &0xffff), __LINE__);
      }
      return 0;
     }

     //    printf("LINE: %d\n", __LINE__);

     if( mode ==1 ){
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1 && i%1 == 0) printf(" DMA status read %d %X \n", i, u32Data); // CFM Edit 2021.05.11 - set to only print on every 1000th event
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }

      if(icomp == 0) {
        printf("DMA timeout, %d\n", __LINE__);
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }

    //    printf("LINE: %d\n", __LINE__);

    return 0;
    }


 static int pcie_rec_2(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
/* nword assume to be number of 16 bits word */

#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp,is;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
 //   printf(" istart = %d\n", istart);
 //   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = tx_mode_reg;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(mode == 1) {
/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     }
     /*initialize the receiver */
     dwAddrSpace =cs_bar;
     u32Data = cs_init;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =cs_bar;
     u32Data = cs_start+nword*4;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =cs_bar;
      u64Data =0;
      dwOffset = t2_cs_reg;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/2+1;
      if(nword%2 == 0) nread = nword/2;
      for (j=0; j< nread; j++) {
       dwAddrSpace =t2_tr_bar;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t2_cs_reg;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){            ///**** not up to date ****///
      nread = nword*2;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
//      dwAddrSpace =2;
//      dwOffset = 0xc;
//      u32Data = 0x00100040;
//      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = cs_dma_cntrl;
      is = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      if(is == 0) {
//**         if(iwrite !=1 ) printf(" use 3dw \n");
       u32Data = dma_tr2+dma_3dw_rec;
      }
      else {
       u32Data = dma_tr2+dma_4dw_rec;
//**        if(iwrite !=1 ) printf(" use 4dw \n");
      }
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xc;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1 && i%1000 == 0) printf(" DMA status read %d %X \n", i, u32Data); // CFM Edit 2021.05.11 - set to only print on every 1000th event
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
//          if(iprint == 1) printf(" DMA complete %d \n", i);
          printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout, %d\n", __LINE__);
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }



 static int pcie_rec_16b(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
//    printf(" istart = %d\n", istart);
//   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
//     printf(" nword = %d \n",nword);
/*
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before set = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }
*/
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =2;
     u32Data = 0x40000000+nword*2;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/4+1;
      if(nword%2 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout, %d\n", __LINE__);
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }


static int pcie_send_6_1(WDC_DEVICE_HANDLE hDev2, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = pbuf_send;
    }
    iprint =1;
    if(iprint ==1) printf(" enter pcie_send_6_1 \n");
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && (iprint == 1)) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100000;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) &&( iprint == 1)) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }


 static int pcie_rec_6_1(WDC_DEVICE_HANDLE hDev2, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
 //   printf(" istart = %d\n", istart);
 //   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
 //    dwAddrSpace =2;
 //    u32Data = 0xf0000008;
 //    dwOffset = 0x28;
 //    WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =2;
     u32Data = 0x40000000+nword*2;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read hDev2 = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/4+1;
      if(nword%4 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev2,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read hDev2 = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){            ///**** not up to date ****///
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout, %d\n", __LINE__);
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }



 static int pcie_rec_6_2(WDC_DEVICE_HANDLE hDev2, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
 //   printf(" istart = %d\n", istart);
 //   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
//     dwAddrSpace =2;
//     u32Data = 0xf0000008;
//     dwOffset = tx_mode_reg;
//     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =cs_bar;
     u32Data = cs_init;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =cs_bar;
     u32Data = cs_start+nword*2;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =cs_bar;
      u64Data =0;
      dwOffset = t2_cs_reg;
      WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/4+1;
      if(nword%4 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
       dwAddrSpace =t2_tr_bar;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev2,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t2_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){            ///**** not up to date ****///
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout, %d\n", __LINE__);
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }



    static int xmit_boot(WDC_DEVICE_HANDLE hDev, int imod_xmit)
{
#include "wdc_defs.h"
#define  mb_xmit_conf_add 0x2

    FILE *inpf;
    int imod,ichip,count,counta,ichip_c,dummy1,ik,ij,i;
    unsigned char charchannel,carray[4000];
    int nsend,nword,k;
    UINT32 buf_send[10000],send_array[10000];
    UINT32 *px;
    struct timespec tim,tim2;
    tim.tv_sec=0;
    tim.tv_nsec = 128000;
//
//    boot up xmit module 1st
//
      nsend=500;
      px = &buf_send;
      printf(" boot xmit module \n");
      inpf = fopen("/home/ub/xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      return i;
}


    static int fem_boot(WDC_DEVICE_HANDLE hDev, int imod_fem)
{
#include "wdc_defs.h"
#define  mb_feb_conf_add 0x2

    FILE *inpf;
    int imod,ichip,count,counta,ichip_c,dummy1,ik,ij,i;
    unsigned char charchannel,carray[4000];
    int nsend,nword,k;
    UINT32 buf_send[10000],send_array[10000];
    UINT32 *px;
    struct timespec tim,tim2;
    tim.tv_sec=0;
    tim.tv_nsec = 128000;
//
//    boot up xmit module 1st
//
      nsend=500;
      px = &buf_send;
//
//    Boot stratix after XMIT module
//
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=imod_fem;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
      return i;
}




/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
/* Read/write address menu options */
enum {
    MENU_RW_ADDR_SET_ADDR_SPACE = 1,
    MENU_RW_ADDR_SET_MODE,
    MENU_RW_ADDR_SET_TRANS_TYPE,
    MENU_RW_ADDR_READ,
    MENU_RW_ADDR_WRITE,
    MENU_RW_ADDR_EXIT = DIAG_EXIT_MENU,
};

#define ACTIVE_ADDR_SPACE_NEEDS_INIT 0xFF

/* Read/write memory or I/O space address menu */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    static DWORD dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
    static WDC_ADDR_MODE mode = WDC_MODE_32;
    static BOOL fBlock = FALSE;

    /* Initialize active address space */
    if (ACTIVE_ADDR_SPACE_NEEDS_INIT == dwAddrSpace)
    {
        DWORD dwNumAddrSpaces = JSEB2_GetNumAddrSpaces(hDev);
        
        /* Find the first active address space */
        for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
        {
            if (WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
                break;
        }
        
        /* Sanity check */
        if (dwAddrSpace == dwNumAddrSpaces)
        {
            JSEB2_ERR("MenuReadWriteAddr: Error - no active address spaces found\n");
            dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
            return;
        }
    }

    do
    {
        printf("\n");
        printf("Read/write the device's memory and IO ranges\n");
        printf("---------------------------------------------\n");
        printf("%d. Change active address space for read/write "
            "(currently: BAR %ld)\n", MENU_RW_ADDR_SET_ADDR_SPACE, dwAddrSpace);
        printf("%d. Change active read/write mode (currently: %s)\n",
            MENU_RW_ADDR_SET_MODE,
            (WDC_MODE_8 == mode) ? "8 bit" : (WDC_MODE_16 == mode) ? "16 bit" :
            (WDC_MODE_32 == mode) ? "32 bit" : "64 bit");
        printf("%d. Toggle active transfer type (currently: %s)\n",
            MENU_RW_ADDR_SET_TRANS_TYPE,
            (fBlock ? "block transfers" : "non-block transfers"));
        printf("%d. Read from active address space\n", MENU_RW_ADDR_READ);
        printf("%d. Write to active address space\n", MENU_RW_ADDR_WRITE);
        printf("%d. Exit menu\n", MENU_RW_ADDR_EXIT);
        printf("\n");
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_ADDR_WRITE))
        {
            continue;
        }
        
        switch (option)
        {
        case MENU_RW_ADDR_EXIT: /* Exit menu */
            break;
        case MENU_RW_ADDR_SET_ADDR_SPACE: /* Set active address space for read/write address requests */
        {
            SetAddrSpace(hDev, &dwAddrSpace);
            break;
        }
        case MENU_RW_ADDR_SET_MODE: /* Set active mode for read/write address requests */
            WDC_DIAG_SetMode(&mode);
            break;
        case MENU_RW_ADDR_SET_TRANS_TYPE: /* Toggle active transfer type */
            fBlock = !fBlock;
            break;
        case MENU_RW_ADDR_READ:  /* Read from a memory or I/O address */
        case MENU_RW_ADDR_WRITE: /* Write to a memory or I/O address */
        {
            WDC_DIRECTION direction =
                (MENU_RW_ADDR_READ == option) ? WDC_READ : WDC_WRITE;

            if (fBlock)
                WDC_DIAG_ReadWriteBlock(hDev, direction, dwAddrSpace);
            else
                WDC_DIAG_ReadWriteAddr(hDev, direction, dwAddrSpace, mode);
            
            break;
        }
        }
    } while (MENU_RW_ADDR_EXIT != option);
}

static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace)
{
    DWORD dwAddrSpace;
    DWORD dwNumAddrSpaces = JSEB2_GetNumAddrSpaces(hDev);
    JSEB2_ADDR_SPACE_INFO addrSpaceInfo;
    
    printf("\n");
    printf("Select an active address space:\n");
    printf("-------------------------------\n");

    for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
    {
        BZERO(addrSpaceInfo);
        addrSpaceInfo.dwAddrSpace = dwAddrSpace;
        if (!JSEB2_GetAddrSpaceInfo(hDev, &addrSpaceInfo))
        {
            JSEB2_ERR("SetAddrSpace: Error - Failed to get address space information: %s",
                JSEB2_GetLastErr());
            return;
        }

        printf("%ld. %-*s %-*s %s\n",
            dwAddrSpace + 1,
            MAX_NAME_DISPLAY, addrSpaceInfo.sName,
            MAX_TYPE - 1, addrSpaceInfo.sType,
            addrSpaceInfo.sDesc);
    }
    printf("\n");

    if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwAddrSpace,
        "Enter option", FALSE, 1, dwNumAddrSpaces))
    {
         return;
    }

    dwAddrSpace--;
    if (!WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
    {
        printf("You have selected an inactive address space\n");
        return;
    }
            
    *pdwAddrSpace = dwAddrSpace;
}

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
/* Read/write the configuration space menu options */
enum {
    MENU_RW_CFG_SPACE_READ_OFFSET = 1,
    MENU_RW_CFG_SPACE_WRITE_OFFSET,
    MENU_RW_CFG_SPACE_READ_ALL_REGS,
    MENU_RW_CFG_SPACE_READ_REG,
    MENU_RW_CFG_SPACE_WRITE_REG,
    MENU_RW_CFG_SPACE_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write configuration space menu */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
  
    do {
        /* Display pre-defined registers' information */
        if (JSEB2_CFG_REGS_NUM)
        {
            printf("\n");
            printf("Configuration registers:\n");
            printf("------------------------\n");
            WDC_DIAG_RegsInfoPrint(gpJSEB2_CfgRegs, JSEB2_CFG_REGS_NUM,
                WDC_DIAG_REG_PRINT_ALL & ~WDC_DIAG_REG_PRINT_ADDR_SPACE);
        }

        printf("\n");
        printf("Read/write the device's configuration space\n");
        printf("--------------------------------------------\n");
        printf("%d. Read from an offset\n", MENU_RW_CFG_SPACE_READ_OFFSET);
        printf("%d. Write to an offset\n", MENU_RW_CFG_SPACE_WRITE_OFFSET);
        if (JSEB2_CFG_REGS_NUM)
        {
            printf("%d. Read all configuration registers defined for the device (see list above)\n",
                MENU_RW_CFG_SPACE_READ_ALL_REGS);
            printf("%d. Read from a named register\n", MENU_RW_CFG_SPACE_READ_REG);
            printf("%d. Write to a named register\n", MENU_RW_CFG_SPACE_WRITE_REG);
        }
        printf("%d. Exit menu\n", MENU_RW_CFG_SPACE_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            JSEB2_CFG_REGS_NUM ? MENU_RW_CFG_SPACE_WRITE_REG :
            MENU_RW_CFG_SPACE_WRITE_OFFSET))
        {
            continue;
        }

        switch (option)
        {
        case MENU_RW_CFG_SPACE_EXIT: /* Exit menu */
            break;
        case MENU_RW_CFG_SPACE_READ_OFFSET: /* Read from a configuration space offset */
            WDC_DIAG_ReadWriteBlock(hDev, WDC_READ, WDC_AD_CFG_SPACE);
            break;
        case MENU_RW_CFG_SPACE_WRITE_OFFSET: /* Write to a configuration space offset */
            WDC_DIAG_ReadWriteBlock(hDev, WDC_WRITE, WDC_AD_CFG_SPACE);
            break;
        case MENU_RW_CFG_SPACE_READ_ALL_REGS:
            WDC_DIAG_ReadRegsAll(hDev, gpJSEB2_CfgRegs, JSEB2_CFG_REGS_NUM, TRUE);
            break;
        case MENU_RW_CFG_SPACE_READ_REG:  /* Read from a configuration register */
            WDC_DIAG_ReadWriteReg(hDev, gpJSEB2_CfgRegs, JSEB2_CFG_REGS_NUM, WDC_READ, TRUE);
            break;
        case MENU_RW_CFG_SPACE_WRITE_REG: /* Write to a configuration register */
            WDC_DIAG_ReadWriteReg(hDev, gpJSEB2_CfgRegs, JSEB2_CFG_REGS_NUM, WDC_WRITE, TRUE);
            break;
        }
    } while (MENU_RW_CFG_SPACE_EXIT != option);
}

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
/* Read/write the run-time registers menu options */
enum {
    MENU_RW_REGS_READ_ALL = 1,
    MENU_RW_REGS_READ_REG,
    MENU_RW_REGS_WRITE_REG,
    MENU_RW_REGS_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write run-time registers menu */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    
    if (!JSEB2_REGS_NUM)
    {
        printf("There are currently no pre-defined run-time registers\n");
        return;
    }
  
    do {
        /* Display pre-defined registers' information */
        printf("\n");
        printf("JSEB2 run-time registers:\n");
        printf("--------------------------\n");   
        WDC_DIAG_RegsInfoPrint(gpJSEB2_Regs, JSEB2_REGS_NUM, WDC_DIAG_REG_PRINT_ALL);

        printf("\n");
        printf("Read/write the JSEB2 run-time registers\n");
        printf("-----------------------------------------\n");
        printf("%d. Read all run-time registers defined for the device (see list above)\n",
            MENU_RW_REGS_READ_ALL);
        printf("%d. Read from a specific register\n", MENU_RW_REGS_READ_REG);
        printf("%d. Write to a specific register\n", MENU_RW_REGS_WRITE_REG);
        printf("%d. Exit menu\n", MENU_RW_REGS_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_REGS_WRITE_REG))
        {
            continue;
        }

        switch (option)
        {
        case MENU_RW_REGS_EXIT: /* Exit menu */
            break;
        case MENU_RW_REGS_READ_ALL:
            WDC_DIAG_ReadRegsAll(hDev, gpJSEB2_Regs, JSEB2_REGS_NUM, FALSE);
            break;
        case MENU_RW_REGS_READ_REG:  /* Read from a register */
            WDC_DIAG_ReadWriteReg(hDev, gpJSEB2_Regs, JSEB2_REGS_NUM, WDC_READ, FALSE);
            break;
        case MENU_RW_REGS_WRITE_REG: /* Write to a register */
            WDC_DIAG_ReadWriteReg(hDev, gpJSEB2_Regs, JSEB2_REGS_NUM, WDC_WRITE, FALSE);
            break;
        }
    } while (MENU_RW_REGS_EXIT != option);
}

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
/* Interrupts menu options */
enum {
    MENU_INT_ENABLE_DISABLE = 1,
    MENU_INT_EXIT = DIAG_EXIT_MENU,
};

/* Enable/Disable interrupts menu */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev)
{
    DWORD option, dwIntOptions;
    BOOL fIntEnable, fIsMsi;

    dwIntOptions = WDC_GET_INT_OPTIONS(hDev);
    fIsMsi = WDC_INT_IS_MSI(dwIntOptions);
    if (dwIntOptions & INTERRUPT_LEVEL_SENSITIVE)
    {
        /* TODO: You can remove this message after you have modified the
           implementation of JSEB2_IntEnable() in pcie_lib.c to 
           correctly acknowledge level-sensitive interrupts (see guidelines
           in JSEB2_IntEnable()) */
        printf("\n");
        printf("WARNING!!!\n");
        printf("----------\n");
        printf("Your hardware has level sensitive interrupts.\n");
        printf("Before enabling the interrupts, %s first modify the source "
           "code of JSEB2_IntEnable(), in the file pcie_lib.c, to "
           "correctly acknowledge\n%s interrupts when they occur (as dictated by "
           "the hardware's specifications)\n",
           fIsMsi ? "it's recommended that you" : "you must",
           fIsMsi ? "level sensitive" : "");    }

    do
    {
        fIntEnable = !JSEB2_IntIsEnabled(hDev);

        printf("\n");
        printf("Interrupts\n");
        printf("-----------\n");
        printf("%d. %s interrupts\n", MENU_INT_ENABLE_DISABLE,
            fIntEnable ? "Enable" : "Disable");
        printf("%d. Exit menu\n", MENU_INT_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_ADDR_WRITE))
        {
            continue;
        }

        switch (option)
        {
        case MENU_INT_EXIT: /* Exit menu */
            break;
        case MENU_INT_ENABLE_DISABLE: /* Enable/disable interrupts */
            if (fIntEnable)
            {
                DWORD dwStatus = JSEB2_IntEnable(hDev, DiagIntHandler);

                if (WD_STATUS_SUCCESS == dwStatus)
                    printf("Interrupts enabled\n");
                else
                {
                    JSEB2_ERR("Failed enabling interrupts. Error 0x%lx - %s\n",
                       dwStatus, Stat2Str(dwStatus));
                }
            }
            else
            {
                if (WD_STATUS_SUCCESS == JSEB2_IntDisable(hDev))
                    printf("Interrupts disabled\n");
                else
                    JSEB2_ERR("Failed disabling interrupts: %s", JSEB2_GetLastErr());
            }
            break;
        }
    } while (MENU_INT_EXIT != option);
}

/* Diagnostics interrupt handler routine */
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, JSEB2_INT_RESULT *pIntResult)
{
    /* TODO: You can modify this function in order to implement your own
             diagnostics interrupt handler routine */

    printf("Got interrupt number %ld\n", pIntResult->dwCounter);
    printf("Interrupt Type: %s\n",
        WDC_DIAG_IntTypeDescriptionGet(pIntResult->dwEnabledIntType));
    if (WDC_INT_IS_MSI(pIntResult->dwEnabledIntType))
        printf("Message Data: 0x%lx\n", pIntResult->dwLastMessage);
}

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
/* Events menu options */
enum {
    MENU_EVENTS_REGISTER_UNREGISTER = 1,
    MENU_EVENTS_EXIT = DIAG_EXIT_MENU,
};

/* Register/unregister Plug-and-play and power management events */
static void MenuEvents(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    BOOL fRegister;

    do
    {
        fRegister = !JSEB2_EventIsRegistered(hDev);
        
        printf("\n");
        printf("Plug-and-play and power management events\n");
        printf("------------------------------------------\n");
        printf("%d. %s events\n", MENU_EVENTS_REGISTER_UNREGISTER,
            fRegister ? "Register" : "Unregister");
        printf("%d. Exit menu\n", MENU_EVENTS_EXIT);
        printf("\n");
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_EVENTS_REGISTER_UNREGISTER))
        {
            continue;
        }

        switch (option)
        {
        case MENU_EVENTS_EXIT: /* Exit menu */
            break;
        case MENU_EVENTS_REGISTER_UNREGISTER: /* Register/unregister events */
            if (fRegister)
            {
                if (WD_STATUS_SUCCESS == JSEB2_EventRegister(hDev, DiagEventHandler))
                    printf("Events registered\n");
                else
                    JSEB2_ERR("Failed to register events. Last error:\n%s", JSEB2_GetLastErr());
            }
            else
            {
                if (WD_STATUS_SUCCESS == JSEB2_EventUnregister(hDev))
                    printf("Events unregistered\n");
                else
                    JSEB2_ERR("Failed to unregister events. Last Error:\n%s", JSEB2_GetLastErr());
            }
            break;
        }
    } while (MENU_EVENTS_EXIT != option);
}

/* Plug-and-play and power management events handler routine */
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction)
{
    /* TODO: You can modify this function in order to implement your own
             diagnostics events handler routine */

    printf("\nReceived event notification (device handle 0x%p): ", hDev);
    switch (dwAction)
    {
    case WD_INSERT:
        printf("WD_INSERT\n");
        break;
    case WD_REMOVE:
        printf("WD_REMOVE\n");
        break;
    case WD_POWER_CHANGED_D0:
        printf("WD_POWER_CHANGED_D0\n");
        break;
    case WD_POWER_CHANGED_D1:
        printf("WD_POWER_CHANGED_D1\n");
        break;
    case WD_POWER_CHANGED_D2:
        printf("WD_POWER_CHANGED_D2\n");
        break;
    case WD_POWER_CHANGED_D3:
        printf("WD_POWER_CHANGED_D3\n");
        break;
    case WD_POWER_SYSTEM_WORKING:
        printf("WD_POWER_SYSTEM_WORKING\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING1:
        printf("WD_POWER_SYSTEM_SLEEPING1\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING2:
        printf("WD_POWER_SYSTEM_SLEEPING2\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING3:
        printf("WD_POWER_SYSTEM_SLEEPING3\n");
        break;
    case WD_POWER_SYSTEM_HIBERNATE:
        printf("WD_POWER_SYSTEM_HIBERNATE\n");
        break;
    case WD_POWER_SYSTEM_SHUTDOWN:
        printf("WD_POWER_SYSTEM_SHUTDOWN\n");
        break;
    default:
        printf("0x%lx\n", dwAction);
        break;
    }
}

